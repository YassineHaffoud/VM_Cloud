/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
import { __asyncDelegator, __asyncGenerator, __asyncValues, __await, __awaiter } from "tslib";
import * as coreClient from "@azure/core-client";
import { LroEngine } from "@azure/core-lro";
import { LroImpl } from "./lroImpl";
import { ApplicationGatewaysImpl, ApplicationGatewayPrivateLinkResourcesImpl, ApplicationGatewayPrivateEndpointConnectionsImpl, ApplicationSecurityGroupsImpl, AvailableDelegationsImpl, AvailableResourceGroupDelegationsImpl, AvailableServiceAliasesImpl, AzureFirewallsImpl, AzureFirewallFqdnTagsImpl, WebCategoriesImpl, BastionHostsImpl, NetworkInterfacesImpl, PublicIPAddressesImpl, CustomIPPrefixesImpl, DdosCustomPoliciesImpl, DdosProtectionPlansImpl, DscpConfigurationOperationsImpl, AvailableEndpointServicesImpl, ExpressRouteCircuitAuthorizationsImpl, ExpressRouteCircuitPeeringsImpl, ExpressRouteCircuitConnectionsImpl, PeerExpressRouteCircuitConnectionsImpl, ExpressRouteCircuitsImpl, ExpressRouteServiceProvidersImpl, ExpressRouteCrossConnectionsImpl, ExpressRouteCrossConnectionPeeringsImpl, ExpressRoutePortsLocationsImpl, ExpressRoutePortsImpl, ExpressRouteLinksImpl, FirewallPoliciesImpl, FirewallPolicyRuleCollectionGroupsImpl, FirewallPolicyIdpsSignaturesImpl, FirewallPolicyIdpsSignaturesOverridesImpl, FirewallPolicyIdpsSignaturesFilterValuesImpl, IpAllocationsImpl, IpGroupsImpl, LoadBalancersImpl, LoadBalancerBackendAddressPoolsImpl, LoadBalancerFrontendIPConfigurationsImpl, InboundNatRulesImpl, LoadBalancerLoadBalancingRulesImpl, LoadBalancerOutboundRulesImpl, LoadBalancerNetworkInterfacesImpl, LoadBalancerProbesImpl, NatGatewaysImpl, NetworkInterfaceIPConfigurationsImpl, NetworkInterfaceLoadBalancersImpl, NetworkInterfaceTapConfigurationsImpl, NetworkProfilesImpl, NetworkSecurityGroupsImpl, SecurityRulesImpl, DefaultSecurityRulesImpl, NetworkVirtualAppliancesImpl, VirtualApplianceSitesImpl, VirtualApplianceSkusImpl, InboundSecurityRuleOperationsImpl, NetworkWatchersImpl, PacketCapturesImpl, ConnectionMonitorsImpl, FlowLogsImpl, OperationsImpl, PrivateEndpointsImpl, AvailablePrivateEndpointTypesImpl, PrivateDnsZoneGroupsImpl, PrivateLinkServicesImpl, PublicIPPrefixesImpl, RouteFiltersImpl, RouteFilterRulesImpl, RouteTablesImpl, RoutesImpl, SecurityPartnerProvidersImpl, BgpServiceCommunitiesImpl, ServiceEndpointPoliciesImpl, ServiceEndpointPolicyDefinitionsImpl, ServiceTagsImpl, ServiceTagInformationOperationsImpl, UsagesImpl, VirtualNetworksImpl, SubnetsImpl, ResourceNavigationLinksImpl, ServiceAssociationLinksImpl, VirtualNetworkPeeringsImpl, VirtualNetworkGatewaysImpl, VirtualNetworkGatewayConnectionsImpl, LocalNetworkGatewaysImpl, VirtualNetworkGatewayNatRulesImpl, VirtualNetworkTapsImpl, VirtualRoutersImpl, VirtualRouterPeeringsImpl, VirtualWansImpl, VpnSitesImpl, VpnSiteLinksImpl, VpnSitesConfigurationImpl, VpnServerConfigurationsImpl, VirtualHubsImpl, HubVirtualNetworkConnectionsImpl, VpnGatewaysImpl, VpnLinkConnectionsImpl, VpnConnectionsImpl, VpnSiteLinkConnectionsImpl, NatRulesImpl, P2SVpnGatewaysImpl, VpnServerConfigurationsAssociatedWithVirtualWanImpl, VirtualHubRouteTableV2SImpl, ExpressRouteGatewaysImpl, ExpressRouteConnectionsImpl, VirtualHubBgpConnectionImpl, VirtualHubBgpConnectionsImpl, VirtualHubIpConfigurationImpl, HubRouteTablesImpl, RoutingIntentOperationsImpl, WebApplicationFirewallPoliciesImpl } from "./operations";
import * as Parameters from "./models/parameters";
import * as Mappers from "./models/mappers";
/// <reference lib="esnext.asynciterable" />
export class NetworkManagementClient extends coreClient.ServiceClient {
    /**
     * Initializes a new instance of the NetworkManagementClient class.
     * @param credentials Subscription credentials which uniquely identify client subscription.
     * @param subscriptionId The subscription credentials which uniquely identify the Microsoft Azure
     *                       subscription. The subscription ID forms part of the URI for every service call.
     * @param options The parameter options
     */
    constructor(credentials, subscriptionId, options) {
        if (credentials === undefined) {
            throw new Error("'credentials' cannot be null");
        }
        if (subscriptionId === undefined) {
            throw new Error("'subscriptionId' cannot be null");
        }
        // Initializing default values for options
        if (!options) {
            options = {};
        }
        const defaults = {
            requestContentType: "application/json; charset=utf-8",
            credential: credentials
        };
        const packageDetails = `azsdk-js-arm-network/26.0.0`;
        const userAgentPrefix = options.userAgentOptions && options.userAgentOptions.userAgentPrefix
            ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}`
            : `${packageDetails}`;
        if (!options.credentialScopes) {
            options.credentialScopes = ["https://management.azure.com/.default"];
        }
        const optionsWithDefaults = Object.assign(Object.assign(Object.assign({}, defaults), options), { userAgentOptions: {
                userAgentPrefix
            }, baseUri: options.endpoint || "https://management.azure.com" });
        super(optionsWithDefaults);
        // Parameter assignments
        this.subscriptionId = subscriptionId;
        // Assigning values to Constant parameters
        this.$host = options.$host || "https://management.azure.com";
        this.applicationGateways = new ApplicationGatewaysImpl(this);
        this.applicationGatewayPrivateLinkResources = new ApplicationGatewayPrivateLinkResourcesImpl(this);
        this.applicationGatewayPrivateEndpointConnections = new ApplicationGatewayPrivateEndpointConnectionsImpl(this);
        this.applicationSecurityGroups = new ApplicationSecurityGroupsImpl(this);
        this.availableDelegations = new AvailableDelegationsImpl(this);
        this.availableResourceGroupDelegations = new AvailableResourceGroupDelegationsImpl(this);
        this.availableServiceAliases = new AvailableServiceAliasesImpl(this);
        this.azureFirewalls = new AzureFirewallsImpl(this);
        this.azureFirewallFqdnTags = new AzureFirewallFqdnTagsImpl(this);
        this.webCategories = new WebCategoriesImpl(this);
        this.bastionHosts = new BastionHostsImpl(this);
        this.networkInterfaces = new NetworkInterfacesImpl(this);
        this.publicIPAddresses = new PublicIPAddressesImpl(this);
        this.customIPPrefixes = new CustomIPPrefixesImpl(this);
        this.ddosCustomPolicies = new DdosCustomPoliciesImpl(this);
        this.ddosProtectionPlans = new DdosProtectionPlansImpl(this);
        this.dscpConfigurationOperations = new DscpConfigurationOperationsImpl(this);
        this.availableEndpointServices = new AvailableEndpointServicesImpl(this);
        this.expressRouteCircuitAuthorizations = new ExpressRouteCircuitAuthorizationsImpl(this);
        this.expressRouteCircuitPeerings = new ExpressRouteCircuitPeeringsImpl(this);
        this.expressRouteCircuitConnections = new ExpressRouteCircuitConnectionsImpl(this);
        this.peerExpressRouteCircuitConnections = new PeerExpressRouteCircuitConnectionsImpl(this);
        this.expressRouteCircuits = new ExpressRouteCircuitsImpl(this);
        this.expressRouteServiceProviders = new ExpressRouteServiceProvidersImpl(this);
        this.expressRouteCrossConnections = new ExpressRouteCrossConnectionsImpl(this);
        this.expressRouteCrossConnectionPeerings = new ExpressRouteCrossConnectionPeeringsImpl(this);
        this.expressRoutePortsLocations = new ExpressRoutePortsLocationsImpl(this);
        this.expressRoutePorts = new ExpressRoutePortsImpl(this);
        this.expressRouteLinks = new ExpressRouteLinksImpl(this);
        this.firewallPolicies = new FirewallPoliciesImpl(this);
        this.firewallPolicyRuleCollectionGroups = new FirewallPolicyRuleCollectionGroupsImpl(this);
        this.firewallPolicyIdpsSignatures = new FirewallPolicyIdpsSignaturesImpl(this);
        this.firewallPolicyIdpsSignaturesOverrides = new FirewallPolicyIdpsSignaturesOverridesImpl(this);
        this.firewallPolicyIdpsSignaturesFilterValues = new FirewallPolicyIdpsSignaturesFilterValuesImpl(this);
        this.ipAllocations = new IpAllocationsImpl(this);
        this.ipGroups = new IpGroupsImpl(this);
        this.loadBalancers = new LoadBalancersImpl(this);
        this.loadBalancerBackendAddressPools = new LoadBalancerBackendAddressPoolsImpl(this);
        this.loadBalancerFrontendIPConfigurations = new LoadBalancerFrontendIPConfigurationsImpl(this);
        this.inboundNatRules = new InboundNatRulesImpl(this);
        this.loadBalancerLoadBalancingRules = new LoadBalancerLoadBalancingRulesImpl(this);
        this.loadBalancerOutboundRules = new LoadBalancerOutboundRulesImpl(this);
        this.loadBalancerNetworkInterfaces = new LoadBalancerNetworkInterfacesImpl(this);
        this.loadBalancerProbes = new LoadBalancerProbesImpl(this);
        this.natGateways = new NatGatewaysImpl(this);
        this.networkInterfaceIPConfigurations = new NetworkInterfaceIPConfigurationsImpl(this);
        this.networkInterfaceLoadBalancers = new NetworkInterfaceLoadBalancersImpl(this);
        this.networkInterfaceTapConfigurations = new NetworkInterfaceTapConfigurationsImpl(this);
        this.networkProfiles = new NetworkProfilesImpl(this);
        this.networkSecurityGroups = new NetworkSecurityGroupsImpl(this);
        this.securityRules = new SecurityRulesImpl(this);
        this.defaultSecurityRules = new DefaultSecurityRulesImpl(this);
        this.networkVirtualAppliances = new NetworkVirtualAppliancesImpl(this);
        this.virtualApplianceSites = new VirtualApplianceSitesImpl(this);
        this.virtualApplianceSkus = new VirtualApplianceSkusImpl(this);
        this.inboundSecurityRuleOperations = new InboundSecurityRuleOperationsImpl(this);
        this.networkWatchers = new NetworkWatchersImpl(this);
        this.packetCaptures = new PacketCapturesImpl(this);
        this.connectionMonitors = new ConnectionMonitorsImpl(this);
        this.flowLogs = new FlowLogsImpl(this);
        this.operations = new OperationsImpl(this);
        this.privateEndpoints = new PrivateEndpointsImpl(this);
        this.availablePrivateEndpointTypes = new AvailablePrivateEndpointTypesImpl(this);
        this.privateDnsZoneGroups = new PrivateDnsZoneGroupsImpl(this);
        this.privateLinkServices = new PrivateLinkServicesImpl(this);
        this.publicIPPrefixes = new PublicIPPrefixesImpl(this);
        this.routeFilters = new RouteFiltersImpl(this);
        this.routeFilterRules = new RouteFilterRulesImpl(this);
        this.routeTables = new RouteTablesImpl(this);
        this.routes = new RoutesImpl(this);
        this.securityPartnerProviders = new SecurityPartnerProvidersImpl(this);
        this.bgpServiceCommunities = new BgpServiceCommunitiesImpl(this);
        this.serviceEndpointPolicies = new ServiceEndpointPoliciesImpl(this);
        this.serviceEndpointPolicyDefinitions = new ServiceEndpointPolicyDefinitionsImpl(this);
        this.serviceTags = new ServiceTagsImpl(this);
        this.serviceTagInformationOperations = new ServiceTagInformationOperationsImpl(this);
        this.usages = new UsagesImpl(this);
        this.virtualNetworks = new VirtualNetworksImpl(this);
        this.subnets = new SubnetsImpl(this);
        this.resourceNavigationLinks = new ResourceNavigationLinksImpl(this);
        this.serviceAssociationLinks = new ServiceAssociationLinksImpl(this);
        this.virtualNetworkPeerings = new VirtualNetworkPeeringsImpl(this);
        this.virtualNetworkGateways = new VirtualNetworkGatewaysImpl(this);
        this.virtualNetworkGatewayConnections = new VirtualNetworkGatewayConnectionsImpl(this);
        this.localNetworkGateways = new LocalNetworkGatewaysImpl(this);
        this.virtualNetworkGatewayNatRules = new VirtualNetworkGatewayNatRulesImpl(this);
        this.virtualNetworkTaps = new VirtualNetworkTapsImpl(this);
        this.virtualRouters = new VirtualRoutersImpl(this);
        this.virtualRouterPeerings = new VirtualRouterPeeringsImpl(this);
        this.virtualWans = new VirtualWansImpl(this);
        this.vpnSites = new VpnSitesImpl(this);
        this.vpnSiteLinks = new VpnSiteLinksImpl(this);
        this.vpnSitesConfiguration = new VpnSitesConfigurationImpl(this);
        this.vpnServerConfigurations = new VpnServerConfigurationsImpl(this);
        this.virtualHubs = new VirtualHubsImpl(this);
        this.hubVirtualNetworkConnections = new HubVirtualNetworkConnectionsImpl(this);
        this.vpnGateways = new VpnGatewaysImpl(this);
        this.vpnLinkConnections = new VpnLinkConnectionsImpl(this);
        this.vpnConnections = new VpnConnectionsImpl(this);
        this.vpnSiteLinkConnections = new VpnSiteLinkConnectionsImpl(this);
        this.natRules = new NatRulesImpl(this);
        this.p2SVpnGateways = new P2SVpnGatewaysImpl(this);
        this.vpnServerConfigurationsAssociatedWithVirtualWan = new VpnServerConfigurationsAssociatedWithVirtualWanImpl(this);
        this.virtualHubRouteTableV2S = new VirtualHubRouteTableV2SImpl(this);
        this.expressRouteGateways = new ExpressRouteGatewaysImpl(this);
        this.expressRouteConnections = new ExpressRouteConnectionsImpl(this);
        this.virtualHubBgpConnection = new VirtualHubBgpConnectionImpl(this);
        this.virtualHubBgpConnections = new VirtualHubBgpConnectionsImpl(this);
        this.virtualHubIpConfiguration = new VirtualHubIpConfigurationImpl(this);
        this.hubRouteTables = new HubRouteTablesImpl(this);
        this.routingIntentOperations = new RoutingIntentOperationsImpl(this);
        this.webApplicationFirewallPolicies = new WebApplicationFirewallPoliciesImpl(this);
    }
    /**
     * Creates a Bastion Shareable Links for all the VMs specified in the request.
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostName The name of the Bastion Host.
     * @param bslRequest Post request for all the Bastion Shareable Link endpoints.
     * @param options The options parameters.
     */
    beginListPutBastionShareableLinkAndWait(resourceGroupName, bastionHostName, bslRequest, options) {
        const iter = this.putBastionShareableLinkPagingAll(resourceGroupName, bastionHostName, bslRequest, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.putBastionShareableLinkPagingPage(resourceGroupName, bastionHostName, bslRequest, options);
            }
        };
    }
    putBastionShareableLinkPagingPage(resourceGroupName, bastionHostName, bslRequest, options) {
        return __asyncGenerator(this, arguments, function* putBastionShareableLinkPagingPage_1() {
            const poller = yield __await(this._putBastionShareableLink(resourceGroupName, bastionHostName, bslRequest, options));
            let result = yield __await(poller.pollUntilDone());
            yield yield __await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield __await(this._putBastionShareableLinkNext(resourceGroupName, bastionHostName, bslRequest, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield __await(result.value || []);
            }
        });
    }
    putBastionShareableLinkPagingAll(resourceGroupName, bastionHostName, bslRequest, options) {
        return __asyncGenerator(this, arguments, function* putBastionShareableLinkPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = __asyncValues(this.putBastionShareableLinkPagingPage(resourceGroupName, bastionHostName, bslRequest, options)), _c; _c = yield __await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield __await(yield* __asyncDelegator(__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield __await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Return the Bastion Shareable Links for all the VMs specified in the request.
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostName The name of the Bastion Host.
     * @param bslRequest Post request for all the Bastion Shareable Link endpoints.
     * @param options The options parameters.
     */
    listBastionShareableLink(resourceGroupName, bastionHostName, bslRequest, options) {
        const iter = this.getBastionShareableLinkPagingAll(resourceGroupName, bastionHostName, bslRequest, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.getBastionShareableLinkPagingPage(resourceGroupName, bastionHostName, bslRequest, options);
            }
        };
    }
    getBastionShareableLinkPagingPage(resourceGroupName, bastionHostName, bslRequest, options) {
        return __asyncGenerator(this, arguments, function* getBastionShareableLinkPagingPage_1() {
            let result = yield __await(this._getBastionShareableLink(resourceGroupName, bastionHostName, bslRequest, options));
            yield yield __await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield __await(this._getBastionShareableLinkNext(resourceGroupName, bastionHostName, bslRequest, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield __await(result.value || []);
            }
        });
    }
    getBastionShareableLinkPagingAll(resourceGroupName, bastionHostName, bslRequest, options) {
        return __asyncGenerator(this, arguments, function* getBastionShareableLinkPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = __asyncValues(this.getBastionShareableLinkPagingPage(resourceGroupName, bastionHostName, bslRequest, options)), _c; _c = yield __await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield __await(yield* __asyncDelegator(__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield __await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Returns the list of currently active sessions on the Bastion.
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostName The name of the Bastion Host.
     * @param options The options parameters.
     */
    beginListActiveSessionsAndWait(resourceGroupName, bastionHostName, options) {
        const iter = this.getActiveSessionsPagingAll(resourceGroupName, bastionHostName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.getActiveSessionsPagingPage(resourceGroupName, bastionHostName, options);
            }
        };
    }
    getActiveSessionsPagingPage(resourceGroupName, bastionHostName, options) {
        return __asyncGenerator(this, arguments, function* getActiveSessionsPagingPage_1() {
            const poller = yield __await(this._getActiveSessions(resourceGroupName, bastionHostName, options));
            let result = yield __await(poller.pollUntilDone());
            yield yield __await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield __await(this._getActiveSessionsNext(resourceGroupName, bastionHostName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield __await(result.value || []);
            }
        });
    }
    getActiveSessionsPagingAll(resourceGroupName, bastionHostName, options) {
        return __asyncGenerator(this, arguments, function* getActiveSessionsPagingAll_1() {
            var e_3, _a;
            try {
                for (var _b = __asyncValues(this.getActiveSessionsPagingPage(resourceGroupName, bastionHostName, options)), _c; _c = yield __await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield __await(yield* __asyncDelegator(__asyncValues(page)));
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield __await(_a.call(_b));
                }
                finally { if (e_3) throw e_3.error; }
            }
        });
    }
    /**
     * Returns the list of currently active sessions on the Bastion.
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostName The name of the Bastion Host.
     * @param sessionIds The list of sessionids to disconnect.
     * @param options The options parameters.
     */
    listDisconnectActiveSessions(resourceGroupName, bastionHostName, sessionIds, options) {
        const iter = this.disconnectActiveSessionsPagingAll(resourceGroupName, bastionHostName, sessionIds, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.disconnectActiveSessionsPagingPage(resourceGroupName, bastionHostName, sessionIds, options);
            }
        };
    }
    disconnectActiveSessionsPagingPage(resourceGroupName, bastionHostName, sessionIds, options) {
        return __asyncGenerator(this, arguments, function* disconnectActiveSessionsPagingPage_1() {
            let result = yield __await(this._disconnectActiveSessions(resourceGroupName, bastionHostName, sessionIds, options));
            yield yield __await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield __await(this._disconnectActiveSessionsNext(resourceGroupName, bastionHostName, sessionIds, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield __await(result.value || []);
            }
        });
    }
    disconnectActiveSessionsPagingAll(resourceGroupName, bastionHostName, sessionIds, options) {
        return __asyncGenerator(this, arguments, function* disconnectActiveSessionsPagingAll_1() {
            var e_4, _a;
            try {
                for (var _b = __asyncValues(this.disconnectActiveSessionsPagingPage(resourceGroupName, bastionHostName, sessionIds, options)), _c; _c = yield __await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield __await(yield* __asyncDelegator(__asyncValues(page)));
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield __await(_a.call(_b));
                }
                finally { if (e_4) throw e_4.error; }
            }
        });
    }
    /**
     * Creates a Bastion Shareable Links for all the VMs specified in the request.
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostName The name of the Bastion Host.
     * @param bslRequest Post request for all the Bastion Shareable Link endpoints.
     * @param options The options parameters.
     */
    _putBastionShareableLink(resourceGroupName, bastionHostName, bslRequest, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                return this.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, bastionHostName, bslRequest, options }, putBastionShareableLinkOperationSpec);
            return new LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Deletes the Bastion Shareable Links for all the VMs specified in the request.
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostName The name of the Bastion Host.
     * @param bslRequest Post request for all the Bastion Shareable Link endpoints.
     * @param options The options parameters.
     */
    beginDeleteBastionShareableLink(resourceGroupName, bastionHostName, bslRequest, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                return this.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, bastionHostName, bslRequest, options }, deleteBastionShareableLinkOperationSpec);
            return new LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Deletes the Bastion Shareable Links for all the VMs specified in the request.
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostName The name of the Bastion Host.
     * @param bslRequest Post request for all the Bastion Shareable Link endpoints.
     * @param options The options parameters.
     */
    beginDeleteBastionShareableLinkAndWait(resourceGroupName, bastionHostName, bslRequest, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDeleteBastionShareableLink(resourceGroupName, bastionHostName, bslRequest, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Return the Bastion Shareable Links for all the VMs specified in the request.
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostName The name of the Bastion Host.
     * @param bslRequest Post request for all the Bastion Shareable Link endpoints.
     * @param options The options parameters.
     */
    _getBastionShareableLink(resourceGroupName, bastionHostName, bslRequest, options) {
        return this.sendOperationRequest({ resourceGroupName, bastionHostName, bslRequest, options }, getBastionShareableLinkOperationSpec);
    }
    /**
     * Returns the list of currently active sessions on the Bastion.
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostName The name of the Bastion Host.
     * @param options The options parameters.
     */
    _getActiveSessions(resourceGroupName, bastionHostName, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                return this.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, bastionHostName, options }, getActiveSessionsOperationSpec);
            return new LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Returns the list of currently active sessions on the Bastion.
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostName The name of the Bastion Host.
     * @param sessionIds The list of sessionids to disconnect.
     * @param options The options parameters.
     */
    _disconnectActiveSessions(resourceGroupName, bastionHostName, sessionIds, options) {
        return this.sendOperationRequest({ resourceGroupName, bastionHostName, sessionIds, options }, disconnectActiveSessionsOperationSpec);
    }
    /**
     * Checks whether a domain name in the cloudapp.azure.com zone is available for use.
     * @param location The location of the domain name.
     * @param domainNameLabel The domain name to be verified. It must conform to the following regular
     *                        expression: ^[a-z][a-z0-9-]{1,61}[a-z0-9]$.
     * @param options The options parameters.
     */
    checkDnsNameAvailability(location, domainNameLabel, options) {
        return this.sendOperationRequest({ location, domainNameLabel, options }, checkDnsNameAvailabilityOperationSpec);
    }
    /**
     * Gives the supported security providers for the virtual wan.
     * @param resourceGroupName The resource group name.
     * @param virtualWANName The name of the VirtualWAN for which supported security providers are needed.
     * @param options The options parameters.
     */
    supportedSecurityProviders(resourceGroupName, virtualWANName, options) {
        return this.sendOperationRequest({ resourceGroupName, virtualWANName, options }, supportedSecurityProvidersOperationSpec);
    }
    /**
     * Generates a unique VPN profile for P2S clients for VirtualWan and associated VpnServerConfiguration
     * combination in the specified resource group.
     * @param resourceGroupName The resource group name.
     * @param virtualWANName The name of the VirtualWAN whose associated VpnServerConfigurations is needed.
     * @param vpnClientParams Parameters supplied to the generate VirtualWan VPN profile generation
     *                        operation.
     * @param options The options parameters.
     */
    beginGeneratevirtualwanvpnserverconfigurationvpnprofile(resourceGroupName, virtualWANName, vpnClientParams, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                return this.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, virtualWANName, vpnClientParams, options }, generatevirtualwanvpnserverconfigurationvpnprofileOperationSpec);
            return new LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Generates a unique VPN profile for P2S clients for VirtualWan and associated VpnServerConfiguration
     * combination in the specified resource group.
     * @param resourceGroupName The resource group name.
     * @param virtualWANName The name of the VirtualWAN whose associated VpnServerConfigurations is needed.
     * @param vpnClientParams Parameters supplied to the generate VirtualWan VPN profile generation
     *                        operation.
     * @param options The options parameters.
     */
    beginGeneratevirtualwanvpnserverconfigurationvpnprofileAndWait(resourceGroupName, virtualWANName, vpnClientParams, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginGeneratevirtualwanvpnserverconfigurationvpnprofile(resourceGroupName, virtualWANName, vpnClientParams, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * PutBastionShareableLinkNext
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostName The name of the Bastion Host.
     * @param bslRequest Post request for all the Bastion Shareable Link endpoints.
     * @param nextLink The nextLink from the previous successful call to the PutBastionShareableLink
     *                 method.
     * @param options The options parameters.
     */
    _putBastionShareableLinkNext(resourceGroupName, bastionHostName, bslRequest, nextLink, options) {
        return this.sendOperationRequest({ resourceGroupName, bastionHostName, bslRequest, nextLink, options }, putBastionShareableLinkNextOperationSpec);
    }
    /**
     * GetBastionShareableLinkNext
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostName The name of the Bastion Host.
     * @param bslRequest Post request for all the Bastion Shareable Link endpoints.
     * @param nextLink The nextLink from the previous successful call to the GetBastionShareableLink
     *                 method.
     * @param options The options parameters.
     */
    _getBastionShareableLinkNext(resourceGroupName, bastionHostName, bslRequest, nextLink, options) {
        return this.sendOperationRequest({ resourceGroupName, bastionHostName, bslRequest, nextLink, options }, getBastionShareableLinkNextOperationSpec);
    }
    /**
     * GetActiveSessionsNext
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostName The name of the Bastion Host.
     * @param nextLink The nextLink from the previous successful call to the GetActiveSessions method.
     * @param options The options parameters.
     */
    _getActiveSessionsNext(resourceGroupName, bastionHostName, nextLink, options) {
        return this.sendOperationRequest({ resourceGroupName, bastionHostName, nextLink, options }, getActiveSessionsNextOperationSpec);
    }
    /**
     * DisconnectActiveSessionsNext
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostName The name of the Bastion Host.
     * @param sessionIds The list of sessionids to disconnect.
     * @param nextLink The nextLink from the previous successful call to the DisconnectActiveSessions
     *                 method.
     * @param options The options parameters.
     */
    _disconnectActiveSessionsNext(resourceGroupName, bastionHostName, sessionIds, nextLink, options) {
        return this.sendOperationRequest({ resourceGroupName, bastionHostName, sessionIds, nextLink, options }, disconnectActiveSessionsNextOperationSpec);
    }
}
// Operation Specifications
const serializer = coreClient.createSerializer(Mappers, /* isXml */ false);
const putBastionShareableLinkOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/bastionHosts/{bastionHostName}/createShareableLinks",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: Mappers.BastionShareableLinkListResult
        },
        201: {
            bodyMapper: Mappers.BastionShareableLinkListResult
        },
        202: {
            bodyMapper: Mappers.BastionShareableLinkListResult
        },
        204: {
            bodyMapper: Mappers.BastionShareableLinkListResult
        },
        default: {
            bodyMapper: Mappers.CloudError
        }
    },
    requestBody: Parameters.bslRequest,
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.resourceGroupName,
        Parameters.subscriptionId,
        Parameters.bastionHostName
    ],
    headerParameters: [Parameters.accept, Parameters.contentType],
    mediaType: "json",
    serializer
};
const deleteBastionShareableLinkOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/bastionHosts/{bastionHostName}/deleteShareableLinks",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: Mappers.CloudError
        }
    },
    requestBody: Parameters.bslRequest,
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.resourceGroupName,
        Parameters.subscriptionId,
        Parameters.bastionHostName
    ],
    headerParameters: [Parameters.accept, Parameters.contentType],
    mediaType: "json",
    serializer
};
const getBastionShareableLinkOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/bastionHosts/{bastionHostName}/getShareableLinks",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: Mappers.BastionShareableLinkListResult
        },
        default: {
            bodyMapper: Mappers.CloudError
        }
    },
    requestBody: Parameters.bslRequest,
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.resourceGroupName,
        Parameters.subscriptionId,
        Parameters.bastionHostName
    ],
    headerParameters: [Parameters.accept, Parameters.contentType],
    mediaType: "json",
    serializer
};
const getActiveSessionsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/bastionHosts/{bastionHostName}/getActiveSessions",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: Mappers.BastionActiveSessionListResult
        },
        201: {
            bodyMapper: Mappers.BastionActiveSessionListResult
        },
        202: {
            bodyMapper: Mappers.BastionActiveSessionListResult
        },
        204: {
            bodyMapper: Mappers.BastionActiveSessionListResult
        },
        default: {
            bodyMapper: Mappers.CloudError
        }
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.resourceGroupName,
        Parameters.subscriptionId,
        Parameters.bastionHostName
    ],
    headerParameters: [Parameters.accept],
    serializer
};
const disconnectActiveSessionsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/bastionHosts/{bastionHostName}/disconnectActiveSessions",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: Mappers.BastionSessionDeleteResult
        },
        default: {
            bodyMapper: Mappers.CloudError
        }
    },
    requestBody: Parameters.sessionIds,
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.resourceGroupName,
        Parameters.subscriptionId,
        Parameters.bastionHostName
    ],
    headerParameters: [Parameters.accept, Parameters.contentType],
    mediaType: "json",
    serializer
};
const checkDnsNameAvailabilityOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/locations/{location}/CheckDnsNameAvailability",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.DnsNameAvailabilityResult
        },
        default: {
            bodyMapper: Mappers.CloudError
        }
    },
    queryParameters: [Parameters.apiVersion, Parameters.domainNameLabel],
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.location
    ],
    headerParameters: [Parameters.accept],
    serializer
};
const supportedSecurityProvidersOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualWans/{virtualWANName}/supportedSecurityProviders",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.VirtualWanSecurityProviders
        },
        default: {
            bodyMapper: Mappers.CloudError
        }
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.resourceGroupName,
        Parameters.subscriptionId,
        Parameters.virtualWANName
    ],
    headerParameters: [Parameters.accept],
    serializer
};
const generatevirtualwanvpnserverconfigurationvpnprofileOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualWans/{virtualWANName}/GenerateVpnProfile",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: Mappers.VpnProfileResponse
        },
        201: {
            bodyMapper: Mappers.VpnProfileResponse
        },
        202: {
            bodyMapper: Mappers.VpnProfileResponse
        },
        204: {
            bodyMapper: Mappers.VpnProfileResponse
        },
        default: {
            bodyMapper: Mappers.CloudError
        }
    },
    requestBody: Parameters.vpnClientParams,
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.resourceGroupName,
        Parameters.subscriptionId,
        Parameters.virtualWANName
    ],
    headerParameters: [Parameters.accept, Parameters.contentType],
    mediaType: "json",
    serializer
};
const putBastionShareableLinkNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.BastionShareableLinkListResult
        },
        202: {},
        default: {
            bodyMapper: Mappers.CloudError
        }
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.resourceGroupName,
        Parameters.subscriptionId,
        Parameters.nextLink,
        Parameters.bastionHostName
    ],
    headerParameters: [Parameters.accept, Parameters.contentType],
    mediaType: "json",
    serializer
};
const getBastionShareableLinkNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.BastionShareableLinkListResult
        },
        default: {
            bodyMapper: Mappers.CloudError
        }
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.resourceGroupName,
        Parameters.subscriptionId,
        Parameters.nextLink,
        Parameters.bastionHostName
    ],
    headerParameters: [Parameters.accept, Parameters.contentType],
    mediaType: "json",
    serializer
};
const getActiveSessionsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.BastionActiveSessionListResult
        },
        202: {},
        default: {
            bodyMapper: Mappers.CloudError
        }
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.resourceGroupName,
        Parameters.subscriptionId,
        Parameters.nextLink,
        Parameters.bastionHostName
    ],
    headerParameters: [Parameters.accept],
    serializer
};
const disconnectActiveSessionsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.BastionSessionDeleteResult
        },
        default: {
            bodyMapper: Mappers.CloudError
        }
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.resourceGroupName,
        Parameters.subscriptionId,
        Parameters.nextLink,
        Parameters.bastionHostName
    ],
    headerParameters: [Parameters.accept, Parameters.contentType],
    mediaType: "json",
    serializer
};
//# sourceMappingURL=networkManagementClient.js.map