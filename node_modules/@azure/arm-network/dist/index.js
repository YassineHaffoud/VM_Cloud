'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tslib = require('tslib');
var coreClient = require('@azure/core-client');
var coreLro = require('@azure/core-lro');

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
(function (KnownApplicationGatewaySkuName) {
    KnownApplicationGatewaySkuName["StandardSmall"] = "Standard_Small";
    KnownApplicationGatewaySkuName["StandardMedium"] = "Standard_Medium";
    KnownApplicationGatewaySkuName["StandardLarge"] = "Standard_Large";
    KnownApplicationGatewaySkuName["WAFMedium"] = "WAF_Medium";
    KnownApplicationGatewaySkuName["WAFLarge"] = "WAF_Large";
    KnownApplicationGatewaySkuName["StandardV2"] = "Standard_v2";
    KnownApplicationGatewaySkuName["WAFV2"] = "WAF_v2";
})(exports.KnownApplicationGatewaySkuName || (exports.KnownApplicationGatewaySkuName = {}));
(function (KnownApplicationGatewayTier) {
    KnownApplicationGatewayTier["Standard"] = "Standard";
    KnownApplicationGatewayTier["WAF"] = "WAF";
    KnownApplicationGatewayTier["StandardV2"] = "Standard_v2";
    KnownApplicationGatewayTier["WAFV2"] = "WAF_v2";
})(exports.KnownApplicationGatewayTier || (exports.KnownApplicationGatewayTier = {}));
(function (KnownApplicationGatewaySslProtocol) {
    KnownApplicationGatewaySslProtocol["TLSv10"] = "TLSv1_0";
    KnownApplicationGatewaySslProtocol["TLSv11"] = "TLSv1_1";
    KnownApplicationGatewaySslProtocol["TLSv12"] = "TLSv1_2";
})(exports.KnownApplicationGatewaySslProtocol || (exports.KnownApplicationGatewaySslProtocol = {}));
(function (KnownApplicationGatewaySslPolicyType) {
    KnownApplicationGatewaySslPolicyType["Predefined"] = "Predefined";
    KnownApplicationGatewaySslPolicyType["Custom"] = "Custom";
})(exports.KnownApplicationGatewaySslPolicyType || (exports.KnownApplicationGatewaySslPolicyType = {}));
(function (KnownApplicationGatewaySslPolicyName) {
    KnownApplicationGatewaySslPolicyName["AppGwSslPolicy20150501"] = "AppGwSslPolicy20150501";
    KnownApplicationGatewaySslPolicyName["AppGwSslPolicy20170401"] = "AppGwSslPolicy20170401";
    KnownApplicationGatewaySslPolicyName["AppGwSslPolicy20170401S"] = "AppGwSslPolicy20170401S";
})(exports.KnownApplicationGatewaySslPolicyName || (exports.KnownApplicationGatewaySslPolicyName = {}));
(function (KnownApplicationGatewaySslCipherSuite) {
    KnownApplicationGatewaySslCipherSuite["TLSEcdheRSAWithAES256CBCSHA384"] = "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384";
    KnownApplicationGatewaySslCipherSuite["TLSEcdheRSAWithAES128CBCSHA256"] = "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256";
    KnownApplicationGatewaySslCipherSuite["TLSEcdheRSAWithAES256CBCSHA"] = "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA";
    KnownApplicationGatewaySslCipherSuite["TLSEcdheRSAWithAES128CBCSHA"] = "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA";
    KnownApplicationGatewaySslCipherSuite["TLSDHERSAWithAES256GCMSHA384"] = "TLS_DHE_RSA_WITH_AES_256_GCM_SHA384";
    KnownApplicationGatewaySslCipherSuite["TLSDHERSAWithAES128GCMSHA256"] = "TLS_DHE_RSA_WITH_AES_128_GCM_SHA256";
    KnownApplicationGatewaySslCipherSuite["TLSDHERSAWithAES256CBCSHA"] = "TLS_DHE_RSA_WITH_AES_256_CBC_SHA";
    KnownApplicationGatewaySslCipherSuite["TLSDHERSAWithAES128CBCSHA"] = "TLS_DHE_RSA_WITH_AES_128_CBC_SHA";
    KnownApplicationGatewaySslCipherSuite["TLSRSAWithAES256GCMSHA384"] = "TLS_RSA_WITH_AES_256_GCM_SHA384";
    KnownApplicationGatewaySslCipherSuite["TLSRSAWithAES128GCMSHA256"] = "TLS_RSA_WITH_AES_128_GCM_SHA256";
    KnownApplicationGatewaySslCipherSuite["TLSRSAWithAES256CBCSHA256"] = "TLS_RSA_WITH_AES_256_CBC_SHA256";
    KnownApplicationGatewaySslCipherSuite["TLSRSAWithAES128CBCSHA256"] = "TLS_RSA_WITH_AES_128_CBC_SHA256";
    KnownApplicationGatewaySslCipherSuite["TLSRSAWithAES256CBCSHA"] = "TLS_RSA_WITH_AES_256_CBC_SHA";
    KnownApplicationGatewaySslCipherSuite["TLSRSAWithAES128CBCSHA"] = "TLS_RSA_WITH_AES_128_CBC_SHA";
    KnownApplicationGatewaySslCipherSuite["TLSEcdheEcdsaWithAES256GCMSHA384"] = "TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384";
    KnownApplicationGatewaySslCipherSuite["TLSEcdheEcdsaWithAES128GCMSHA256"] = "TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256";
    KnownApplicationGatewaySslCipherSuite["TLSEcdheEcdsaWithAES256CBCSHA384"] = "TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384";
    KnownApplicationGatewaySslCipherSuite["TLSEcdheEcdsaWithAES128CBCSHA256"] = "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256";
    KnownApplicationGatewaySslCipherSuite["TLSEcdheEcdsaWithAES256CBCSHA"] = "TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA";
    KnownApplicationGatewaySslCipherSuite["TLSEcdheEcdsaWithAES128CBCSHA"] = "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA";
    KnownApplicationGatewaySslCipherSuite["TLSDHEDSSWithAES256CBCSHA256"] = "TLS_DHE_DSS_WITH_AES_256_CBC_SHA256";
    KnownApplicationGatewaySslCipherSuite["TLSDHEDSSWithAES128CBCSHA256"] = "TLS_DHE_DSS_WITH_AES_128_CBC_SHA256";
    KnownApplicationGatewaySslCipherSuite["TLSDHEDSSWithAES256CBCSHA"] = "TLS_DHE_DSS_WITH_AES_256_CBC_SHA";
    KnownApplicationGatewaySslCipherSuite["TLSDHEDSSWithAES128CBCSHA"] = "TLS_DHE_DSS_WITH_AES_128_CBC_SHA";
    KnownApplicationGatewaySslCipherSuite["TLSRSAWith3DESEDECBCSHA"] = "TLS_RSA_WITH_3DES_EDE_CBC_SHA";
    KnownApplicationGatewaySslCipherSuite["TLSDHEDSSWith3DESEDECBCSHA"] = "TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA";
    KnownApplicationGatewaySslCipherSuite["TLSEcdheRSAWithAES128GCMSHA256"] = "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256";
    KnownApplicationGatewaySslCipherSuite["TLSEcdheRSAWithAES256GCMSHA384"] = "TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384";
})(exports.KnownApplicationGatewaySslCipherSuite || (exports.KnownApplicationGatewaySslCipherSuite = {}));
(function (KnownApplicationGatewayOperationalState) {
    KnownApplicationGatewayOperationalState["Stopped"] = "Stopped";
    KnownApplicationGatewayOperationalState["Starting"] = "Starting";
    KnownApplicationGatewayOperationalState["Running"] = "Running";
    KnownApplicationGatewayOperationalState["Stopping"] = "Stopping";
})(exports.KnownApplicationGatewayOperationalState || (exports.KnownApplicationGatewayOperationalState = {}));
(function (KnownProvisioningState) {
    KnownProvisioningState["Succeeded"] = "Succeeded";
    KnownProvisioningState["Updating"] = "Updating";
    KnownProvisioningState["Deleting"] = "Deleting";
    KnownProvisioningState["Failed"] = "Failed";
})(exports.KnownProvisioningState || (exports.KnownProvisioningState = {}));
(function (KnownIPAllocationMethod) {
    KnownIPAllocationMethod["Static"] = "Static";
    KnownIPAllocationMethod["Dynamic"] = "Dynamic";
})(exports.KnownIPAllocationMethod || (exports.KnownIPAllocationMethod = {}));
(function (KnownApplicationGatewayProtocol) {
    KnownApplicationGatewayProtocol["Http"] = "Http";
    KnownApplicationGatewayProtocol["Https"] = "Https";
})(exports.KnownApplicationGatewayProtocol || (exports.KnownApplicationGatewayProtocol = {}));
(function (KnownIPVersion) {
    KnownIPVersion["IPv4"] = "IPv4";
    KnownIPVersion["IPv6"] = "IPv6";
})(exports.KnownIPVersion || (exports.KnownIPVersion = {}));
(function (KnownSecurityRuleProtocol) {
    KnownSecurityRuleProtocol["Tcp"] = "Tcp";
    KnownSecurityRuleProtocol["Udp"] = "Udp";
    KnownSecurityRuleProtocol["Icmp"] = "Icmp";
    KnownSecurityRuleProtocol["Esp"] = "Esp";
    KnownSecurityRuleProtocol["Asterisk"] = "*";
    KnownSecurityRuleProtocol["Ah"] = "Ah";
})(exports.KnownSecurityRuleProtocol || (exports.KnownSecurityRuleProtocol = {}));
(function (KnownSecurityRuleAccess) {
    KnownSecurityRuleAccess["Allow"] = "Allow";
    KnownSecurityRuleAccess["Deny"] = "Deny";
})(exports.KnownSecurityRuleAccess || (exports.KnownSecurityRuleAccess = {}));
(function (KnownSecurityRuleDirection) {
    KnownSecurityRuleDirection["Inbound"] = "Inbound";
    KnownSecurityRuleDirection["Outbound"] = "Outbound";
})(exports.KnownSecurityRuleDirection || (exports.KnownSecurityRuleDirection = {}));
(function (KnownExtendedLocationTypes) {
    KnownExtendedLocationTypes["EdgeZone"] = "EdgeZone";
})(exports.KnownExtendedLocationTypes || (exports.KnownExtendedLocationTypes = {}));
(function (KnownNetworkInterfaceNicType) {
    KnownNetworkInterfaceNicType["Standard"] = "Standard";
    KnownNetworkInterfaceNicType["Elastic"] = "Elastic";
})(exports.KnownNetworkInterfaceNicType || (exports.KnownNetworkInterfaceNicType = {}));
(function (KnownNetworkInterfaceMigrationPhase) {
    KnownNetworkInterfaceMigrationPhase["None"] = "None";
    KnownNetworkInterfaceMigrationPhase["Prepare"] = "Prepare";
    KnownNetworkInterfaceMigrationPhase["Commit"] = "Commit";
    KnownNetworkInterfaceMigrationPhase["Abort"] = "Abort";
    KnownNetworkInterfaceMigrationPhase["Committed"] = "Committed";
})(exports.KnownNetworkInterfaceMigrationPhase || (exports.KnownNetworkInterfaceMigrationPhase = {}));
(function (KnownFlowLogFormatType) {
    KnownFlowLogFormatType["Json"] = "JSON";
})(exports.KnownFlowLogFormatType || (exports.KnownFlowLogFormatType = {}));
(function (KnownRouteNextHopType) {
    KnownRouteNextHopType["VirtualNetworkGateway"] = "VirtualNetworkGateway";
    KnownRouteNextHopType["VnetLocal"] = "VnetLocal";
    KnownRouteNextHopType["Internet"] = "Internet";
    KnownRouteNextHopType["VirtualAppliance"] = "VirtualAppliance";
    KnownRouteNextHopType["None"] = "None";
})(exports.KnownRouteNextHopType || (exports.KnownRouteNextHopType = {}));
(function (KnownPublicIPAddressSkuName) {
    KnownPublicIPAddressSkuName["Basic"] = "Basic";
    KnownPublicIPAddressSkuName["Standard"] = "Standard";
})(exports.KnownPublicIPAddressSkuName || (exports.KnownPublicIPAddressSkuName = {}));
(function (KnownPublicIPAddressSkuTier) {
    KnownPublicIPAddressSkuTier["Regional"] = "Regional";
    KnownPublicIPAddressSkuTier["Global"] = "Global";
})(exports.KnownPublicIPAddressSkuTier || (exports.KnownPublicIPAddressSkuTier = {}));
(function (KnownDdosSettingsProtectionCoverage) {
    KnownDdosSettingsProtectionCoverage["Basic"] = "Basic";
    KnownDdosSettingsProtectionCoverage["Standard"] = "Standard";
})(exports.KnownDdosSettingsProtectionCoverage || (exports.KnownDdosSettingsProtectionCoverage = {}));
(function (KnownNatGatewaySkuName) {
    KnownNatGatewaySkuName["Standard"] = "Standard";
})(exports.KnownNatGatewaySkuName || (exports.KnownNatGatewaySkuName = {}));
(function (KnownPublicIPAddressMigrationPhase) {
    KnownPublicIPAddressMigrationPhase["None"] = "None";
    KnownPublicIPAddressMigrationPhase["Prepare"] = "Prepare";
    KnownPublicIPAddressMigrationPhase["Commit"] = "Commit";
    KnownPublicIPAddressMigrationPhase["Abort"] = "Abort";
    KnownPublicIPAddressMigrationPhase["Committed"] = "Committed";
})(exports.KnownPublicIPAddressMigrationPhase || (exports.KnownPublicIPAddressMigrationPhase = {}));
(function (KnownDeleteOptions) {
    KnownDeleteOptions["Delete"] = "Delete";
    KnownDeleteOptions["Detach"] = "Detach";
})(exports.KnownDeleteOptions || (exports.KnownDeleteOptions = {}));
(function (KnownVirtualNetworkPrivateEndpointNetworkPolicies) {
    KnownVirtualNetworkPrivateEndpointNetworkPolicies["Enabled"] = "Enabled";
    KnownVirtualNetworkPrivateEndpointNetworkPolicies["Disabled"] = "Disabled";
})(exports.KnownVirtualNetworkPrivateEndpointNetworkPolicies || (exports.KnownVirtualNetworkPrivateEndpointNetworkPolicies = {}));
(function (KnownVirtualNetworkPrivateLinkServiceNetworkPolicies) {
    KnownVirtualNetworkPrivateLinkServiceNetworkPolicies["Enabled"] = "Enabled";
    KnownVirtualNetworkPrivateLinkServiceNetworkPolicies["Disabled"] = "Disabled";
})(exports.KnownVirtualNetworkPrivateLinkServiceNetworkPolicies || (exports.KnownVirtualNetworkPrivateLinkServiceNetworkPolicies = {}));
(function (KnownGatewayLoadBalancerTunnelProtocol) {
    KnownGatewayLoadBalancerTunnelProtocol["None"] = "None";
    KnownGatewayLoadBalancerTunnelProtocol["Native"] = "Native";
    KnownGatewayLoadBalancerTunnelProtocol["Vxlan"] = "VXLAN";
})(exports.KnownGatewayLoadBalancerTunnelProtocol || (exports.KnownGatewayLoadBalancerTunnelProtocol = {}));
(function (KnownGatewayLoadBalancerTunnelInterfaceType) {
    KnownGatewayLoadBalancerTunnelInterfaceType["None"] = "None";
    KnownGatewayLoadBalancerTunnelInterfaceType["Internal"] = "Internal";
    KnownGatewayLoadBalancerTunnelInterfaceType["External"] = "External";
})(exports.KnownGatewayLoadBalancerTunnelInterfaceType || (exports.KnownGatewayLoadBalancerTunnelInterfaceType = {}));
(function (KnownTransportProtocol) {
    KnownTransportProtocol["Udp"] = "Udp";
    KnownTransportProtocol["Tcp"] = "Tcp";
    KnownTransportProtocol["All"] = "All";
})(exports.KnownTransportProtocol || (exports.KnownTransportProtocol = {}));
(function (KnownApplicationGatewayCookieBasedAffinity) {
    KnownApplicationGatewayCookieBasedAffinity["Enabled"] = "Enabled";
    KnownApplicationGatewayCookieBasedAffinity["Disabled"] = "Disabled";
})(exports.KnownApplicationGatewayCookieBasedAffinity || (exports.KnownApplicationGatewayCookieBasedAffinity = {}));
(function (KnownApplicationGatewayCustomErrorStatusCode) {
    KnownApplicationGatewayCustomErrorStatusCode["HttpStatus403"] = "HttpStatus403";
    KnownApplicationGatewayCustomErrorStatusCode["HttpStatus502"] = "HttpStatus502";
})(exports.KnownApplicationGatewayCustomErrorStatusCode || (exports.KnownApplicationGatewayCustomErrorStatusCode = {}));
(function (KnownApplicationGatewayRequestRoutingRuleType) {
    KnownApplicationGatewayRequestRoutingRuleType["Basic"] = "Basic";
    KnownApplicationGatewayRequestRoutingRuleType["PathBasedRouting"] = "PathBasedRouting";
})(exports.KnownApplicationGatewayRequestRoutingRuleType || (exports.KnownApplicationGatewayRequestRoutingRuleType = {}));
(function (KnownApplicationGatewayRedirectType) {
    KnownApplicationGatewayRedirectType["Permanent"] = "Permanent";
    KnownApplicationGatewayRedirectType["Found"] = "Found";
    KnownApplicationGatewayRedirectType["SeeOther"] = "SeeOther";
    KnownApplicationGatewayRedirectType["Temporary"] = "Temporary";
})(exports.KnownApplicationGatewayRedirectType || (exports.KnownApplicationGatewayRedirectType = {}));
(function (KnownApplicationGatewayFirewallMode) {
    KnownApplicationGatewayFirewallMode["Detection"] = "Detection";
    KnownApplicationGatewayFirewallMode["Prevention"] = "Prevention";
})(exports.KnownApplicationGatewayFirewallMode || (exports.KnownApplicationGatewayFirewallMode = {}));
(function (KnownApplicationGatewayLoadDistributionAlgorithm) {
    KnownApplicationGatewayLoadDistributionAlgorithm["RoundRobin"] = "RoundRobin";
    KnownApplicationGatewayLoadDistributionAlgorithm["LeastConnections"] = "LeastConnections";
    KnownApplicationGatewayLoadDistributionAlgorithm["IpHash"] = "IpHash";
})(exports.KnownApplicationGatewayLoadDistributionAlgorithm || (exports.KnownApplicationGatewayLoadDistributionAlgorithm = {}));
(function (KnownApplicationGatewayBackendHealthServerHealth) {
    KnownApplicationGatewayBackendHealthServerHealth["Unknown"] = "Unknown";
    KnownApplicationGatewayBackendHealthServerHealth["Up"] = "Up";
    KnownApplicationGatewayBackendHealthServerHealth["Down"] = "Down";
    KnownApplicationGatewayBackendHealthServerHealth["Partial"] = "Partial";
    KnownApplicationGatewayBackendHealthServerHealth["Draining"] = "Draining";
})(exports.KnownApplicationGatewayBackendHealthServerHealth || (exports.KnownApplicationGatewayBackendHealthServerHealth = {}));
(function (KnownAzureFirewallRCActionType) {
    KnownAzureFirewallRCActionType["Allow"] = "Allow";
    KnownAzureFirewallRCActionType["Deny"] = "Deny";
})(exports.KnownAzureFirewallRCActionType || (exports.KnownAzureFirewallRCActionType = {}));
(function (KnownAzureFirewallApplicationRuleProtocolType) {
    KnownAzureFirewallApplicationRuleProtocolType["Http"] = "Http";
    KnownAzureFirewallApplicationRuleProtocolType["Https"] = "Https";
    KnownAzureFirewallApplicationRuleProtocolType["Mssql"] = "Mssql";
})(exports.KnownAzureFirewallApplicationRuleProtocolType || (exports.KnownAzureFirewallApplicationRuleProtocolType = {}));
(function (KnownAzureFirewallNatRCActionType) {
    KnownAzureFirewallNatRCActionType["Snat"] = "Snat";
    KnownAzureFirewallNatRCActionType["Dnat"] = "Dnat";
})(exports.KnownAzureFirewallNatRCActionType || (exports.KnownAzureFirewallNatRCActionType = {}));
(function (KnownAzureFirewallNetworkRuleProtocol) {
    KnownAzureFirewallNetworkRuleProtocol["TCP"] = "TCP";
    KnownAzureFirewallNetworkRuleProtocol["UDP"] = "UDP";
    KnownAzureFirewallNetworkRuleProtocol["Any"] = "Any";
    KnownAzureFirewallNetworkRuleProtocol["Icmp"] = "ICMP";
})(exports.KnownAzureFirewallNetworkRuleProtocol || (exports.KnownAzureFirewallNetworkRuleProtocol = {}));
(function (KnownAzureFirewallThreatIntelMode) {
    KnownAzureFirewallThreatIntelMode["Alert"] = "Alert";
    KnownAzureFirewallThreatIntelMode["Deny"] = "Deny";
    KnownAzureFirewallThreatIntelMode["Off"] = "Off";
})(exports.KnownAzureFirewallThreatIntelMode || (exports.KnownAzureFirewallThreatIntelMode = {}));
(function (KnownAzureFirewallSkuName) {
    KnownAzureFirewallSkuName["AzfwVnet"] = "AZFW_VNet";
    KnownAzureFirewallSkuName["AzfwHub"] = "AZFW_Hub";
})(exports.KnownAzureFirewallSkuName || (exports.KnownAzureFirewallSkuName = {}));
(function (KnownAzureFirewallSkuTier) {
    KnownAzureFirewallSkuTier["Standard"] = "Standard";
    KnownAzureFirewallSkuTier["Premium"] = "Premium";
    KnownAzureFirewallSkuTier["Basic"] = "Basic";
})(exports.KnownAzureFirewallSkuTier || (exports.KnownAzureFirewallSkuTier = {}));
(function (KnownBastionHostSkuName) {
    KnownBastionHostSkuName["Basic"] = "Basic";
    KnownBastionHostSkuName["Standard"] = "Standard";
})(exports.KnownBastionHostSkuName || (exports.KnownBastionHostSkuName = {}));
(function (KnownBastionConnectProtocol) {
    KnownBastionConnectProtocol["SSH"] = "SSH";
    KnownBastionConnectProtocol["RDP"] = "RDP";
})(exports.KnownBastionConnectProtocol || (exports.KnownBastionConnectProtocol = {}));
(function (KnownCommissionedState) {
    KnownCommissionedState["Provisioning"] = "Provisioning";
    KnownCommissionedState["Provisioned"] = "Provisioned";
    KnownCommissionedState["Commissioning"] = "Commissioning";
    KnownCommissionedState["Commissioned"] = "Commissioned";
    KnownCommissionedState["Decommissioning"] = "Decommissioning";
    KnownCommissionedState["Deprovisioning"] = "Deprovisioning";
})(exports.KnownCommissionedState || (exports.KnownCommissionedState = {}));
(function (KnownDdosCustomPolicyProtocol) {
    KnownDdosCustomPolicyProtocol["Tcp"] = "Tcp";
    KnownDdosCustomPolicyProtocol["Udp"] = "Udp";
    KnownDdosCustomPolicyProtocol["Syn"] = "Syn";
})(exports.KnownDdosCustomPolicyProtocol || (exports.KnownDdosCustomPolicyProtocol = {}));
(function (KnownDdosCustomPolicyTriggerSensitivityOverride) {
    KnownDdosCustomPolicyTriggerSensitivityOverride["Relaxed"] = "Relaxed";
    KnownDdosCustomPolicyTriggerSensitivityOverride["Low"] = "Low";
    KnownDdosCustomPolicyTriggerSensitivityOverride["Default"] = "Default";
    KnownDdosCustomPolicyTriggerSensitivityOverride["High"] = "High";
})(exports.KnownDdosCustomPolicyTriggerSensitivityOverride || (exports.KnownDdosCustomPolicyTriggerSensitivityOverride = {}));
(function (KnownProtocolType) {
    KnownProtocolType["DoNotUse"] = "DoNotUse";
    KnownProtocolType["Icmp"] = "Icmp";
    KnownProtocolType["Tcp"] = "Tcp";
    KnownProtocolType["Udp"] = "Udp";
    KnownProtocolType["Gre"] = "Gre";
    KnownProtocolType["Esp"] = "Esp";
    KnownProtocolType["Ah"] = "Ah";
    KnownProtocolType["Vxlan"] = "Vxlan";
    KnownProtocolType["All"] = "All";
})(exports.KnownProtocolType || (exports.KnownProtocolType = {}));
(function (KnownAuthorizationUseStatus) {
    KnownAuthorizationUseStatus["Available"] = "Available";
    KnownAuthorizationUseStatus["InUse"] = "InUse";
})(exports.KnownAuthorizationUseStatus || (exports.KnownAuthorizationUseStatus = {}));
(function (KnownExpressRoutePeeringType) {
    KnownExpressRoutePeeringType["AzurePublicPeering"] = "AzurePublicPeering";
    KnownExpressRoutePeeringType["AzurePrivatePeering"] = "AzurePrivatePeering";
    KnownExpressRoutePeeringType["MicrosoftPeering"] = "MicrosoftPeering";
})(exports.KnownExpressRoutePeeringType || (exports.KnownExpressRoutePeeringType = {}));
(function (KnownExpressRoutePeeringState) {
    KnownExpressRoutePeeringState["Disabled"] = "Disabled";
    KnownExpressRoutePeeringState["Enabled"] = "Enabled";
})(exports.KnownExpressRoutePeeringState || (exports.KnownExpressRoutePeeringState = {}));
(function (KnownExpressRouteCircuitPeeringAdvertisedPublicPrefixState) {
    KnownExpressRouteCircuitPeeringAdvertisedPublicPrefixState["NotConfigured"] = "NotConfigured";
    KnownExpressRouteCircuitPeeringAdvertisedPublicPrefixState["Configuring"] = "Configuring";
    KnownExpressRouteCircuitPeeringAdvertisedPublicPrefixState["Configured"] = "Configured";
    KnownExpressRouteCircuitPeeringAdvertisedPublicPrefixState["ValidationNeeded"] = "ValidationNeeded";
})(exports.KnownExpressRouteCircuitPeeringAdvertisedPublicPrefixState || (exports.KnownExpressRouteCircuitPeeringAdvertisedPublicPrefixState = {}));
(function (KnownExpressRouteCircuitPeeringState) {
    KnownExpressRouteCircuitPeeringState["Disabled"] = "Disabled";
    KnownExpressRouteCircuitPeeringState["Enabled"] = "Enabled";
})(exports.KnownExpressRouteCircuitPeeringState || (exports.KnownExpressRouteCircuitPeeringState = {}));
(function (KnownCircuitConnectionStatus) {
    KnownCircuitConnectionStatus["Connected"] = "Connected";
    KnownCircuitConnectionStatus["Connecting"] = "Connecting";
    KnownCircuitConnectionStatus["Disconnected"] = "Disconnected";
})(exports.KnownCircuitConnectionStatus || (exports.KnownCircuitConnectionStatus = {}));
(function (KnownExpressRouteCircuitSkuTier) {
    KnownExpressRouteCircuitSkuTier["Standard"] = "Standard";
    KnownExpressRouteCircuitSkuTier["Premium"] = "Premium";
    KnownExpressRouteCircuitSkuTier["Basic"] = "Basic";
    KnownExpressRouteCircuitSkuTier["Local"] = "Local";
})(exports.KnownExpressRouteCircuitSkuTier || (exports.KnownExpressRouteCircuitSkuTier = {}));
(function (KnownExpressRouteCircuitSkuFamily) {
    KnownExpressRouteCircuitSkuFamily["UnlimitedData"] = "UnlimitedData";
    KnownExpressRouteCircuitSkuFamily["MeteredData"] = "MeteredData";
})(exports.KnownExpressRouteCircuitSkuFamily || (exports.KnownExpressRouteCircuitSkuFamily = {}));
(function (KnownServiceProviderProvisioningState) {
    KnownServiceProviderProvisioningState["NotProvisioned"] = "NotProvisioned";
    KnownServiceProviderProvisioningState["Provisioning"] = "Provisioning";
    KnownServiceProviderProvisioningState["Provisioned"] = "Provisioned";
    KnownServiceProviderProvisioningState["Deprovisioning"] = "Deprovisioning";
})(exports.KnownServiceProviderProvisioningState || (exports.KnownServiceProviderProvisioningState = {}));
(function (KnownExpressRoutePortsEncapsulation) {
    KnownExpressRoutePortsEncapsulation["Dot1Q"] = "Dot1Q";
    KnownExpressRoutePortsEncapsulation["QinQ"] = "QinQ";
})(exports.KnownExpressRoutePortsEncapsulation || (exports.KnownExpressRoutePortsEncapsulation = {}));
(function (KnownExpressRouteLinkConnectorType) {
    KnownExpressRouteLinkConnectorType["LC"] = "LC";
    KnownExpressRouteLinkConnectorType["SC"] = "SC";
})(exports.KnownExpressRouteLinkConnectorType || (exports.KnownExpressRouteLinkConnectorType = {}));
(function (KnownExpressRouteLinkAdminState) {
    KnownExpressRouteLinkAdminState["Enabled"] = "Enabled";
    KnownExpressRouteLinkAdminState["Disabled"] = "Disabled";
})(exports.KnownExpressRouteLinkAdminState || (exports.KnownExpressRouteLinkAdminState = {}));
(function (KnownExpressRouteLinkMacSecCipher) {
    KnownExpressRouteLinkMacSecCipher["GcmAes256"] = "GcmAes256";
    KnownExpressRouteLinkMacSecCipher["GcmAes128"] = "GcmAes128";
    KnownExpressRouteLinkMacSecCipher["GcmAesXpn128"] = "GcmAesXpn128";
    KnownExpressRouteLinkMacSecCipher["GcmAesXpn256"] = "GcmAesXpn256";
})(exports.KnownExpressRouteLinkMacSecCipher || (exports.KnownExpressRouteLinkMacSecCipher = {}));
(function (KnownExpressRouteLinkMacSecSciState) {
    KnownExpressRouteLinkMacSecSciState["Disabled"] = "Disabled";
    KnownExpressRouteLinkMacSecSciState["Enabled"] = "Enabled";
})(exports.KnownExpressRouteLinkMacSecSciState || (exports.KnownExpressRouteLinkMacSecSciState = {}));
(function (KnownFirewallPolicyIntrusionDetectionStateType) {
    KnownFirewallPolicyIntrusionDetectionStateType["Off"] = "Off";
    KnownFirewallPolicyIntrusionDetectionStateType["Alert"] = "Alert";
    KnownFirewallPolicyIntrusionDetectionStateType["Deny"] = "Deny";
})(exports.KnownFirewallPolicyIntrusionDetectionStateType || (exports.KnownFirewallPolicyIntrusionDetectionStateType = {}));
(function (KnownFirewallPolicyIntrusionDetectionProtocol) {
    KnownFirewallPolicyIntrusionDetectionProtocol["TCP"] = "TCP";
    KnownFirewallPolicyIntrusionDetectionProtocol["UDP"] = "UDP";
    KnownFirewallPolicyIntrusionDetectionProtocol["Icmp"] = "ICMP";
    KnownFirewallPolicyIntrusionDetectionProtocol["ANY"] = "ANY";
})(exports.KnownFirewallPolicyIntrusionDetectionProtocol || (exports.KnownFirewallPolicyIntrusionDetectionProtocol = {}));
(function (KnownFirewallPolicySkuTier) {
    KnownFirewallPolicySkuTier["Standard"] = "Standard";
    KnownFirewallPolicySkuTier["Premium"] = "Premium";
    KnownFirewallPolicySkuTier["Basic"] = "Basic";
})(exports.KnownFirewallPolicySkuTier || (exports.KnownFirewallPolicySkuTier = {}));
(function (KnownFirewallPolicyRuleCollectionType) {
    KnownFirewallPolicyRuleCollectionType["FirewallPolicyNatRuleCollection"] = "FirewallPolicyNatRuleCollection";
    KnownFirewallPolicyRuleCollectionType["FirewallPolicyFilterRuleCollection"] = "FirewallPolicyFilterRuleCollection";
})(exports.KnownFirewallPolicyRuleCollectionType || (exports.KnownFirewallPolicyRuleCollectionType = {}));
(function (KnownOrderByOrder) {
    KnownOrderByOrder["Ascending"] = "Ascending";
    KnownOrderByOrder["Descending"] = "Descending";
})(exports.KnownOrderByOrder || (exports.KnownOrderByOrder = {}));
(function (KnownEnum69) {
    KnownEnum69[KnownEnum69["Zero"] = 0] = "Zero";
    KnownEnum69[KnownEnum69["One"] = 1] = "One";
    KnownEnum69[KnownEnum69["Two"] = 2] = "Two";
})(exports.KnownEnum69 || (exports.KnownEnum69 = {}));
(function (KnownEnum70) {
    KnownEnum70[KnownEnum70["One"] = 1] = "One";
    KnownEnum70[KnownEnum70["Two"] = 2] = "Two";
    KnownEnum70[KnownEnum70["Three"] = 3] = "Three";
})(exports.KnownEnum70 || (exports.KnownEnum70 = {}));
(function (KnownEnum71) {
    KnownEnum71[KnownEnum71["Zero"] = 0] = "Zero";
    KnownEnum71[KnownEnum71["One"] = 1] = "One";
    KnownEnum71[KnownEnum71["Two"] = 2] = "Two";
})(exports.KnownEnum71 || (exports.KnownEnum71 = {}));
(function (KnownIpAllocationType) {
    KnownIpAllocationType["Undefined"] = "Undefined";
    KnownIpAllocationType["Hypernet"] = "Hypernet";
})(exports.KnownIpAllocationType || (exports.KnownIpAllocationType = {}));
(function (KnownLoadBalancerSkuName) {
    KnownLoadBalancerSkuName["Basic"] = "Basic";
    KnownLoadBalancerSkuName["Standard"] = "Standard";
    KnownLoadBalancerSkuName["Gateway"] = "Gateway";
})(exports.KnownLoadBalancerSkuName || (exports.KnownLoadBalancerSkuName = {}));
(function (KnownLoadBalancerSkuTier) {
    KnownLoadBalancerSkuTier["Regional"] = "Regional";
    KnownLoadBalancerSkuTier["Global"] = "Global";
})(exports.KnownLoadBalancerSkuTier || (exports.KnownLoadBalancerSkuTier = {}));
(function (KnownLoadDistribution) {
    KnownLoadDistribution["Default"] = "Default";
    KnownLoadDistribution["SourceIP"] = "SourceIP";
    KnownLoadDistribution["SourceIPProtocol"] = "SourceIPProtocol";
})(exports.KnownLoadDistribution || (exports.KnownLoadDistribution = {}));
(function (KnownProbeProtocol) {
    KnownProbeProtocol["Http"] = "Http";
    KnownProbeProtocol["Tcp"] = "Tcp";
    KnownProbeProtocol["Https"] = "Https";
})(exports.KnownProbeProtocol || (exports.KnownProbeProtocol = {}));
(function (KnownLoadBalancerOutboundRuleProtocol) {
    KnownLoadBalancerOutboundRuleProtocol["Tcp"] = "Tcp";
    KnownLoadBalancerOutboundRuleProtocol["Udp"] = "Udp";
    KnownLoadBalancerOutboundRuleProtocol["All"] = "All";
})(exports.KnownLoadBalancerOutboundRuleProtocol || (exports.KnownLoadBalancerOutboundRuleProtocol = {}));
(function (KnownEffectiveRouteSource) {
    KnownEffectiveRouteSource["Unknown"] = "Unknown";
    KnownEffectiveRouteSource["User"] = "User";
    KnownEffectiveRouteSource["VirtualNetworkGateway"] = "VirtualNetworkGateway";
    KnownEffectiveRouteSource["Default"] = "Default";
})(exports.KnownEffectiveRouteSource || (exports.KnownEffectiveRouteSource = {}));
(function (KnownEffectiveRouteState) {
    KnownEffectiveRouteState["Active"] = "Active";
    KnownEffectiveRouteState["Invalid"] = "Invalid";
})(exports.KnownEffectiveRouteState || (exports.KnownEffectiveRouteState = {}));
(function (KnownEffectiveSecurityRuleProtocol) {
    KnownEffectiveSecurityRuleProtocol["Tcp"] = "Tcp";
    KnownEffectiveSecurityRuleProtocol["Udp"] = "Udp";
    KnownEffectiveSecurityRuleProtocol["All"] = "All";
})(exports.KnownEffectiveSecurityRuleProtocol || (exports.KnownEffectiveSecurityRuleProtocol = {}));
(function (KnownInboundSecurityRulesProtocol) {
    KnownInboundSecurityRulesProtocol["TCP"] = "TCP";
    KnownInboundSecurityRulesProtocol["UDP"] = "UDP";
})(exports.KnownInboundSecurityRulesProtocol || (exports.KnownInboundSecurityRulesProtocol = {}));
(function (KnownAssociationType) {
    KnownAssociationType["Associated"] = "Associated";
    KnownAssociationType["Contains"] = "Contains";
})(exports.KnownAssociationType || (exports.KnownAssociationType = {}));
(function (KnownDirection) {
    KnownDirection["Inbound"] = "Inbound";
    KnownDirection["Outbound"] = "Outbound";
})(exports.KnownDirection || (exports.KnownDirection = {}));
(function (KnownIpFlowProtocol) {
    KnownIpFlowProtocol["TCP"] = "TCP";
    KnownIpFlowProtocol["UDP"] = "UDP";
})(exports.KnownIpFlowProtocol || (exports.KnownIpFlowProtocol = {}));
(function (KnownAccess) {
    KnownAccess["Allow"] = "Allow";
    KnownAccess["Deny"] = "Deny";
})(exports.KnownAccess || (exports.KnownAccess = {}));
(function (KnownNextHopType) {
    KnownNextHopType["Internet"] = "Internet";
    KnownNextHopType["VirtualAppliance"] = "VirtualAppliance";
    KnownNextHopType["VirtualNetworkGateway"] = "VirtualNetworkGateway";
    KnownNextHopType["VnetLocal"] = "VnetLocal";
    KnownNextHopType["HyperNetGateway"] = "HyperNetGateway";
    KnownNextHopType["None"] = "None";
})(exports.KnownNextHopType || (exports.KnownNextHopType = {}));
(function (KnownPcProtocol) {
    KnownPcProtocol["TCP"] = "TCP";
    KnownPcProtocol["UDP"] = "UDP";
    KnownPcProtocol["Any"] = "Any";
})(exports.KnownPcProtocol || (exports.KnownPcProtocol = {}));
(function (KnownPcStatus) {
    KnownPcStatus["NotStarted"] = "NotStarted";
    KnownPcStatus["Running"] = "Running";
    KnownPcStatus["Stopped"] = "Stopped";
    KnownPcStatus["Error"] = "Error";
    KnownPcStatus["Unknown"] = "Unknown";
})(exports.KnownPcStatus || (exports.KnownPcStatus = {}));
(function (KnownPcError) {
    KnownPcError["InternalError"] = "InternalError";
    KnownPcError["AgentStopped"] = "AgentStopped";
    KnownPcError["CaptureFailed"] = "CaptureFailed";
    KnownPcError["LocalFileFailed"] = "LocalFileFailed";
    KnownPcError["StorageFailed"] = "StorageFailed";
})(exports.KnownPcError || (exports.KnownPcError = {}));
(function (KnownProtocol) {
    KnownProtocol["Tcp"] = "Tcp";
    KnownProtocol["Http"] = "Http";
    KnownProtocol["Https"] = "Https";
    KnownProtocol["Icmp"] = "Icmp";
})(exports.KnownProtocol || (exports.KnownProtocol = {}));
(function (KnownHttpMethod) {
    KnownHttpMethod["Get"] = "Get";
})(exports.KnownHttpMethod || (exports.KnownHttpMethod = {}));
(function (KnownOrigin) {
    KnownOrigin["Local"] = "Local";
    KnownOrigin["Inbound"] = "Inbound";
    KnownOrigin["Outbound"] = "Outbound";
})(exports.KnownOrigin || (exports.KnownOrigin = {}));
(function (KnownSeverity) {
    KnownSeverity["Error"] = "Error";
    KnownSeverity["Warning"] = "Warning";
})(exports.KnownSeverity || (exports.KnownSeverity = {}));
(function (KnownIssueType) {
    KnownIssueType["Unknown"] = "Unknown";
    KnownIssueType["AgentStopped"] = "AgentStopped";
    KnownIssueType["GuestFirewall"] = "GuestFirewall";
    KnownIssueType["DnsResolution"] = "DnsResolution";
    KnownIssueType["SocketBind"] = "SocketBind";
    KnownIssueType["NetworkSecurityRule"] = "NetworkSecurityRule";
    KnownIssueType["UserDefinedRoute"] = "UserDefinedRoute";
    KnownIssueType["PortThrottled"] = "PortThrottled";
    KnownIssueType["Platform"] = "Platform";
})(exports.KnownIssueType || (exports.KnownIssueType = {}));
(function (KnownConnectionStatus) {
    KnownConnectionStatus["Unknown"] = "Unknown";
    KnownConnectionStatus["Connected"] = "Connected";
    KnownConnectionStatus["Disconnected"] = "Disconnected";
    KnownConnectionStatus["Degraded"] = "Degraded";
})(exports.KnownConnectionStatus || (exports.KnownConnectionStatus = {}));
(function (KnownVerbosityLevel) {
    KnownVerbosityLevel["Normal"] = "Normal";
    KnownVerbosityLevel["Minimum"] = "Minimum";
    KnownVerbosityLevel["Full"] = "Full";
})(exports.KnownVerbosityLevel || (exports.KnownVerbosityLevel = {}));
(function (KnownEndpointType) {
    KnownEndpointType["AzureVM"] = "AzureVM";
    KnownEndpointType["AzureVNet"] = "AzureVNet";
    KnownEndpointType["AzureSubnet"] = "AzureSubnet";
    KnownEndpointType["ExternalAddress"] = "ExternalAddress";
    KnownEndpointType["MMAWorkspaceMachine"] = "MMAWorkspaceMachine";
    KnownEndpointType["MMAWorkspaceNetwork"] = "MMAWorkspaceNetwork";
})(exports.KnownEndpointType || (exports.KnownEndpointType = {}));
(function (KnownConnectionMonitorEndpointFilterType) {
    KnownConnectionMonitorEndpointFilterType["Include"] = "Include";
})(exports.KnownConnectionMonitorEndpointFilterType || (exports.KnownConnectionMonitorEndpointFilterType = {}));
(function (KnownConnectionMonitorEndpointFilterItemType) {
    KnownConnectionMonitorEndpointFilterItemType["AgentAddress"] = "AgentAddress";
})(exports.KnownConnectionMonitorEndpointFilterItemType || (exports.KnownConnectionMonitorEndpointFilterItemType = {}));
(function (KnownCoverageLevel) {
    KnownCoverageLevel["Default"] = "Default";
    KnownCoverageLevel["Low"] = "Low";
    KnownCoverageLevel["BelowAverage"] = "BelowAverage";
    KnownCoverageLevel["Average"] = "Average";
    KnownCoverageLevel["AboveAverage"] = "AboveAverage";
    KnownCoverageLevel["Full"] = "Full";
})(exports.KnownCoverageLevel || (exports.KnownCoverageLevel = {}));
(function (KnownConnectionMonitorTestConfigurationProtocol) {
    KnownConnectionMonitorTestConfigurationProtocol["Tcp"] = "Tcp";
    KnownConnectionMonitorTestConfigurationProtocol["Http"] = "Http";
    KnownConnectionMonitorTestConfigurationProtocol["Icmp"] = "Icmp";
})(exports.KnownConnectionMonitorTestConfigurationProtocol || (exports.KnownConnectionMonitorTestConfigurationProtocol = {}));
(function (KnownPreferredIPVersion) {
    KnownPreferredIPVersion["IPv4"] = "IPv4";
    KnownPreferredIPVersion["IPv6"] = "IPv6";
})(exports.KnownPreferredIPVersion || (exports.KnownPreferredIPVersion = {}));
(function (KnownHttpConfigurationMethod) {
    KnownHttpConfigurationMethod["Get"] = "Get";
    KnownHttpConfigurationMethod["Post"] = "Post";
})(exports.KnownHttpConfigurationMethod || (exports.KnownHttpConfigurationMethod = {}));
(function (KnownDestinationPortBehavior) {
    KnownDestinationPortBehavior["None"] = "None";
    KnownDestinationPortBehavior["ListenIfAvailable"] = "ListenIfAvailable";
})(exports.KnownDestinationPortBehavior || (exports.KnownDestinationPortBehavior = {}));
(function (KnownOutputType) {
    KnownOutputType["Workspace"] = "Workspace";
})(exports.KnownOutputType || (exports.KnownOutputType = {}));
(function (KnownConnectionMonitorType) {
    KnownConnectionMonitorType["MultiEndpoint"] = "MultiEndpoint";
    KnownConnectionMonitorType["SingleSourceDestination"] = "SingleSourceDestination";
})(exports.KnownConnectionMonitorType || (exports.KnownConnectionMonitorType = {}));
(function (KnownConnectionMonitorSourceStatus) {
    KnownConnectionMonitorSourceStatus["Unknown"] = "Unknown";
    KnownConnectionMonitorSourceStatus["Active"] = "Active";
    KnownConnectionMonitorSourceStatus["Inactive"] = "Inactive";
})(exports.KnownConnectionMonitorSourceStatus || (exports.KnownConnectionMonitorSourceStatus = {}));
(function (KnownConnectionState) {
    KnownConnectionState["Reachable"] = "Reachable";
    KnownConnectionState["Unreachable"] = "Unreachable";
    KnownConnectionState["Unknown"] = "Unknown";
})(exports.KnownConnectionState || (exports.KnownConnectionState = {}));
(function (KnownEvaluationState) {
    KnownEvaluationState["NotStarted"] = "NotStarted";
    KnownEvaluationState["InProgress"] = "InProgress";
    KnownEvaluationState["Completed"] = "Completed";
})(exports.KnownEvaluationState || (exports.KnownEvaluationState = {}));
(function (KnownPublicIPPrefixSkuName) {
    KnownPublicIPPrefixSkuName["Standard"] = "Standard";
})(exports.KnownPublicIPPrefixSkuName || (exports.KnownPublicIPPrefixSkuName = {}));
(function (KnownPublicIPPrefixSkuTier) {
    KnownPublicIPPrefixSkuTier["Regional"] = "Regional";
    KnownPublicIPPrefixSkuTier["Global"] = "Global";
})(exports.KnownPublicIPPrefixSkuTier || (exports.KnownPublicIPPrefixSkuTier = {}));
(function (KnownRouteFilterRuleType) {
    KnownRouteFilterRuleType["Community"] = "Community";
})(exports.KnownRouteFilterRuleType || (exports.KnownRouteFilterRuleType = {}));
(function (KnownSecurityProviderName) {
    KnownSecurityProviderName["ZScaler"] = "ZScaler";
    KnownSecurityProviderName["IBoss"] = "IBoss";
    KnownSecurityProviderName["Checkpoint"] = "Checkpoint";
})(exports.KnownSecurityProviderName || (exports.KnownSecurityProviderName = {}));
(function (KnownSecurityPartnerProviderConnectionStatus) {
    KnownSecurityPartnerProviderConnectionStatus["Unknown"] = "Unknown";
    KnownSecurityPartnerProviderConnectionStatus["PartiallyConnected"] = "PartiallyConnected";
    KnownSecurityPartnerProviderConnectionStatus["Connected"] = "Connected";
    KnownSecurityPartnerProviderConnectionStatus["NotConnected"] = "NotConnected";
})(exports.KnownSecurityPartnerProviderConnectionStatus || (exports.KnownSecurityPartnerProviderConnectionStatus = {}));
(function (KnownUsageUnit) {
    KnownUsageUnit["Count"] = "Count";
})(exports.KnownUsageUnit || (exports.KnownUsageUnit = {}));
(function (KnownVirtualNetworkEncryptionEnforcement) {
    KnownVirtualNetworkEncryptionEnforcement["DropUnencrypted"] = "DropUnencrypted";
    KnownVirtualNetworkEncryptionEnforcement["AllowUnencrypted"] = "AllowUnencrypted";
})(exports.KnownVirtualNetworkEncryptionEnforcement || (exports.KnownVirtualNetworkEncryptionEnforcement = {}));
(function (KnownVirtualNetworkPeeringState) {
    KnownVirtualNetworkPeeringState["Initiated"] = "Initiated";
    KnownVirtualNetworkPeeringState["Connected"] = "Connected";
    KnownVirtualNetworkPeeringState["Disconnected"] = "Disconnected";
})(exports.KnownVirtualNetworkPeeringState || (exports.KnownVirtualNetworkPeeringState = {}));
(function (KnownVirtualNetworkPeeringLevel) {
    KnownVirtualNetworkPeeringLevel["FullyInSync"] = "FullyInSync";
    KnownVirtualNetworkPeeringLevel["RemoteNotInSync"] = "RemoteNotInSync";
    KnownVirtualNetworkPeeringLevel["LocalNotInSync"] = "LocalNotInSync";
    KnownVirtualNetworkPeeringLevel["LocalAndRemoteNotInSync"] = "LocalAndRemoteNotInSync";
})(exports.KnownVirtualNetworkPeeringLevel || (exports.KnownVirtualNetworkPeeringLevel = {}));
(function (KnownSyncRemoteAddressSpace) {
    KnownSyncRemoteAddressSpace["True"] = "true";
})(exports.KnownSyncRemoteAddressSpace || (exports.KnownSyncRemoteAddressSpace = {}));
(function (KnownVirtualNetworkGatewayType) {
    KnownVirtualNetworkGatewayType["Vpn"] = "Vpn";
    KnownVirtualNetworkGatewayType["ExpressRoute"] = "ExpressRoute";
    KnownVirtualNetworkGatewayType["LocalGateway"] = "LocalGateway";
})(exports.KnownVirtualNetworkGatewayType || (exports.KnownVirtualNetworkGatewayType = {}));
(function (KnownVpnType) {
    KnownVpnType["PolicyBased"] = "PolicyBased";
    KnownVpnType["RouteBased"] = "RouteBased";
})(exports.KnownVpnType || (exports.KnownVpnType = {}));
(function (KnownVpnGatewayGeneration) {
    KnownVpnGatewayGeneration["None"] = "None";
    KnownVpnGatewayGeneration["Generation1"] = "Generation1";
    KnownVpnGatewayGeneration["Generation2"] = "Generation2";
})(exports.KnownVpnGatewayGeneration || (exports.KnownVpnGatewayGeneration = {}));
(function (KnownVirtualNetworkGatewaySkuName) {
    KnownVirtualNetworkGatewaySkuName["Basic"] = "Basic";
    KnownVirtualNetworkGatewaySkuName["HighPerformance"] = "HighPerformance";
    KnownVirtualNetworkGatewaySkuName["Standard"] = "Standard";
    KnownVirtualNetworkGatewaySkuName["UltraPerformance"] = "UltraPerformance";
    KnownVirtualNetworkGatewaySkuName["VpnGw1"] = "VpnGw1";
    KnownVirtualNetworkGatewaySkuName["VpnGw2"] = "VpnGw2";
    KnownVirtualNetworkGatewaySkuName["VpnGw3"] = "VpnGw3";
    KnownVirtualNetworkGatewaySkuName["VpnGw4"] = "VpnGw4";
    KnownVirtualNetworkGatewaySkuName["VpnGw5"] = "VpnGw5";
    KnownVirtualNetworkGatewaySkuName["VpnGw1AZ"] = "VpnGw1AZ";
    KnownVirtualNetworkGatewaySkuName["VpnGw2AZ"] = "VpnGw2AZ";
    KnownVirtualNetworkGatewaySkuName["VpnGw3AZ"] = "VpnGw3AZ";
    KnownVirtualNetworkGatewaySkuName["VpnGw4AZ"] = "VpnGw4AZ";
    KnownVirtualNetworkGatewaySkuName["VpnGw5AZ"] = "VpnGw5AZ";
    KnownVirtualNetworkGatewaySkuName["ErGw1AZ"] = "ErGw1AZ";
    KnownVirtualNetworkGatewaySkuName["ErGw2AZ"] = "ErGw2AZ";
    KnownVirtualNetworkGatewaySkuName["ErGw3AZ"] = "ErGw3AZ";
})(exports.KnownVirtualNetworkGatewaySkuName || (exports.KnownVirtualNetworkGatewaySkuName = {}));
(function (KnownVirtualNetworkGatewaySkuTier) {
    KnownVirtualNetworkGatewaySkuTier["Basic"] = "Basic";
    KnownVirtualNetworkGatewaySkuTier["HighPerformance"] = "HighPerformance";
    KnownVirtualNetworkGatewaySkuTier["Standard"] = "Standard";
    KnownVirtualNetworkGatewaySkuTier["UltraPerformance"] = "UltraPerformance";
    KnownVirtualNetworkGatewaySkuTier["VpnGw1"] = "VpnGw1";
    KnownVirtualNetworkGatewaySkuTier["VpnGw2"] = "VpnGw2";
    KnownVirtualNetworkGatewaySkuTier["VpnGw3"] = "VpnGw3";
    KnownVirtualNetworkGatewaySkuTier["VpnGw4"] = "VpnGw4";
    KnownVirtualNetworkGatewaySkuTier["VpnGw5"] = "VpnGw5";
    KnownVirtualNetworkGatewaySkuTier["VpnGw1AZ"] = "VpnGw1AZ";
    KnownVirtualNetworkGatewaySkuTier["VpnGw2AZ"] = "VpnGw2AZ";
    KnownVirtualNetworkGatewaySkuTier["VpnGw3AZ"] = "VpnGw3AZ";
    KnownVirtualNetworkGatewaySkuTier["VpnGw4AZ"] = "VpnGw4AZ";
    KnownVirtualNetworkGatewaySkuTier["VpnGw5AZ"] = "VpnGw5AZ";
    KnownVirtualNetworkGatewaySkuTier["ErGw1AZ"] = "ErGw1AZ";
    KnownVirtualNetworkGatewaySkuTier["ErGw2AZ"] = "ErGw2AZ";
    KnownVirtualNetworkGatewaySkuTier["ErGw3AZ"] = "ErGw3AZ";
})(exports.KnownVirtualNetworkGatewaySkuTier || (exports.KnownVirtualNetworkGatewaySkuTier = {}));
(function (KnownVpnClientProtocol) {
    KnownVpnClientProtocol["IkeV2"] = "IkeV2";
    KnownVpnClientProtocol["Sstp"] = "SSTP";
    KnownVpnClientProtocol["OpenVPN"] = "OpenVPN";
})(exports.KnownVpnClientProtocol || (exports.KnownVpnClientProtocol = {}));
(function (KnownVpnAuthenticationType) {
    KnownVpnAuthenticationType["Certificate"] = "Certificate";
    KnownVpnAuthenticationType["Radius"] = "Radius";
    KnownVpnAuthenticationType["AAD"] = "AAD";
})(exports.KnownVpnAuthenticationType || (exports.KnownVpnAuthenticationType = {}));
(function (KnownIpsecEncryption) {
    KnownIpsecEncryption["None"] = "None";
    KnownIpsecEncryption["DES"] = "DES";
    KnownIpsecEncryption["DES3"] = "DES3";
    KnownIpsecEncryption["AES128"] = "AES128";
    KnownIpsecEncryption["AES192"] = "AES192";
    KnownIpsecEncryption["AES256"] = "AES256";
    KnownIpsecEncryption["Gcmaes128"] = "GCMAES128";
    KnownIpsecEncryption["Gcmaes192"] = "GCMAES192";
    KnownIpsecEncryption["Gcmaes256"] = "GCMAES256";
})(exports.KnownIpsecEncryption || (exports.KnownIpsecEncryption = {}));
(function (KnownIpsecIntegrity) {
    KnownIpsecIntegrity["MD5"] = "MD5";
    KnownIpsecIntegrity["SHA1"] = "SHA1";
    KnownIpsecIntegrity["SHA256"] = "SHA256";
    KnownIpsecIntegrity["Gcmaes128"] = "GCMAES128";
    KnownIpsecIntegrity["Gcmaes192"] = "GCMAES192";
    KnownIpsecIntegrity["Gcmaes256"] = "GCMAES256";
})(exports.KnownIpsecIntegrity || (exports.KnownIpsecIntegrity = {}));
(function (KnownIkeEncryption) {
    KnownIkeEncryption["DES"] = "DES";
    KnownIkeEncryption["DES3"] = "DES3";
    KnownIkeEncryption["AES128"] = "AES128";
    KnownIkeEncryption["AES192"] = "AES192";
    KnownIkeEncryption["AES256"] = "AES256";
    KnownIkeEncryption["Gcmaes256"] = "GCMAES256";
    KnownIkeEncryption["Gcmaes128"] = "GCMAES128";
})(exports.KnownIkeEncryption || (exports.KnownIkeEncryption = {}));
(function (KnownIkeIntegrity) {
    KnownIkeIntegrity["MD5"] = "MD5";
    KnownIkeIntegrity["SHA1"] = "SHA1";
    KnownIkeIntegrity["SHA256"] = "SHA256";
    KnownIkeIntegrity["SHA384"] = "SHA384";
    KnownIkeIntegrity["Gcmaes256"] = "GCMAES256";
    KnownIkeIntegrity["Gcmaes128"] = "GCMAES128";
})(exports.KnownIkeIntegrity || (exports.KnownIkeIntegrity = {}));
(function (KnownDhGroup) {
    KnownDhGroup["None"] = "None";
    KnownDhGroup["DHGroup1"] = "DHGroup1";
    KnownDhGroup["DHGroup2"] = "DHGroup2";
    KnownDhGroup["DHGroup14"] = "DHGroup14";
    KnownDhGroup["DHGroup2048"] = "DHGroup2048";
    KnownDhGroup["ECP256"] = "ECP256";
    KnownDhGroup["ECP384"] = "ECP384";
    KnownDhGroup["DHGroup24"] = "DHGroup24";
})(exports.KnownDhGroup || (exports.KnownDhGroup = {}));
(function (KnownPfsGroup) {
    KnownPfsGroup["None"] = "None";
    KnownPfsGroup["PFS1"] = "PFS1";
    KnownPfsGroup["PFS2"] = "PFS2";
    KnownPfsGroup["PFS2048"] = "PFS2048";
    KnownPfsGroup["ECP256"] = "ECP256";
    KnownPfsGroup["ECP384"] = "ECP384";
    KnownPfsGroup["PFS24"] = "PFS24";
    KnownPfsGroup["PFS14"] = "PFS14";
    KnownPfsGroup["Pfsmm"] = "PFSMM";
})(exports.KnownPfsGroup || (exports.KnownPfsGroup = {}));
(function (KnownVpnNatRuleType) {
    KnownVpnNatRuleType["Static"] = "Static";
    KnownVpnNatRuleType["Dynamic"] = "Dynamic";
})(exports.KnownVpnNatRuleType || (exports.KnownVpnNatRuleType = {}));
(function (KnownVpnNatRuleMode) {
    KnownVpnNatRuleMode["EgressSnat"] = "EgressSnat";
    KnownVpnNatRuleMode["IngressSnat"] = "IngressSnat";
})(exports.KnownVpnNatRuleMode || (exports.KnownVpnNatRuleMode = {}));
(function (KnownVirtualNetworkGatewayConnectionType) {
    KnownVirtualNetworkGatewayConnectionType["IPsec"] = "IPsec";
    KnownVirtualNetworkGatewayConnectionType["Vnet2Vnet"] = "Vnet2Vnet";
    KnownVirtualNetworkGatewayConnectionType["ExpressRoute"] = "ExpressRoute";
    KnownVirtualNetworkGatewayConnectionType["VPNClient"] = "VPNClient";
})(exports.KnownVirtualNetworkGatewayConnectionType || (exports.KnownVirtualNetworkGatewayConnectionType = {}));
(function (KnownVirtualNetworkGatewayConnectionProtocol) {
    KnownVirtualNetworkGatewayConnectionProtocol["IKEv2"] = "IKEv2";
    KnownVirtualNetworkGatewayConnectionProtocol["IKEv1"] = "IKEv1";
})(exports.KnownVirtualNetworkGatewayConnectionProtocol || (exports.KnownVirtualNetworkGatewayConnectionProtocol = {}));
(function (KnownVirtualNetworkGatewayConnectionMode) {
    KnownVirtualNetworkGatewayConnectionMode["Default"] = "Default";
    KnownVirtualNetworkGatewayConnectionMode["ResponderOnly"] = "ResponderOnly";
    KnownVirtualNetworkGatewayConnectionMode["InitiatorOnly"] = "InitiatorOnly";
})(exports.KnownVirtualNetworkGatewayConnectionMode || (exports.KnownVirtualNetworkGatewayConnectionMode = {}));
(function (KnownVirtualNetworkGatewayConnectionStatus) {
    KnownVirtualNetworkGatewayConnectionStatus["Unknown"] = "Unknown";
    KnownVirtualNetworkGatewayConnectionStatus["Connecting"] = "Connecting";
    KnownVirtualNetworkGatewayConnectionStatus["Connected"] = "Connected";
    KnownVirtualNetworkGatewayConnectionStatus["NotConnected"] = "NotConnected";
})(exports.KnownVirtualNetworkGatewayConnectionStatus || (exports.KnownVirtualNetworkGatewayConnectionStatus = {}));
(function (KnownProcessorArchitecture) {
    KnownProcessorArchitecture["Amd64"] = "Amd64";
    KnownProcessorArchitecture["X86"] = "X86";
})(exports.KnownProcessorArchitecture || (exports.KnownProcessorArchitecture = {}));
(function (KnownAuthenticationMethod) {
    KnownAuthenticationMethod["Eaptls"] = "EAPTLS";
    KnownAuthenticationMethod["EapmschaPv2"] = "EAPMSCHAPv2";
})(exports.KnownAuthenticationMethod || (exports.KnownAuthenticationMethod = {}));
(function (KnownBgpPeerState) {
    KnownBgpPeerState["Unknown"] = "Unknown";
    KnownBgpPeerState["Stopped"] = "Stopped";
    KnownBgpPeerState["Idle"] = "Idle";
    KnownBgpPeerState["Connecting"] = "Connecting";
    KnownBgpPeerState["Connected"] = "Connected";
})(exports.KnownBgpPeerState || (exports.KnownBgpPeerState = {}));
(function (KnownOfficeTrafficCategory) {
    KnownOfficeTrafficCategory["Optimize"] = "Optimize";
    KnownOfficeTrafficCategory["OptimizeAndAllow"] = "OptimizeAndAllow";
    KnownOfficeTrafficCategory["All"] = "All";
    KnownOfficeTrafficCategory["None"] = "None";
})(exports.KnownOfficeTrafficCategory || (exports.KnownOfficeTrafficCategory = {}));
(function (KnownVirtualWanSecurityProviderType) {
    KnownVirtualWanSecurityProviderType["External"] = "External";
    KnownVirtualWanSecurityProviderType["Native"] = "Native";
})(exports.KnownVirtualWanSecurityProviderType || (exports.KnownVirtualWanSecurityProviderType = {}));
(function (KnownVpnGatewayTunnelingProtocol) {
    KnownVpnGatewayTunnelingProtocol["IkeV2"] = "IkeV2";
    KnownVpnGatewayTunnelingProtocol["OpenVPN"] = "OpenVPN";
})(exports.KnownVpnGatewayTunnelingProtocol || (exports.KnownVpnGatewayTunnelingProtocol = {}));
(function (KnownRoutingState) {
    KnownRoutingState["None"] = "None";
    KnownRoutingState["Provisioned"] = "Provisioned";
    KnownRoutingState["Provisioning"] = "Provisioning";
    KnownRoutingState["Failed"] = "Failed";
})(exports.KnownRoutingState || (exports.KnownRoutingState = {}));
(function (KnownPreferredRoutingGateway) {
    KnownPreferredRoutingGateway["ExpressRoute"] = "ExpressRoute";
    KnownPreferredRoutingGateway["VpnGateway"] = "VpnGateway";
    KnownPreferredRoutingGateway["None"] = "None";
})(exports.KnownPreferredRoutingGateway || (exports.KnownPreferredRoutingGateway = {}));
(function (KnownVpnConnectionStatus) {
    KnownVpnConnectionStatus["Unknown"] = "Unknown";
    KnownVpnConnectionStatus["Connecting"] = "Connecting";
    KnownVpnConnectionStatus["Connected"] = "Connected";
    KnownVpnConnectionStatus["NotConnected"] = "NotConnected";
})(exports.KnownVpnConnectionStatus || (exports.KnownVpnConnectionStatus = {}));
(function (KnownVpnLinkConnectionMode) {
    KnownVpnLinkConnectionMode["Default"] = "Default";
    KnownVpnLinkConnectionMode["ResponderOnly"] = "ResponderOnly";
    KnownVpnLinkConnectionMode["InitiatorOnly"] = "InitiatorOnly";
})(exports.KnownVpnLinkConnectionMode || (exports.KnownVpnLinkConnectionMode = {}));
(function (KnownHubBgpConnectionStatus) {
    KnownHubBgpConnectionStatus["Unknown"] = "Unknown";
    KnownHubBgpConnectionStatus["Connecting"] = "Connecting";
    KnownHubBgpConnectionStatus["Connected"] = "Connected";
    KnownHubBgpConnectionStatus["NotConnected"] = "NotConnected";
})(exports.KnownHubBgpConnectionStatus || (exports.KnownHubBgpConnectionStatus = {}));
(function (KnownWebApplicationFirewallEnabledState) {
    KnownWebApplicationFirewallEnabledState["Disabled"] = "Disabled";
    KnownWebApplicationFirewallEnabledState["Enabled"] = "Enabled";
})(exports.KnownWebApplicationFirewallEnabledState || (exports.KnownWebApplicationFirewallEnabledState = {}));
(function (KnownWebApplicationFirewallMode) {
    KnownWebApplicationFirewallMode["Prevention"] = "Prevention";
    KnownWebApplicationFirewallMode["Detection"] = "Detection";
})(exports.KnownWebApplicationFirewallMode || (exports.KnownWebApplicationFirewallMode = {}));
(function (KnownWebApplicationFirewallRuleType) {
    KnownWebApplicationFirewallRuleType["MatchRule"] = "MatchRule";
    KnownWebApplicationFirewallRuleType["Invalid"] = "Invalid";
})(exports.KnownWebApplicationFirewallRuleType || (exports.KnownWebApplicationFirewallRuleType = {}));
(function (KnownWebApplicationFirewallMatchVariable) {
    KnownWebApplicationFirewallMatchVariable["RemoteAddr"] = "RemoteAddr";
    KnownWebApplicationFirewallMatchVariable["RequestMethod"] = "RequestMethod";
    KnownWebApplicationFirewallMatchVariable["QueryString"] = "QueryString";
    KnownWebApplicationFirewallMatchVariable["PostArgs"] = "PostArgs";
    KnownWebApplicationFirewallMatchVariable["RequestUri"] = "RequestUri";
    KnownWebApplicationFirewallMatchVariable["RequestHeaders"] = "RequestHeaders";
    KnownWebApplicationFirewallMatchVariable["RequestBody"] = "RequestBody";
    KnownWebApplicationFirewallMatchVariable["RequestCookies"] = "RequestCookies";
})(exports.KnownWebApplicationFirewallMatchVariable || (exports.KnownWebApplicationFirewallMatchVariable = {}));
(function (KnownWebApplicationFirewallOperator) {
    KnownWebApplicationFirewallOperator["IPMatch"] = "IPMatch";
    KnownWebApplicationFirewallOperator["Equal"] = "Equal";
    KnownWebApplicationFirewallOperator["Contains"] = "Contains";
    KnownWebApplicationFirewallOperator["LessThan"] = "LessThan";
    KnownWebApplicationFirewallOperator["GreaterThan"] = "GreaterThan";
    KnownWebApplicationFirewallOperator["LessThanOrEqual"] = "LessThanOrEqual";
    KnownWebApplicationFirewallOperator["GreaterThanOrEqual"] = "GreaterThanOrEqual";
    KnownWebApplicationFirewallOperator["BeginsWith"] = "BeginsWith";
    KnownWebApplicationFirewallOperator["EndsWith"] = "EndsWith";
    KnownWebApplicationFirewallOperator["Regex"] = "Regex";
    KnownWebApplicationFirewallOperator["GeoMatch"] = "GeoMatch";
})(exports.KnownWebApplicationFirewallOperator || (exports.KnownWebApplicationFirewallOperator = {}));
(function (KnownWebApplicationFirewallTransform) {
    KnownWebApplicationFirewallTransform["Lowercase"] = "Lowercase";
    KnownWebApplicationFirewallTransform["Trim"] = "Trim";
    KnownWebApplicationFirewallTransform["UrlDecode"] = "UrlDecode";
    KnownWebApplicationFirewallTransform["UrlEncode"] = "UrlEncode";
    KnownWebApplicationFirewallTransform["RemoveNulls"] = "RemoveNulls";
    KnownWebApplicationFirewallTransform["HtmlEntityDecode"] = "HtmlEntityDecode";
})(exports.KnownWebApplicationFirewallTransform || (exports.KnownWebApplicationFirewallTransform = {}));
(function (KnownWebApplicationFirewallAction) {
    KnownWebApplicationFirewallAction["Allow"] = "Allow";
    KnownWebApplicationFirewallAction["Block"] = "Block";
    KnownWebApplicationFirewallAction["Log"] = "Log";
})(exports.KnownWebApplicationFirewallAction || (exports.KnownWebApplicationFirewallAction = {}));
(function (KnownWebApplicationFirewallPolicyResourceState) {
    KnownWebApplicationFirewallPolicyResourceState["Creating"] = "Creating";
    KnownWebApplicationFirewallPolicyResourceState["Enabling"] = "Enabling";
    KnownWebApplicationFirewallPolicyResourceState["Enabled"] = "Enabled";
    KnownWebApplicationFirewallPolicyResourceState["Disabling"] = "Disabling";
    KnownWebApplicationFirewallPolicyResourceState["Disabled"] = "Disabled";
    KnownWebApplicationFirewallPolicyResourceState["Deleting"] = "Deleting";
})(exports.KnownWebApplicationFirewallPolicyResourceState || (exports.KnownWebApplicationFirewallPolicyResourceState = {}));
(function (KnownOwaspCrsExclusionEntryMatchVariable) {
    KnownOwaspCrsExclusionEntryMatchVariable["RequestHeaderNames"] = "RequestHeaderNames";
    KnownOwaspCrsExclusionEntryMatchVariable["RequestCookieNames"] = "RequestCookieNames";
    KnownOwaspCrsExclusionEntryMatchVariable["RequestArgNames"] = "RequestArgNames";
    KnownOwaspCrsExclusionEntryMatchVariable["RequestHeaderKeys"] = "RequestHeaderKeys";
    KnownOwaspCrsExclusionEntryMatchVariable["RequestHeaderValues"] = "RequestHeaderValues";
    KnownOwaspCrsExclusionEntryMatchVariable["RequestCookieKeys"] = "RequestCookieKeys";
    KnownOwaspCrsExclusionEntryMatchVariable["RequestCookieValues"] = "RequestCookieValues";
    KnownOwaspCrsExclusionEntryMatchVariable["RequestArgKeys"] = "RequestArgKeys";
    KnownOwaspCrsExclusionEntryMatchVariable["RequestArgValues"] = "RequestArgValues";
})(exports.KnownOwaspCrsExclusionEntryMatchVariable || (exports.KnownOwaspCrsExclusionEntryMatchVariable = {}));
(function (KnownOwaspCrsExclusionEntrySelectorMatchOperator) {
    KnownOwaspCrsExclusionEntrySelectorMatchOperator["Equals"] = "Equals";
    KnownOwaspCrsExclusionEntrySelectorMatchOperator["Contains"] = "Contains";
    KnownOwaspCrsExclusionEntrySelectorMatchOperator["StartsWith"] = "StartsWith";
    KnownOwaspCrsExclusionEntrySelectorMatchOperator["EndsWith"] = "EndsWith";
    KnownOwaspCrsExclusionEntrySelectorMatchOperator["EqualsAny"] = "EqualsAny";
})(exports.KnownOwaspCrsExclusionEntrySelectorMatchOperator || (exports.KnownOwaspCrsExclusionEntrySelectorMatchOperator = {}));
(function (KnownManagedRuleEnabledState) {
    KnownManagedRuleEnabledState["Disabled"] = "Disabled";
})(exports.KnownManagedRuleEnabledState || (exports.KnownManagedRuleEnabledState = {}));
(function (KnownFirewallPolicyNatRuleCollectionActionType) {
    KnownFirewallPolicyNatRuleCollectionActionType["Dnat"] = "DNAT";
})(exports.KnownFirewallPolicyNatRuleCollectionActionType || (exports.KnownFirewallPolicyNatRuleCollectionActionType = {}));
(function (KnownFirewallPolicyRuleType) {
    KnownFirewallPolicyRuleType["ApplicationRule"] = "ApplicationRule";
    KnownFirewallPolicyRuleType["NetworkRule"] = "NetworkRule";
    KnownFirewallPolicyRuleType["NatRule"] = "NatRule";
})(exports.KnownFirewallPolicyRuleType || (exports.KnownFirewallPolicyRuleType = {}));
(function (KnownFirewallPolicyFilterRuleCollectionActionType) {
    KnownFirewallPolicyFilterRuleCollectionActionType["Allow"] = "Allow";
    KnownFirewallPolicyFilterRuleCollectionActionType["Deny"] = "Deny";
})(exports.KnownFirewallPolicyFilterRuleCollectionActionType || (exports.KnownFirewallPolicyFilterRuleCollectionActionType = {}));
(function (KnownFirewallPolicyRuleApplicationProtocolType) {
    KnownFirewallPolicyRuleApplicationProtocolType["Http"] = "Http";
    KnownFirewallPolicyRuleApplicationProtocolType["Https"] = "Https";
})(exports.KnownFirewallPolicyRuleApplicationProtocolType || (exports.KnownFirewallPolicyRuleApplicationProtocolType = {}));
(function (KnownFirewallPolicyRuleNetworkProtocol) {
    KnownFirewallPolicyRuleNetworkProtocol["TCP"] = "TCP";
    KnownFirewallPolicyRuleNetworkProtocol["UDP"] = "UDP";
    KnownFirewallPolicyRuleNetworkProtocol["Any"] = "Any";
    KnownFirewallPolicyRuleNetworkProtocol["Icmp"] = "ICMP";
})(exports.KnownFirewallPolicyRuleNetworkProtocol || (exports.KnownFirewallPolicyRuleNetworkProtocol = {}));
(function (KnownNetworkOperationStatus) {
    KnownNetworkOperationStatus["InProgress"] = "InProgress";
    KnownNetworkOperationStatus["Succeeded"] = "Succeeded";
    KnownNetworkOperationStatus["Failed"] = "Failed";
})(exports.KnownNetworkOperationStatus || (exports.KnownNetworkOperationStatus = {}));
(function (KnownTunnelConnectionStatus) {
    KnownTunnelConnectionStatus["Unknown"] = "Unknown";
    KnownTunnelConnectionStatus["Connecting"] = "Connecting";
    KnownTunnelConnectionStatus["Connected"] = "Connected";
    KnownTunnelConnectionStatus["NotConnected"] = "NotConnected";
})(exports.KnownTunnelConnectionStatus || (exports.KnownTunnelConnectionStatus = {}));
(function (KnownHubVirtualNetworkConnectionStatus) {
    KnownHubVirtualNetworkConnectionStatus["Unknown"] = "Unknown";
    KnownHubVirtualNetworkConnectionStatus["Connecting"] = "Connecting";
    KnownHubVirtualNetworkConnectionStatus["Connected"] = "Connected";
    KnownHubVirtualNetworkConnectionStatus["NotConnected"] = "NotConnected";
})(exports.KnownHubVirtualNetworkConnectionStatus || (exports.KnownHubVirtualNetworkConnectionStatus = {}));

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
class LroImpl {
    constructor(sendOperationFn, args, spec, requestPath = spec.path, requestMethod = spec.httpMethod) {
        this.sendOperationFn = sendOperationFn;
        this.args = args;
        this.spec = spec;
        this.requestPath = requestPath;
        this.requestMethod = requestMethod;
    }
    sendInitialRequest() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return this.sendOperationFn(this.args, this.spec);
        });
    }
    sendPollRequest(path) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const _a = this.spec, restSpec = tslib.__rest(_a, ["requestBody"]);
            return this.sendOperationFn(this.args, Object.assign(Object.assign({}, restSpec), { path, httpMethod: "GET" }));
        });
    }
}

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const CloudError = {
    type: {
        name: "Composite",
        className: "CloudError",
        modelProperties: {
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "CloudErrorBody"
                }
            }
        }
    }
};
const CloudErrorBody = {
    type: {
        name: "Composite",
        className: "CloudErrorBody",
        modelProperties: {
            code: {
                serializedName: "code",
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                type: {
                    name: "String"
                }
            },
            target: {
                serializedName: "target",
                type: {
                    name: "String"
                }
            },
            details: {
                serializedName: "details",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "CloudErrorBody"
                        }
                    }
                }
            }
        }
    }
};
const ApplicationGatewaySku = {
    type: {
        name: "Composite",
        className: "ApplicationGatewaySku",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            tier: {
                serializedName: "tier",
                type: {
                    name: "String"
                }
            },
            capacity: {
                serializedName: "capacity",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const ApplicationGatewaySslPolicy = {
    type: {
        name: "Composite",
        className: "ApplicationGatewaySslPolicy",
        modelProperties: {
            disabledSslProtocols: {
                serializedName: "disabledSslProtocols",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            policyType: {
                serializedName: "policyType",
                type: {
                    name: "String"
                }
            },
            policyName: {
                serializedName: "policyName",
                type: {
                    name: "String"
                }
            },
            cipherSuites: {
                serializedName: "cipherSuites",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            minProtocolVersion: {
                serializedName: "minProtocolVersion",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SubResource = {
    type: {
        name: "Composite",
        className: "SubResource",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ApplicationGatewayProbeHealthResponseMatch = {
    type: {
        name: "Composite",
        className: "ApplicationGatewayProbeHealthResponseMatch",
        modelProperties: {
            body: {
                serializedName: "body",
                type: {
                    name: "String"
                }
            },
            statusCodes: {
                serializedName: "statusCodes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const Resource = {
    type: {
        name: "Composite",
        className: "Resource",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }
        }
    }
};
const ExtendedLocation = {
    type: {
        name: "Composite",
        className: "ExtendedLocation",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PrivateLinkServiceConnectionState = {
    type: {
        name: "Composite",
        className: "PrivateLinkServiceConnectionState",
        modelProperties: {
            status: {
                serializedName: "status",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            },
            actionsRequired: {
                serializedName: "actionsRequired",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CustomDnsConfigPropertiesFormat = {
    type: {
        name: "Composite",
        className: "CustomDnsConfigPropertiesFormat",
        modelProperties: {
            fqdn: {
                serializedName: "fqdn",
                type: {
                    name: "String"
                }
            },
            ipAddresses: {
                serializedName: "ipAddresses",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const PrivateEndpointIPConfiguration = {
    type: {
        name: "Composite",
        className: "PrivateEndpointIPConfiguration",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            groupId: {
                serializedName: "properties.groupId",
                type: {
                    name: "String"
                }
            },
            memberName: {
                serializedName: "properties.memberName",
                type: {
                    name: "String"
                }
            },
            privateIPAddress: {
                serializedName: "properties.privateIPAddress",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const NetworkInterfaceDnsSettings = {
    type: {
        name: "Composite",
        className: "NetworkInterfaceDnsSettings",
        modelProperties: {
            dnsServers: {
                serializedName: "dnsServers",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            appliedDnsServers: {
                serializedName: "appliedDnsServers",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            internalDnsNameLabel: {
                serializedName: "internalDnsNameLabel",
                type: {
                    name: "String"
                }
            },
            internalFqdn: {
                serializedName: "internalFqdn",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            internalDomainNameSuffix: {
                serializedName: "internalDomainNameSuffix",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ResourceSet = {
    type: {
        name: "Composite",
        className: "ResourceSet",
        modelProperties: {
            subscriptions: {
                serializedName: "subscriptions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const RetentionPolicyParameters = {
    type: {
        name: "Composite",
        className: "RetentionPolicyParameters",
        modelProperties: {
            days: {
                defaultValue: 0,
                serializedName: "days",
                type: {
                    name: "Number"
                }
            },
            enabled: {
                defaultValue: false,
                serializedName: "enabled",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const FlowLogFormatParameters = {
    type: {
        name: "Composite",
        className: "FlowLogFormatParameters",
        modelProperties: {
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            },
            version: {
                defaultValue: 0,
                serializedName: "version",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const TrafficAnalyticsProperties = {
    type: {
        name: "Composite",
        className: "TrafficAnalyticsProperties",
        modelProperties: {
            networkWatcherFlowAnalyticsConfiguration: {
                serializedName: "networkWatcherFlowAnalyticsConfiguration",
                type: {
                    name: "Composite",
                    className: "TrafficAnalyticsConfigurationProperties"
                }
            }
        }
    }
};
const TrafficAnalyticsConfigurationProperties = {
    type: {
        name: "Composite",
        className: "TrafficAnalyticsConfigurationProperties",
        modelProperties: {
            enabled: {
                serializedName: "enabled",
                type: {
                    name: "Boolean"
                }
            },
            workspaceId: {
                serializedName: "workspaceId",
                type: {
                    name: "String"
                }
            },
            workspaceRegion: {
                serializedName: "workspaceRegion",
                type: {
                    name: "String"
                }
            },
            workspaceResourceId: {
                serializedName: "workspaceResourceId",
                type: {
                    name: "String"
                }
            },
            trafficAnalyticsInterval: {
                serializedName: "trafficAnalyticsInterval",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const ServiceEndpointPropertiesFormat = {
    type: {
        name: "Composite",
        className: "ServiceEndpointPropertiesFormat",
        modelProperties: {
            service: {
                serializedName: "service",
                type: {
                    name: "String"
                }
            },
            locations: {
                serializedName: "locations",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            provisioningState: {
                serializedName: "provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PublicIPAddressSku = {
    type: {
        name: "Composite",
        className: "PublicIPAddressSku",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            tier: {
                serializedName: "tier",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PublicIPAddressDnsSettings = {
    type: {
        name: "Composite",
        className: "PublicIPAddressDnsSettings",
        modelProperties: {
            domainNameLabel: {
                serializedName: "domainNameLabel",
                type: {
                    name: "String"
                }
            },
            fqdn: {
                serializedName: "fqdn",
                type: {
                    name: "String"
                }
            },
            reverseFqdn: {
                serializedName: "reverseFqdn",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DdosSettings = {
    type: {
        name: "Composite",
        className: "DdosSettings",
        modelProperties: {
            ddosCustomPolicy: {
                serializedName: "ddosCustomPolicy",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            },
            protectionCoverage: {
                serializedName: "protectionCoverage",
                type: {
                    name: "String"
                }
            },
            protectedIP: {
                serializedName: "protectedIP",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const IpTag = {
    type: {
        name: "Composite",
        className: "IpTag",
        modelProperties: {
            ipTagType: {
                serializedName: "ipTagType",
                type: {
                    name: "String"
                }
            },
            tag: {
                serializedName: "tag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const NatGatewaySku = {
    type: {
        name: "Composite",
        className: "NatGatewaySku",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const GatewayLoadBalancerTunnelInterface = {
    type: {
        name: "Composite",
        className: "GatewayLoadBalancerTunnelInterface",
        modelProperties: {
            port: {
                serializedName: "port",
                type: {
                    name: "Number"
                }
            },
            identifier: {
                serializedName: "identifier",
                type: {
                    name: "Number"
                }
            },
            protocol: {
                serializedName: "protocol",
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const LoadBalancerBackendAddress = {
    type: {
        name: "Composite",
        className: "LoadBalancerBackendAddress",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            virtualNetwork: {
                serializedName: "properties.virtualNetwork",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            },
            subnet: {
                serializedName: "properties.subnet",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            },
            ipAddress: {
                serializedName: "properties.ipAddress",
                type: {
                    name: "String"
                }
            },
            networkInterfaceIPConfiguration: {
                serializedName: "properties.networkInterfaceIPConfiguration",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            },
            loadBalancerFrontendIPConfiguration: {
                serializedName: "properties.loadBalancerFrontendIPConfiguration",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            },
            inboundNatRulesPortMapping: {
                serializedName: "properties.inboundNatRulesPortMapping",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "NatRulePortMapping"
                        }
                    }
                }
            }
        }
    }
};
const NatRulePortMapping = {
    type: {
        name: "Composite",
        className: "NatRulePortMapping",
        modelProperties: {
            inboundNatRuleName: {
                serializedName: "inboundNatRuleName",
                type: {
                    name: "String"
                }
            },
            frontendPort: {
                serializedName: "frontendPort",
                type: {
                    name: "Number"
                }
            },
            backendPort: {
                serializedName: "backendPort",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties = {
    type: {
        name: "Composite",
        className: "NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties",
        modelProperties: {
            groupId: {
                serializedName: "groupId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            requiredMemberName: {
                serializedName: "requiredMemberName",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            fqdns: {
                serializedName: "fqdns",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const ApplicationGatewayBackendAddress = {
    type: {
        name: "Composite",
        className: "ApplicationGatewayBackendAddress",
        modelProperties: {
            fqdn: {
                serializedName: "fqdn",
                type: {
                    name: "String"
                }
            },
            ipAddress: {
                serializedName: "ipAddress",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ApplicationGatewayConnectionDraining = {
    type: {
        name: "Composite",
        className: "ApplicationGatewayConnectionDraining",
        modelProperties: {
            enabled: {
                serializedName: "enabled",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            drainTimeoutInSec: {
                constraints: {
                    InclusiveMaximum: 3600,
                    InclusiveMinimum: 1
                },
                serializedName: "drainTimeoutInSec",
                required: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const ApplicationGatewayCustomError = {
    type: {
        name: "Composite",
        className: "ApplicationGatewayCustomError",
        modelProperties: {
            statusCode: {
                serializedName: "statusCode",
                type: {
                    name: "String"
                }
            },
            customErrorPageUrl: {
                serializedName: "customErrorPageUrl",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ApplicationGatewayClientAuthConfiguration = {
    type: {
        name: "Composite",
        className: "ApplicationGatewayClientAuthConfiguration",
        modelProperties: {
            verifyClientCertIssuerDN: {
                serializedName: "verifyClientCertIssuerDN",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const ApplicationGatewayRewriteRule = {
    type: {
        name: "Composite",
        className: "ApplicationGatewayRewriteRule",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            ruleSequence: {
                serializedName: "ruleSequence",
                type: {
                    name: "Number"
                }
            },
            conditions: {
                serializedName: "conditions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationGatewayRewriteRuleCondition"
                        }
                    }
                }
            },
            actionSet: {
                serializedName: "actionSet",
                type: {
                    name: "Composite",
                    className: "ApplicationGatewayRewriteRuleActionSet"
                }
            }
        }
    }
};
const ApplicationGatewayRewriteRuleCondition = {
    type: {
        name: "Composite",
        className: "ApplicationGatewayRewriteRuleCondition",
        modelProperties: {
            variable: {
                serializedName: "variable",
                type: {
                    name: "String"
                }
            },
            pattern: {
                serializedName: "pattern",
                type: {
                    name: "String"
                }
            },
            ignoreCase: {
                serializedName: "ignoreCase",
                type: {
                    name: "Boolean"
                }
            },
            negate: {
                serializedName: "negate",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const ApplicationGatewayRewriteRuleActionSet = {
    type: {
        name: "Composite",
        className: "ApplicationGatewayRewriteRuleActionSet",
        modelProperties: {
            requestHeaderConfigurations: {
                serializedName: "requestHeaderConfigurations",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationGatewayHeaderConfiguration"
                        }
                    }
                }
            },
            responseHeaderConfigurations: {
                serializedName: "responseHeaderConfigurations",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationGatewayHeaderConfiguration"
                        }
                    }
                }
            },
            urlConfiguration: {
                serializedName: "urlConfiguration",
                type: {
                    name: "Composite",
                    className: "ApplicationGatewayUrlConfiguration"
                }
            }
        }
    }
};
const ApplicationGatewayHeaderConfiguration = {
    type: {
        name: "Composite",
        className: "ApplicationGatewayHeaderConfiguration",
        modelProperties: {
            headerName: {
                serializedName: "headerName",
                type: {
                    name: "String"
                }
            },
            headerValue: {
                serializedName: "headerValue",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ApplicationGatewayUrlConfiguration = {
    type: {
        name: "Composite",
        className: "ApplicationGatewayUrlConfiguration",
        modelProperties: {
            modifiedPath: {
                serializedName: "modifiedPath",
                type: {
                    name: "String"
                }
            },
            modifiedQueryString: {
                serializedName: "modifiedQueryString",
                type: {
                    name: "String"
                }
            },
            reroute: {
                serializedName: "reroute",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const ApplicationGatewayWebApplicationFirewallConfiguration = {
    type: {
        name: "Composite",
        className: "ApplicationGatewayWebApplicationFirewallConfiguration",
        modelProperties: {
            enabled: {
                serializedName: "enabled",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            firewallMode: {
                serializedName: "firewallMode",
                required: true,
                type: {
                    name: "String"
                }
            },
            ruleSetType: {
                serializedName: "ruleSetType",
                required: true,
                type: {
                    name: "String"
                }
            },
            ruleSetVersion: {
                serializedName: "ruleSetVersion",
                required: true,
                type: {
                    name: "String"
                }
            },
            disabledRuleGroups: {
                serializedName: "disabledRuleGroups",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationGatewayFirewallDisabledRuleGroup"
                        }
                    }
                }
            },
            requestBodyCheck: {
                serializedName: "requestBodyCheck",
                type: {
                    name: "Boolean"
                }
            },
            maxRequestBodySize: {
                constraints: {
                    InclusiveMaximum: 128,
                    InclusiveMinimum: 8
                },
                serializedName: "maxRequestBodySize",
                type: {
                    name: "Number"
                }
            },
            maxRequestBodySizeInKb: {
                constraints: {
                    InclusiveMaximum: 128,
                    InclusiveMinimum: 8
                },
                serializedName: "maxRequestBodySizeInKb",
                type: {
                    name: "Number"
                }
            },
            fileUploadLimitInMb: {
                constraints: {
                    InclusiveMinimum: 0
                },
                serializedName: "fileUploadLimitInMb",
                type: {
                    name: "Number"
                }
            },
            exclusions: {
                serializedName: "exclusions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationGatewayFirewallExclusion"
                        }
                    }
                }
            }
        }
    }
};
const ApplicationGatewayFirewallDisabledRuleGroup = {
    type: {
        name: "Composite",
        className: "ApplicationGatewayFirewallDisabledRuleGroup",
        modelProperties: {
            ruleGroupName: {
                serializedName: "ruleGroupName",
                required: true,
                type: {
                    name: "String"
                }
            },
            rules: {
                serializedName: "rules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Number"
                        }
                    }
                }
            }
        }
    }
};
const ApplicationGatewayFirewallExclusion = {
    type: {
        name: "Composite",
        className: "ApplicationGatewayFirewallExclusion",
        modelProperties: {
            matchVariable: {
                serializedName: "matchVariable",
                required: true,
                type: {
                    name: "String"
                }
            },
            selectorMatchOperator: {
                serializedName: "selectorMatchOperator",
                required: true,
                type: {
                    name: "String"
                }
            },
            selector: {
                serializedName: "selector",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ApplicationGatewayAutoscaleConfiguration = {
    type: {
        name: "Composite",
        className: "ApplicationGatewayAutoscaleConfiguration",
        modelProperties: {
            minCapacity: {
                constraints: {
                    InclusiveMinimum: 0
                },
                serializedName: "minCapacity",
                required: true,
                type: {
                    name: "Number"
                }
            },
            maxCapacity: {
                constraints: {
                    InclusiveMinimum: 2
                },
                serializedName: "maxCapacity",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const ApplicationGatewayGlobalConfiguration = {
    type: {
        name: "Composite",
        className: "ApplicationGatewayGlobalConfiguration",
        modelProperties: {
            enableRequestBuffering: {
                serializedName: "enableRequestBuffering",
                type: {
                    name: "Boolean"
                }
            },
            enableResponseBuffering: {
                serializedName: "enableResponseBuffering",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const ManagedServiceIdentity = {
    type: {
        name: "Composite",
        className: "ManagedServiceIdentity",
        modelProperties: {
            principalId: {
                serializedName: "principalId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            tenantId: {
                serializedName: "tenantId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "SystemAssigned",
                        "UserAssigned",
                        "SystemAssigned, UserAssigned",
                        "None"
                    ]
                }
            },
            userAssignedIdentities: {
                serializedName: "userAssignedIdentities",
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "Composite",
                            className: "Components1Jq1T4ISchemasManagedserviceidentityPropertiesUserassignedidentitiesAdditionalproperties"
                        }
                    }
                }
            }
        }
    }
};
const Components1Jq1T4ISchemasManagedserviceidentityPropertiesUserassignedidentitiesAdditionalproperties = {
    type: {
        name: "Composite",
        className: "Components1Jq1T4ISchemasManagedserviceidentityPropertiesUserassignedidentitiesAdditionalproperties",
        modelProperties: {
            principalId: {
                serializedName: "principalId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            clientId: {
                serializedName: "clientId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TagsObject = {
    type: {
        name: "Composite",
        className: "TagsObject",
        modelProperties: {
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }
        }
    }
};
const ApplicationGatewayListResult = {
    type: {
        name: "Composite",
        className: "ApplicationGatewayListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationGateway"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ApplicationGatewayBackendHealth = {
    type: {
        name: "Composite",
        className: "ApplicationGatewayBackendHealth",
        modelProperties: {
            backendAddressPools: {
                serializedName: "backendAddressPools",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationGatewayBackendHealthPool"
                        }
                    }
                }
            }
        }
    }
};
const ApplicationGatewayBackendHealthPool = {
    type: {
        name: "Composite",
        className: "ApplicationGatewayBackendHealthPool",
        modelProperties: {
            backendAddressPool: {
                serializedName: "backendAddressPool",
                type: {
                    name: "Composite",
                    className: "ApplicationGatewayBackendAddressPool"
                }
            },
            backendHttpSettingsCollection: {
                serializedName: "backendHttpSettingsCollection",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationGatewayBackendHealthHttpSettings"
                        }
                    }
                }
            }
        }
    }
};
const ApplicationGatewayBackendHealthHttpSettings = {
    type: {
        name: "Composite",
        className: "ApplicationGatewayBackendHealthHttpSettings",
        modelProperties: {
            backendHttpSettings: {
                serializedName: "backendHttpSettings",
                type: {
                    name: "Composite",
                    className: "ApplicationGatewayBackendHttpSettings"
                }
            },
            servers: {
                serializedName: "servers",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationGatewayBackendHealthServer"
                        }
                    }
                }
            }
        }
    }
};
const ApplicationGatewayBackendHealthServer = {
    type: {
        name: "Composite",
        className: "ApplicationGatewayBackendHealthServer",
        modelProperties: {
            address: {
                serializedName: "address",
                type: {
                    name: "String"
                }
            },
            ipConfiguration: {
                serializedName: "ipConfiguration",
                type: {
                    name: "Composite",
                    className: "NetworkInterfaceIPConfiguration"
                }
            },
            health: {
                serializedName: "health",
                type: {
                    name: "String"
                }
            },
            healthProbeLog: {
                serializedName: "healthProbeLog",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ApplicationGatewayOnDemandProbe = {
    type: {
        name: "Composite",
        className: "ApplicationGatewayOnDemandProbe",
        modelProperties: {
            protocol: {
                serializedName: "protocol",
                type: {
                    name: "String"
                }
            },
            host: {
                serializedName: "host",
                type: {
                    name: "String"
                }
            },
            path: {
                serializedName: "path",
                type: {
                    name: "String"
                }
            },
            timeout: {
                serializedName: "timeout",
                type: {
                    name: "Number"
                }
            },
            pickHostNameFromBackendHttpSettings: {
                serializedName: "pickHostNameFromBackendHttpSettings",
                type: {
                    name: "Boolean"
                }
            },
            match: {
                serializedName: "match",
                type: {
                    name: "Composite",
                    className: "ApplicationGatewayProbeHealthResponseMatch"
                }
            },
            backendAddressPool: {
                serializedName: "backendAddressPool",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            },
            backendHttpSettings: {
                serializedName: "backendHttpSettings",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }
        }
    }
};
const ApplicationGatewayBackendHealthOnDemand = {
    type: {
        name: "Composite",
        className: "ApplicationGatewayBackendHealthOnDemand",
        modelProperties: {
            backendAddressPool: {
                serializedName: "backendAddressPool",
                type: {
                    name: "Composite",
                    className: "ApplicationGatewayBackendAddressPool"
                }
            },
            backendHealthHttpSettings: {
                serializedName: "backendHealthHttpSettings",
                type: {
                    name: "Composite",
                    className: "ApplicationGatewayBackendHealthHttpSettings"
                }
            }
        }
    }
};
const ApplicationGatewayPrivateLinkResourceListResult = {
    type: {
        name: "Composite",
        className: "ApplicationGatewayPrivateLinkResourceListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationGatewayPrivateLinkResource"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ApplicationGatewayPrivateEndpointConnectionListResult = {
    type: {
        name: "Composite",
        className: "ApplicationGatewayPrivateEndpointConnectionListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationGatewayPrivateEndpointConnection"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ErrorModel = {
    type: {
        name: "Composite",
        className: "ErrorModel",
        modelProperties: {
            code: {
                serializedName: "code",
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                type: {
                    name: "String"
                }
            },
            target: {
                serializedName: "target",
                type: {
                    name: "String"
                }
            },
            details: {
                serializedName: "details",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ErrorDetails"
                        }
                    }
                }
            },
            innerError: {
                serializedName: "innerError",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ErrorDetails = {
    type: {
        name: "Composite",
        className: "ErrorDetails",
        modelProperties: {
            code: {
                serializedName: "code",
                type: {
                    name: "String"
                }
            },
            target: {
                serializedName: "target",
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ApplicationGatewayAvailableWafRuleSetsResult = {
    type: {
        name: "Composite",
        className: "ApplicationGatewayAvailableWafRuleSetsResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationGatewayFirewallRuleSet"
                        }
                    }
                }
            }
        }
    }
};
const ApplicationGatewayFirewallRuleGroup = {
    type: {
        name: "Composite",
        className: "ApplicationGatewayFirewallRuleGroup",
        modelProperties: {
            ruleGroupName: {
                serializedName: "ruleGroupName",
                required: true,
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            },
            rules: {
                serializedName: "rules",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationGatewayFirewallRule"
                        }
                    }
                }
            }
        }
    }
};
const ApplicationGatewayFirewallRule = {
    type: {
        name: "Composite",
        className: "ApplicationGatewayFirewallRule",
        modelProperties: {
            ruleId: {
                serializedName: "ruleId",
                required: true,
                type: {
                    name: "Number"
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ApplicationGatewayAvailableSslPredefinedPolicies = {
    type: {
        name: "Composite",
        className: "ApplicationGatewayAvailableSslPredefinedPolicies",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationGatewaySslPredefinedPolicy"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ApplicationSecurityGroupListResult = {
    type: {
        name: "Composite",
        className: "ApplicationSecurityGroupListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationSecurityGroup"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AvailableDelegationsResult = {
    type: {
        name: "Composite",
        className: "AvailableDelegationsResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AvailableDelegation"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AvailableDelegation = {
    type: {
        name: "Composite",
        className: "AvailableDelegation",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            },
            serviceName: {
                serializedName: "serviceName",
                type: {
                    name: "String"
                }
            },
            actions: {
                serializedName: "actions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const AvailableServiceAliasesResult = {
    type: {
        name: "Composite",
        className: "AvailableServiceAliasesResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AvailableServiceAlias"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AvailableServiceAlias = {
    type: {
        name: "Composite",
        className: "AvailableServiceAlias",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            },
            resourceName: {
                serializedName: "resourceName",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AzureFirewallRCAction = {
    type: {
        name: "Composite",
        className: "AzureFirewallRCAction",
        modelProperties: {
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AzureFirewallApplicationRule = {
    type: {
        name: "Composite",
        className: "AzureFirewallApplicationRule",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            },
            sourceAddresses: {
                serializedName: "sourceAddresses",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            protocols: {
                serializedName: "protocols",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AzureFirewallApplicationRuleProtocol"
                        }
                    }
                }
            },
            targetFqdns: {
                serializedName: "targetFqdns",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            fqdnTags: {
                serializedName: "fqdnTags",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            sourceIpGroups: {
                serializedName: "sourceIpGroups",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const AzureFirewallApplicationRuleProtocol = {
    type: {
        name: "Composite",
        className: "AzureFirewallApplicationRuleProtocol",
        modelProperties: {
            protocolType: {
                serializedName: "protocolType",
                type: {
                    name: "String"
                }
            },
            port: {
                constraints: {
                    InclusiveMaximum: 64000,
                    InclusiveMinimum: 0
                },
                serializedName: "port",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const AzureFirewallNatRCAction = {
    type: {
        name: "Composite",
        className: "AzureFirewallNatRCAction",
        modelProperties: {
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AzureFirewallNatRule = {
    type: {
        name: "Composite",
        className: "AzureFirewallNatRule",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            },
            sourceAddresses: {
                serializedName: "sourceAddresses",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            destinationAddresses: {
                serializedName: "destinationAddresses",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            destinationPorts: {
                serializedName: "destinationPorts",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            protocols: {
                serializedName: "protocols",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            translatedAddress: {
                serializedName: "translatedAddress",
                type: {
                    name: "String"
                }
            },
            translatedPort: {
                serializedName: "translatedPort",
                type: {
                    name: "String"
                }
            },
            translatedFqdn: {
                serializedName: "translatedFqdn",
                type: {
                    name: "String"
                }
            },
            sourceIpGroups: {
                serializedName: "sourceIpGroups",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const AzureFirewallNetworkRule = {
    type: {
        name: "Composite",
        className: "AzureFirewallNetworkRule",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            },
            protocols: {
                serializedName: "protocols",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            sourceAddresses: {
                serializedName: "sourceAddresses",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            destinationAddresses: {
                serializedName: "destinationAddresses",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            destinationPorts: {
                serializedName: "destinationPorts",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            destinationFqdns: {
                serializedName: "destinationFqdns",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            sourceIpGroups: {
                serializedName: "sourceIpGroups",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            destinationIpGroups: {
                serializedName: "destinationIpGroups",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const HubIPAddresses = {
    type: {
        name: "Composite",
        className: "HubIPAddresses",
        modelProperties: {
            publicIPs: {
                serializedName: "publicIPs",
                type: {
                    name: "Composite",
                    className: "HubPublicIPAddresses"
                }
            },
            privateIPAddress: {
                serializedName: "privateIPAddress",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const HubPublicIPAddresses = {
    type: {
        name: "Composite",
        className: "HubPublicIPAddresses",
        modelProperties: {
            addresses: {
                serializedName: "addresses",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AzureFirewallPublicIPAddress"
                        }
                    }
                }
            },
            count: {
                serializedName: "count",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const AzureFirewallPublicIPAddress = {
    type: {
        name: "Composite",
        className: "AzureFirewallPublicIPAddress",
        modelProperties: {
            address: {
                serializedName: "address",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AzureFirewallIpGroups = {
    type: {
        name: "Composite",
        className: "AzureFirewallIpGroups",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            changeNumber: {
                serializedName: "changeNumber",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AzureFirewallSku = {
    type: {
        name: "Composite",
        className: "AzureFirewallSku",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            tier: {
                serializedName: "tier",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AzureFirewallListResult = {
    type: {
        name: "Composite",
        className: "AzureFirewallListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AzureFirewall"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AzureFirewallFqdnTagListResult = {
    type: {
        name: "Composite",
        className: "AzureFirewallFqdnTagListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AzureFirewallFqdnTag"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AzureWebCategory = {
    type: {
        name: "Composite",
        className: "AzureWebCategory",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            group: {
                serializedName: "properties.group",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AzureWebCategoryListResult = {
    type: {
        name: "Composite",
        className: "AzureWebCategoryListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AzureWebCategory"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Sku = {
    type: {
        name: "Composite",
        className: "Sku",
        modelProperties: {
            name: {
                defaultValue: "Standard",
                serializedName: "name",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const BastionHostListResult = {
    type: {
        name: "Composite",
        className: "BastionHostListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "BastionHost"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const BastionShareableLinkListRequest = {
    type: {
        name: "Composite",
        className: "BastionShareableLinkListRequest",
        modelProperties: {
            vms: {
                serializedName: "vms",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "BastionShareableLink"
                        }
                    }
                }
            }
        }
    }
};
const BastionShareableLink = {
    type: {
        name: "Composite",
        className: "BastionShareableLink",
        modelProperties: {
            vm: {
                serializedName: "vm",
                type: {
                    name: "Composite",
                    className: "Vm"
                }
            },
            bsl: {
                serializedName: "bsl",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            createdAt: {
                serializedName: "createdAt",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const BastionShareableLinkListResult = {
    type: {
        name: "Composite",
        className: "BastionShareableLinkListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "BastionShareableLink"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const BastionActiveSessionListResult = {
    type: {
        name: "Composite",
        className: "BastionActiveSessionListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "BastionActiveSession"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const BastionActiveSession = {
    type: {
        name: "Composite",
        className: "BastionActiveSession",
        modelProperties: {
            sessionId: {
                serializedName: "sessionId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            startTime: {
                serializedName: "startTime",
                readOnly: true,
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            },
            targetSubscriptionId: {
                serializedName: "targetSubscriptionId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            resourceType: {
                serializedName: "resourceType",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            targetHostName: {
                serializedName: "targetHostName",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            targetResourceGroup: {
                serializedName: "targetResourceGroup",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            userName: {
                serializedName: "userName",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            targetIpAddress: {
                serializedName: "targetIpAddress",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            protocol: {
                serializedName: "protocol",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            targetResourceId: {
                serializedName: "targetResourceId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            sessionDurationInMins: {
                serializedName: "sessionDurationInMins",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const SessionIds = {
    type: {
        name: "Composite",
        className: "SessionIds",
        modelProperties: {
            sessionIds: {
                serializedName: "sessionIds",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const BastionSessionDeleteResult = {
    type: {
        name: "Composite",
        className: "BastionSessionDeleteResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "BastionSessionState"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const BastionSessionState = {
    type: {
        name: "Composite",
        className: "BastionSessionState",
        modelProperties: {
            sessionId: {
                serializedName: "sessionId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            state: {
                serializedName: "state",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DnsNameAvailabilityResult = {
    type: {
        name: "Composite",
        className: "DnsNameAvailabilityResult",
        modelProperties: {
            available: {
                serializedName: "available",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const NetworkInterfaceListResult = {
    type: {
        name: "Composite",
        className: "NetworkInterfaceListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "NetworkInterface"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PublicIPAddressListResult = {
    type: {
        name: "Composite",
        className: "PublicIPAddressListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PublicIPAddress"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CustomIpPrefixListResult = {
    type: {
        name: "Composite",
        className: "CustomIpPrefixListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "CustomIpPrefix"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ProtocolCustomSettingsFormat = {
    type: {
        name: "Composite",
        className: "ProtocolCustomSettingsFormat",
        modelProperties: {
            protocol: {
                serializedName: "protocol",
                type: {
                    name: "String"
                }
            },
            triggerRateOverride: {
                serializedName: "triggerRateOverride",
                type: {
                    name: "String"
                }
            },
            sourceRateOverride: {
                serializedName: "sourceRateOverride",
                type: {
                    name: "String"
                }
            },
            triggerSensitivityOverride: {
                serializedName: "triggerSensitivityOverride",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DdosProtectionPlan = {
    type: {
        name: "Composite",
        className: "DdosProtectionPlan",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            resourceGuid: {
                serializedName: "properties.resourceGuid",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            virtualNetworks: {
                serializedName: "properties.virtualNetworks",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            }
        }
    }
};
const DdosProtectionPlanListResult = {
    type: {
        name: "Composite",
        className: "DdosProtectionPlanListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DdosProtectionPlan"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const QosIpRange = {
    type: {
        name: "Composite",
        className: "QosIpRange",
        modelProperties: {
            startIP: {
                serializedName: "startIP",
                type: {
                    name: "String"
                }
            },
            endIP: {
                serializedName: "endIP",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const QosPortRange = {
    type: {
        name: "Composite",
        className: "QosPortRange",
        modelProperties: {
            start: {
                serializedName: "start",
                type: {
                    name: "Number"
                }
            },
            end: {
                serializedName: "end",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const QosDefinition = {
    type: {
        name: "Composite",
        className: "QosDefinition",
        modelProperties: {
            markings: {
                serializedName: "markings",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Number"
                        }
                    }
                }
            },
            sourceIpRanges: {
                serializedName: "sourceIpRanges",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "QosIpRange"
                        }
                    }
                }
            },
            destinationIpRanges: {
                serializedName: "destinationIpRanges",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "QosIpRange"
                        }
                    }
                }
            },
            sourcePortRanges: {
                serializedName: "sourcePortRanges",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "QosPortRange"
                        }
                    }
                }
            },
            destinationPortRanges: {
                serializedName: "destinationPortRanges",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "QosPortRange"
                        }
                    }
                }
            },
            protocol: {
                serializedName: "protocol",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DscpConfigurationListResult = {
    type: {
        name: "Composite",
        className: "DscpConfigurationListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DscpConfiguration"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const EndpointServicesListResult = {
    type: {
        name: "Composite",
        className: "EndpointServicesListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "EndpointServiceResult"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AuthorizationListResult = {
    type: {
        name: "Composite",
        className: "AuthorizationListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ExpressRouteCircuitAuthorization"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ExpressRouteCircuitPeeringConfig = {
    type: {
        name: "Composite",
        className: "ExpressRouteCircuitPeeringConfig",
        modelProperties: {
            advertisedPublicPrefixes: {
                serializedName: "advertisedPublicPrefixes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            advertisedCommunities: {
                serializedName: "advertisedCommunities",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            advertisedPublicPrefixesState: {
                serializedName: "advertisedPublicPrefixesState",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            legacyMode: {
                serializedName: "legacyMode",
                type: {
                    name: "Number"
                }
            },
            customerASN: {
                serializedName: "customerASN",
                type: {
                    name: "Number"
                }
            },
            routingRegistryName: {
                serializedName: "routingRegistryName",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ExpressRouteCircuitStats = {
    type: {
        name: "Composite",
        className: "ExpressRouteCircuitStats",
        modelProperties: {
            primarybytesIn: {
                serializedName: "primarybytesIn",
                type: {
                    name: "Number"
                }
            },
            primarybytesOut: {
                serializedName: "primarybytesOut",
                type: {
                    name: "Number"
                }
            },
            secondarybytesIn: {
                serializedName: "secondarybytesIn",
                type: {
                    name: "Number"
                }
            },
            secondarybytesOut: {
                serializedName: "secondarybytesOut",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const Ipv6ExpressRouteCircuitPeeringConfig = {
    type: {
        name: "Composite",
        className: "Ipv6ExpressRouteCircuitPeeringConfig",
        modelProperties: {
            primaryPeerAddressPrefix: {
                serializedName: "primaryPeerAddressPrefix",
                type: {
                    name: "String"
                }
            },
            secondaryPeerAddressPrefix: {
                serializedName: "secondaryPeerAddressPrefix",
                type: {
                    name: "String"
                }
            },
            microsoftPeeringConfig: {
                serializedName: "microsoftPeeringConfig",
                type: {
                    name: "Composite",
                    className: "ExpressRouteCircuitPeeringConfig"
                }
            },
            routeFilter: {
                serializedName: "routeFilter",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            },
            state: {
                serializedName: "state",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ExpressRouteConnectionId = {
    type: {
        name: "Composite",
        className: "ExpressRouteConnectionId",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Ipv6CircuitConnectionConfig = {
    type: {
        name: "Composite",
        className: "Ipv6CircuitConnectionConfig",
        modelProperties: {
            addressPrefix: {
                serializedName: "addressPrefix",
                type: {
                    name: "String"
                }
            },
            circuitConnectionStatus: {
                serializedName: "circuitConnectionStatus",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ExpressRouteCircuitPeeringListResult = {
    type: {
        name: "Composite",
        className: "ExpressRouteCircuitPeeringListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ExpressRouteCircuitPeering"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ExpressRouteCircuitConnectionListResult = {
    type: {
        name: "Composite",
        className: "ExpressRouteCircuitConnectionListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ExpressRouteCircuitConnection"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PeerExpressRouteCircuitConnectionListResult = {
    type: {
        name: "Composite",
        className: "PeerExpressRouteCircuitConnectionListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PeerExpressRouteCircuitConnection"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ExpressRouteCircuitSku = {
    type: {
        name: "Composite",
        className: "ExpressRouteCircuitSku",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            tier: {
                serializedName: "tier",
                type: {
                    name: "String"
                }
            },
            family: {
                serializedName: "family",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ExpressRouteCircuitServiceProviderProperties = {
    type: {
        name: "Composite",
        className: "ExpressRouteCircuitServiceProviderProperties",
        modelProperties: {
            serviceProviderName: {
                serializedName: "serviceProviderName",
                type: {
                    name: "String"
                }
            },
            peeringLocation: {
                serializedName: "peeringLocation",
                type: {
                    name: "String"
                }
            },
            bandwidthInMbps: {
                serializedName: "bandwidthInMbps",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const ExpressRouteCircuitsArpTableListResult = {
    type: {
        name: "Composite",
        className: "ExpressRouteCircuitsArpTableListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ExpressRouteCircuitArpTable"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ExpressRouteCircuitArpTable = {
    type: {
        name: "Composite",
        className: "ExpressRouteCircuitArpTable",
        modelProperties: {
            age: {
                serializedName: "age",
                type: {
                    name: "Number"
                }
            },
            interface: {
                serializedName: "interface",
                type: {
                    name: "String"
                }
            },
            ipAddress: {
                serializedName: "ipAddress",
                type: {
                    name: "String"
                }
            },
            macAddress: {
                serializedName: "macAddress",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ExpressRouteCircuitsRoutesTableListResult = {
    type: {
        name: "Composite",
        className: "ExpressRouteCircuitsRoutesTableListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ExpressRouteCircuitRoutesTable"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ExpressRouteCircuitRoutesTable = {
    type: {
        name: "Composite",
        className: "ExpressRouteCircuitRoutesTable",
        modelProperties: {
            network: {
                serializedName: "network",
                type: {
                    name: "String"
                }
            },
            nextHop: {
                serializedName: "nextHop",
                type: {
                    name: "String"
                }
            },
            locPrf: {
                serializedName: "locPrf",
                type: {
                    name: "String"
                }
            },
            weight: {
                serializedName: "weight",
                type: {
                    name: "Number"
                }
            },
            path: {
                serializedName: "path",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ExpressRouteCircuitsRoutesTableSummaryListResult = {
    type: {
        name: "Composite",
        className: "ExpressRouteCircuitsRoutesTableSummaryListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ExpressRouteCircuitRoutesTableSummary"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ExpressRouteCircuitRoutesTableSummary = {
    type: {
        name: "Composite",
        className: "ExpressRouteCircuitRoutesTableSummary",
        modelProperties: {
            neighbor: {
                serializedName: "neighbor",
                type: {
                    name: "String"
                }
            },
            v: {
                serializedName: "v",
                type: {
                    name: "Number"
                }
            },
            as: {
                serializedName: "as",
                type: {
                    name: "Number"
                }
            },
            upDown: {
                serializedName: "upDown",
                type: {
                    name: "String"
                }
            },
            statePfxRcd: {
                serializedName: "statePfxRcd",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ExpressRouteCircuitListResult = {
    type: {
        name: "Composite",
        className: "ExpressRouteCircuitListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ExpressRouteCircuit"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ExpressRouteServiceProviderListResult = {
    type: {
        name: "Composite",
        className: "ExpressRouteServiceProviderListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ExpressRouteServiceProvider"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ExpressRouteServiceProviderBandwidthsOffered = {
    type: {
        name: "Composite",
        className: "ExpressRouteServiceProviderBandwidthsOffered",
        modelProperties: {
            offerName: {
                serializedName: "offerName",
                type: {
                    name: "String"
                }
            },
            valueInMbps: {
                serializedName: "valueInMbps",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const ExpressRouteCrossConnectionListResult = {
    type: {
        name: "Composite",
        className: "ExpressRouteCrossConnectionListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ExpressRouteCrossConnection"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ExpressRouteCircuitReference = {
    type: {
        name: "Composite",
        className: "ExpressRouteCircuitReference",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ExpressRouteCrossConnectionPeeringList = {
    type: {
        name: "Composite",
        className: "ExpressRouteCrossConnectionPeeringList",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ExpressRouteCrossConnectionPeering"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ExpressRouteCrossConnectionsRoutesTableSummaryListResult = {
    type: {
        name: "Composite",
        className: "ExpressRouteCrossConnectionsRoutesTableSummaryListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ExpressRouteCrossConnectionRoutesTableSummary"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ExpressRouteCrossConnectionRoutesTableSummary = {
    type: {
        name: "Composite",
        className: "ExpressRouteCrossConnectionRoutesTableSummary",
        modelProperties: {
            neighbor: {
                serializedName: "neighbor",
                type: {
                    name: "String"
                }
            },
            asn: {
                serializedName: "asn",
                type: {
                    name: "Number"
                }
            },
            upDown: {
                serializedName: "upDown",
                type: {
                    name: "String"
                }
            },
            stateOrPrefixesReceived: {
                serializedName: "stateOrPrefixesReceived",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ExpressRoutePortsLocationListResult = {
    type: {
        name: "Composite",
        className: "ExpressRoutePortsLocationListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ExpressRoutePortsLocation"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ExpressRoutePortsLocationBandwidths = {
    type: {
        name: "Composite",
        className: "ExpressRoutePortsLocationBandwidths",
        modelProperties: {
            offerName: {
                serializedName: "offerName",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            valueInGbps: {
                serializedName: "valueInGbps",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const ExpressRouteLinkMacSecConfig = {
    type: {
        name: "Composite",
        className: "ExpressRouteLinkMacSecConfig",
        modelProperties: {
            cknSecretIdentifier: {
                serializedName: "cknSecretIdentifier",
                type: {
                    name: "String"
                }
            },
            cakSecretIdentifier: {
                serializedName: "cakSecretIdentifier",
                type: {
                    name: "String"
                }
            },
            cipher: {
                serializedName: "cipher",
                type: {
                    name: "String"
                }
            },
            sciState: {
                serializedName: "sciState",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ExpressRoutePortListResult = {
    type: {
        name: "Composite",
        className: "ExpressRoutePortListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ExpressRoutePort"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ExpressRouteLinkListResult = {
    type: {
        name: "Composite",
        className: "ExpressRouteLinkListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ExpressRouteLink"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const GenerateExpressRoutePortsLOARequest = {
    type: {
        name: "Composite",
        className: "GenerateExpressRoutePortsLOARequest",
        modelProperties: {
            customerName: {
                serializedName: "customerName",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const GenerateExpressRoutePortsLOAResult = {
    type: {
        name: "Composite",
        className: "GenerateExpressRoutePortsLOAResult",
        modelProperties: {
            encodedContent: {
                serializedName: "encodedContent",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const FirewallPolicyThreatIntelWhitelist = {
    serializedName: "FirewallPolicyThreatIntelWhitelist",
    type: {
        name: "Composite",
        className: "FirewallPolicyThreatIntelWhitelist",
        modelProperties: {
            ipAddresses: {
                serializedName: "ipAddresses",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            fqdns: {
                serializedName: "fqdns",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const FirewallPolicyInsights = {
    serializedName: "FirewallPolicyInsights",
    type: {
        name: "Composite",
        className: "FirewallPolicyInsights",
        modelProperties: {
            isEnabled: {
                serializedName: "isEnabled",
                type: {
                    name: "Boolean"
                }
            },
            retentionDays: {
                serializedName: "retentionDays",
                type: {
                    name: "Number"
                }
            },
            logAnalyticsResources: {
                serializedName: "logAnalyticsResources",
                type: {
                    name: "Composite",
                    className: "FirewallPolicyLogAnalyticsResources"
                }
            }
        }
    }
};
const FirewallPolicyLogAnalyticsResources = {
    serializedName: "FirewallPolicyLogAnalyticsResources",
    type: {
        name: "Composite",
        className: "FirewallPolicyLogAnalyticsResources",
        modelProperties: {
            workspaces: {
                serializedName: "workspaces",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "FirewallPolicyLogAnalyticsWorkspace"
                        }
                    }
                }
            },
            defaultWorkspaceId: {
                serializedName: "defaultWorkspaceId",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }
        }
    }
};
const FirewallPolicyLogAnalyticsWorkspace = {
    serializedName: "FirewallPolicyLogAnalyticsWorkspace",
    type: {
        name: "Composite",
        className: "FirewallPolicyLogAnalyticsWorkspace",
        modelProperties: {
            region: {
                serializedName: "region",
                type: {
                    name: "String"
                }
            },
            workspaceId: {
                serializedName: "workspaceId",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }
        }
    }
};
const FirewallPolicySnat = {
    serializedName: "FirewallPolicySNAT",
    type: {
        name: "Composite",
        className: "FirewallPolicySnat",
        modelProperties: {
            privateRanges: {
                serializedName: "privateRanges",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const FirewallPolicySQL = {
    serializedName: "FirewallPolicySQL",
    type: {
        name: "Composite",
        className: "FirewallPolicySQL",
        modelProperties: {
            allowSqlRedirect: {
                serializedName: "allowSqlRedirect",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const DnsSettings = {
    serializedName: "DnsSettings",
    type: {
        name: "Composite",
        className: "DnsSettings",
        modelProperties: {
            servers: {
                serializedName: "servers",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            enableProxy: {
                serializedName: "enableProxy",
                type: {
                    name: "Boolean"
                }
            },
            requireProxyForNetworkRules: {
                serializedName: "requireProxyForNetworkRules",
                nullable: true,
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const ExplicitProxySettings = {
    serializedName: "ExplicitProxySettings",
    type: {
        name: "Composite",
        className: "ExplicitProxySettings",
        modelProperties: {
            enableExplicitProxy: {
                serializedName: "enableExplicitProxy",
                nullable: true,
                type: {
                    name: "Boolean"
                }
            },
            httpPort: {
                constraints: {
                    InclusiveMaximum: 64000,
                    InclusiveMinimum: 0
                },
                serializedName: "httpPort",
                type: {
                    name: "Number"
                }
            },
            httpsPort: {
                constraints: {
                    InclusiveMaximum: 64000,
                    InclusiveMinimum: 0
                },
                serializedName: "httpsPort",
                type: {
                    name: "Number"
                }
            },
            pacFilePort: {
                constraints: {
                    InclusiveMaximum: 64000,
                    InclusiveMinimum: 0
                },
                serializedName: "pacFilePort",
                type: {
                    name: "Number"
                }
            },
            pacFile: {
                serializedName: "pacFile",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const FirewallPolicyIntrusionDetection = {
    type: {
        name: "Composite",
        className: "FirewallPolicyIntrusionDetection",
        modelProperties: {
            mode: {
                serializedName: "mode",
                type: {
                    name: "String"
                }
            },
            configuration: {
                serializedName: "configuration",
                type: {
                    name: "Composite",
                    className: "FirewallPolicyIntrusionDetectionConfiguration"
                }
            }
        }
    }
};
const FirewallPolicyIntrusionDetectionConfiguration = {
    type: {
        name: "Composite",
        className: "FirewallPolicyIntrusionDetectionConfiguration",
        modelProperties: {
            signatureOverrides: {
                serializedName: "signatureOverrides",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "FirewallPolicyIntrusionDetectionSignatureSpecification"
                        }
                    }
                }
            },
            bypassTrafficSettings: {
                serializedName: "bypassTrafficSettings",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "FirewallPolicyIntrusionDetectionBypassTrafficSpecifications"
                        }
                    }
                }
            }
        }
    }
};
const FirewallPolicyIntrusionDetectionSignatureSpecification = {
    type: {
        name: "Composite",
        className: "FirewallPolicyIntrusionDetectionSignatureSpecification",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            mode: {
                serializedName: "mode",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const FirewallPolicyIntrusionDetectionBypassTrafficSpecifications = {
    type: {
        name: "Composite",
        className: "FirewallPolicyIntrusionDetectionBypassTrafficSpecifications",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            },
            protocol: {
                serializedName: "protocol",
                type: {
                    name: "String"
                }
            },
            sourceAddresses: {
                serializedName: "sourceAddresses",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            destinationAddresses: {
                serializedName: "destinationAddresses",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            destinationPorts: {
                serializedName: "destinationPorts",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            sourceIpGroups: {
                serializedName: "sourceIpGroups",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            destinationIpGroups: {
                serializedName: "destinationIpGroups",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const FirewallPolicyTransportSecurity = {
    type: {
        name: "Composite",
        className: "FirewallPolicyTransportSecurity",
        modelProperties: {
            certificateAuthority: {
                serializedName: "certificateAuthority",
                type: {
                    name: "Composite",
                    className: "FirewallPolicyCertificateAuthority"
                }
            }
        }
    }
};
const FirewallPolicyCertificateAuthority = {
    type: {
        name: "Composite",
        className: "FirewallPolicyCertificateAuthority",
        modelProperties: {
            keyVaultSecretId: {
                serializedName: "keyVaultSecretId",
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const FirewallPolicySku = {
    type: {
        name: "Composite",
        className: "FirewallPolicySku",
        modelProperties: {
            tier: {
                serializedName: "tier",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const FirewallPolicyListResult = {
    type: {
        name: "Composite",
        className: "FirewallPolicyListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "FirewallPolicy"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const FirewallPolicyRuleCollection = {
    type: {
        name: "Composite",
        className: "FirewallPolicyRuleCollection",
        uberParent: "FirewallPolicyRuleCollection",
        polymorphicDiscriminator: {
            serializedName: "ruleCollectionType",
            clientName: "ruleCollectionType"
        },
        modelProperties: {
            ruleCollectionType: {
                serializedName: "ruleCollectionType",
                required: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            priority: {
                constraints: {
                    InclusiveMaximum: 65000,
                    InclusiveMinimum: 100
                },
                serializedName: "priority",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const FirewallPolicyRuleCollectionGroupListResult = {
    type: {
        name: "Composite",
        className: "FirewallPolicyRuleCollectionGroupListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "FirewallPolicyRuleCollectionGroup"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const IdpsQueryObject = {
    type: {
        name: "Composite",
        className: "IdpsQueryObject",
        modelProperties: {
            filters: {
                serializedName: "filters",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "FilterItems"
                        }
                    }
                }
            },
            search: {
                serializedName: "search",
                type: {
                    name: "String"
                }
            },
            orderBy: {
                serializedName: "orderBy",
                type: {
                    name: "Composite",
                    className: "OrderBy"
                }
            },
            resultsPerPage: {
                constraints: {
                    InclusiveMaximum: 1000,
                    InclusiveMinimum: 1
                },
                serializedName: "resultsPerPage",
                type: {
                    name: "Number"
                }
            },
            skip: {
                serializedName: "skip",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const FilterItems = {
    type: {
        name: "Composite",
        className: "FilterItems",
        modelProperties: {
            field: {
                serializedName: "field",
                type: {
                    name: "String"
                }
            },
            values: {
                serializedName: "values",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const OrderBy = {
    type: {
        name: "Composite",
        className: "OrderBy",
        modelProperties: {
            field: {
                serializedName: "field",
                type: {
                    name: "String"
                }
            },
            order: {
                serializedName: "order",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const QueryResults = {
    type: {
        name: "Composite",
        className: "QueryResults",
        modelProperties: {
            matchingRecordsCount: {
                serializedName: "matchingRecordsCount",
                type: {
                    name: "Number"
                }
            },
            signatures: {
                serializedName: "signatures",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SingleQueryResult"
                        }
                    }
                }
            }
        }
    }
};
const SingleQueryResult = {
    type: {
        name: "Composite",
        className: "SingleQueryResult",
        modelProperties: {
            signatureId: {
                serializedName: "signatureId",
                type: {
                    name: "Number"
                }
            },
            mode: {
                serializedName: "mode",
                type: {
                    name: "Number"
                }
            },
            severity: {
                serializedName: "severity",
                type: {
                    name: "Number"
                }
            },
            direction: {
                serializedName: "direction",
                type: {
                    name: "Number"
                }
            },
            group: {
                serializedName: "group",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            },
            protocol: {
                serializedName: "protocol",
                type: {
                    name: "String"
                }
            },
            sourcePorts: {
                serializedName: "sourcePorts",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            destinationPorts: {
                serializedName: "destinationPorts",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            lastUpdated: {
                serializedName: "lastUpdated",
                type: {
                    name: "String"
                }
            },
            inheritedFromParentPolicy: {
                serializedName: "inheritedFromParentPolicy",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const SignaturesOverrides = {
    type: {
        name: "Composite",
        className: "SignaturesOverrides",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            },
            properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "SignaturesOverridesProperties"
                }
            }
        }
    }
};
const SignaturesOverridesProperties = {
    type: {
        name: "Composite",
        className: "SignaturesOverridesProperties",
        modelProperties: {
            signatures: {
                serializedName: "signatures",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }
        }
    }
};
const SignatureOverridesFilterValuesQuery = {
    type: {
        name: "Composite",
        className: "SignatureOverridesFilterValuesQuery",
        modelProperties: {
            filterName: {
                serializedName: "filterName",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SignatureOverridesFilterValuesResponse = {
    type: {
        name: "Composite",
        className: "SignatureOverridesFilterValuesResponse",
        modelProperties: {
            filterValues: {
                serializedName: "filterValues",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const SignaturesOverridesList = {
    type: {
        name: "Composite",
        className: "SignaturesOverridesList",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SignaturesOverrides"
                        }
                    }
                }
            }
        }
    }
};
const IpAllocationListResult = {
    type: {
        name: "Composite",
        className: "IpAllocationListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "IpAllocation"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const IpGroupListResult = {
    type: {
        name: "Composite",
        className: "IpGroupListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "IpGroup"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const LoadBalancerSku = {
    type: {
        name: "Composite",
        className: "LoadBalancerSku",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            tier: {
                serializedName: "tier",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const LoadBalancerListResult = {
    type: {
        name: "Composite",
        className: "LoadBalancerListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "LoadBalancer"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const LoadBalancerBackendAddressPoolListResult = {
    type: {
        name: "Composite",
        className: "LoadBalancerBackendAddressPoolListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "BackendAddressPool"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const LoadBalancerFrontendIPConfigurationListResult = {
    type: {
        name: "Composite",
        className: "LoadBalancerFrontendIPConfigurationListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "FrontendIPConfiguration"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const InboundNatRuleListResult = {
    type: {
        name: "Composite",
        className: "InboundNatRuleListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "InboundNatRule"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const LoadBalancerLoadBalancingRuleListResult = {
    type: {
        name: "Composite",
        className: "LoadBalancerLoadBalancingRuleListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "LoadBalancingRule"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const LoadBalancerOutboundRuleListResult = {
    type: {
        name: "Composite",
        className: "LoadBalancerOutboundRuleListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "OutboundRule"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const LoadBalancerProbeListResult = {
    type: {
        name: "Composite",
        className: "LoadBalancerProbeListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Probe"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const LoadBalancerVipSwapRequest = {
    type: {
        name: "Composite",
        className: "LoadBalancerVipSwapRequest",
        modelProperties: {
            frontendIPConfigurations: {
                serializedName: "frontendIPConfigurations",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "LoadBalancerVipSwapRequestFrontendIPConfiguration"
                        }
                    }
                }
            }
        }
    }
};
const LoadBalancerVipSwapRequestFrontendIPConfiguration = {
    type: {
        name: "Composite",
        className: "LoadBalancerVipSwapRequestFrontendIPConfiguration",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            publicIPAddress: {
                serializedName: "properties.publicIPAddress",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }
        }
    }
};
const QueryInboundNatRulePortMappingRequest = {
    type: {
        name: "Composite",
        className: "QueryInboundNatRulePortMappingRequest",
        modelProperties: {
            ipConfiguration: {
                serializedName: "ipConfiguration",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            },
            ipAddress: {
                serializedName: "ipAddress",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const BackendAddressInboundNatRulePortMappings = {
    type: {
        name: "Composite",
        className: "BackendAddressInboundNatRulePortMappings",
        modelProperties: {
            inboundNatRulePortMappings: {
                serializedName: "inboundNatRulePortMappings",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "InboundNatRulePortMapping"
                        }
                    }
                }
            }
        }
    }
};
const InboundNatRulePortMapping = {
    type: {
        name: "Composite",
        className: "InboundNatRulePortMapping",
        modelProperties: {
            inboundNatRuleName: {
                serializedName: "inboundNatRuleName",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            protocol: {
                serializedName: "protocol",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            frontendPort: {
                serializedName: "frontendPort",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            backendPort: {
                serializedName: "backendPort",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const NatGatewayListResult = {
    type: {
        name: "Composite",
        className: "NatGatewayListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "NatGateway"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const EffectiveRouteListResult = {
    type: {
        name: "Composite",
        className: "EffectiveRouteListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "EffectiveRoute"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const EffectiveRoute = {
    type: {
        name: "Composite",
        className: "EffectiveRoute",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            disableBgpRoutePropagation: {
                serializedName: "disableBgpRoutePropagation",
                type: {
                    name: "Boolean"
                }
            },
            source: {
                serializedName: "source",
                type: {
                    name: "String"
                }
            },
            state: {
                serializedName: "state",
                type: {
                    name: "String"
                }
            },
            addressPrefix: {
                serializedName: "addressPrefix",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            nextHopIpAddress: {
                serializedName: "nextHopIpAddress",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            nextHopType: {
                serializedName: "nextHopType",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const EffectiveNetworkSecurityGroupListResult = {
    type: {
        name: "Composite",
        className: "EffectiveNetworkSecurityGroupListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "EffectiveNetworkSecurityGroup"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const EffectiveNetworkSecurityGroup = {
    type: {
        name: "Composite",
        className: "EffectiveNetworkSecurityGroup",
        modelProperties: {
            networkSecurityGroup: {
                serializedName: "networkSecurityGroup",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            },
            association: {
                serializedName: "association",
                type: {
                    name: "Composite",
                    className: "EffectiveNetworkSecurityGroupAssociation"
                }
            },
            effectiveSecurityRules: {
                serializedName: "effectiveSecurityRules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "EffectiveNetworkSecurityRule"
                        }
                    }
                }
            },
            tagMap: {
                serializedName: "tagMap",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const EffectiveNetworkSecurityGroupAssociation = {
    type: {
        name: "Composite",
        className: "EffectiveNetworkSecurityGroupAssociation",
        modelProperties: {
            networkManager: {
                serializedName: "networkManager",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            },
            subnet: {
                serializedName: "subnet",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            },
            networkInterface: {
                serializedName: "networkInterface",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }
        }
    }
};
const EffectiveNetworkSecurityRule = {
    type: {
        name: "Composite",
        className: "EffectiveNetworkSecurityRule",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            protocol: {
                serializedName: "protocol",
                type: {
                    name: "String"
                }
            },
            sourcePortRange: {
                serializedName: "sourcePortRange",
                type: {
                    name: "String"
                }
            },
            destinationPortRange: {
                serializedName: "destinationPortRange",
                type: {
                    name: "String"
                }
            },
            sourcePortRanges: {
                serializedName: "sourcePortRanges",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            destinationPortRanges: {
                serializedName: "destinationPortRanges",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            sourceAddressPrefix: {
                serializedName: "sourceAddressPrefix",
                type: {
                    name: "String"
                }
            },
            destinationAddressPrefix: {
                serializedName: "destinationAddressPrefix",
                type: {
                    name: "String"
                }
            },
            sourceAddressPrefixes: {
                serializedName: "sourceAddressPrefixes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            destinationAddressPrefixes: {
                serializedName: "destinationAddressPrefixes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            expandedSourceAddressPrefix: {
                serializedName: "expandedSourceAddressPrefix",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            expandedDestinationAddressPrefix: {
                serializedName: "expandedDestinationAddressPrefix",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            access: {
                serializedName: "access",
                type: {
                    name: "String"
                }
            },
            priority: {
                serializedName: "priority",
                type: {
                    name: "Number"
                }
            },
            direction: {
                serializedName: "direction",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const NetworkInterfaceIPConfigurationListResult = {
    type: {
        name: "Composite",
        className: "NetworkInterfaceIPConfigurationListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "NetworkInterfaceIPConfiguration"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const NetworkInterfaceLoadBalancerListResult = {
    type: {
        name: "Composite",
        className: "NetworkInterfaceLoadBalancerListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "LoadBalancer"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const NetworkInterfaceTapConfigurationListResult = {
    type: {
        name: "Composite",
        className: "NetworkInterfaceTapConfigurationListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "NetworkInterfaceTapConfiguration"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ContainerNetworkInterfaceIpConfiguration = {
    type: {
        name: "Composite",
        className: "ContainerNetworkInterfaceIpConfiguration",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const NetworkProfileListResult = {
    type: {
        name: "Composite",
        className: "NetworkProfileListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "NetworkProfile"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const NetworkSecurityGroupListResult = {
    type: {
        name: "Composite",
        className: "NetworkSecurityGroupListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "NetworkSecurityGroup"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SecurityRuleListResult = {
    type: {
        name: "Composite",
        className: "SecurityRuleListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SecurityRule"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VirtualApplianceSkuProperties = {
    type: {
        name: "Composite",
        className: "VirtualApplianceSkuProperties",
        modelProperties: {
            vendor: {
                serializedName: "vendor",
                type: {
                    name: "String"
                }
            },
            bundledScaleUnit: {
                serializedName: "bundledScaleUnit",
                type: {
                    name: "String"
                }
            },
            marketPlaceVersion: {
                serializedName: "marketPlaceVersion",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VirtualApplianceNicProperties = {
    type: {
        name: "Composite",
        className: "VirtualApplianceNicProperties",
        modelProperties: {
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            publicIpAddress: {
                serializedName: "publicIpAddress",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            privateIpAddress: {
                serializedName: "privateIpAddress",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const NetworkVirtualApplianceListResult = {
    type: {
        name: "Composite",
        className: "NetworkVirtualApplianceListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "NetworkVirtualAppliance"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Office365PolicyProperties = {
    type: {
        name: "Composite",
        className: "Office365PolicyProperties",
        modelProperties: {
            breakOutCategories: {
                serializedName: "breakOutCategories",
                type: {
                    name: "Composite",
                    className: "BreakOutCategoryPolicies"
                }
            }
        }
    }
};
const BreakOutCategoryPolicies = {
    type: {
        name: "Composite",
        className: "BreakOutCategoryPolicies",
        modelProperties: {
            allow: {
                serializedName: "allow",
                type: {
                    name: "Boolean"
                }
            },
            optimize: {
                serializedName: "optimize",
                type: {
                    name: "Boolean"
                }
            },
            default: {
                serializedName: "default",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const NetworkVirtualApplianceSiteListResult = {
    type: {
        name: "Composite",
        className: "NetworkVirtualApplianceSiteListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualApplianceSite"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const NetworkVirtualApplianceSkuListResult = {
    type: {
        name: "Composite",
        className: "NetworkVirtualApplianceSkuListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "NetworkVirtualApplianceSku"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const NetworkVirtualApplianceSkuInstances = {
    type: {
        name: "Composite",
        className: "NetworkVirtualApplianceSkuInstances",
        modelProperties: {
            scaleUnit: {
                serializedName: "scaleUnit",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            instanceCount: {
                serializedName: "instanceCount",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const InboundSecurityRules = {
    type: {
        name: "Composite",
        className: "InboundSecurityRules",
        modelProperties: {
            protocol: {
                serializedName: "protocol",
                type: {
                    name: "String"
                }
            },
            sourceAddressPrefix: {
                serializedName: "sourceAddressPrefix",
                type: {
                    name: "String"
                }
            },
            destinationPortRange: {
                constraints: {
                    InclusiveMaximum: 65535,
                    InclusiveMinimum: 0
                },
                serializedName: "destinationPortRange",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const ErrorResponse = {
    type: {
        name: "Composite",
        className: "ErrorResponse",
        modelProperties: {
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "ErrorDetails"
                }
            }
        }
    }
};
const NetworkWatcherListResult = {
    type: {
        name: "Composite",
        className: "NetworkWatcherListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "NetworkWatcher"
                        }
                    }
                }
            }
        }
    }
};
const TopologyParameters = {
    type: {
        name: "Composite",
        className: "TopologyParameters",
        modelProperties: {
            targetResourceGroupName: {
                serializedName: "targetResourceGroupName",
                type: {
                    name: "String"
                }
            },
            targetVirtualNetwork: {
                serializedName: "targetVirtualNetwork",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            },
            targetSubnet: {
                serializedName: "targetSubnet",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }
        }
    }
};
const Topology = {
    type: {
        name: "Composite",
        className: "Topology",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            createdDateTime: {
                serializedName: "createdDateTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            lastModified: {
                serializedName: "lastModified",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            resources: {
                serializedName: "resources",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TopologyResource"
                        }
                    }
                }
            }
        }
    }
};
const TopologyResource = {
    type: {
        name: "Composite",
        className: "TopologyResource",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            associations: {
                serializedName: "associations",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TopologyAssociation"
                        }
                    }
                }
            }
        }
    }
};
const TopologyAssociation = {
    type: {
        name: "Composite",
        className: "TopologyAssociation",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            resourceId: {
                serializedName: "resourceId",
                type: {
                    name: "String"
                }
            },
            associationType: {
                serializedName: "associationType",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VerificationIPFlowParameters = {
    type: {
        name: "Composite",
        className: "VerificationIPFlowParameters",
        modelProperties: {
            targetResourceId: {
                serializedName: "targetResourceId",
                required: true,
                type: {
                    name: "String"
                }
            },
            direction: {
                serializedName: "direction",
                required: true,
                type: {
                    name: "String"
                }
            },
            protocol: {
                serializedName: "protocol",
                required: true,
                type: {
                    name: "String"
                }
            },
            localPort: {
                serializedName: "localPort",
                required: true,
                type: {
                    name: "String"
                }
            },
            remotePort: {
                serializedName: "remotePort",
                required: true,
                type: {
                    name: "String"
                }
            },
            localIPAddress: {
                serializedName: "localIPAddress",
                required: true,
                type: {
                    name: "String"
                }
            },
            remoteIPAddress: {
                serializedName: "remoteIPAddress",
                required: true,
                type: {
                    name: "String"
                }
            },
            targetNicResourceId: {
                serializedName: "targetNicResourceId",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VerificationIPFlowResult = {
    type: {
        name: "Composite",
        className: "VerificationIPFlowResult",
        modelProperties: {
            access: {
                serializedName: "access",
                type: {
                    name: "String"
                }
            },
            ruleName: {
                serializedName: "ruleName",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const NextHopParameters = {
    type: {
        name: "Composite",
        className: "NextHopParameters",
        modelProperties: {
            targetResourceId: {
                serializedName: "targetResourceId",
                required: true,
                type: {
                    name: "String"
                }
            },
            sourceIPAddress: {
                serializedName: "sourceIPAddress",
                required: true,
                type: {
                    name: "String"
                }
            },
            destinationIPAddress: {
                serializedName: "destinationIPAddress",
                required: true,
                type: {
                    name: "String"
                }
            },
            targetNicResourceId: {
                serializedName: "targetNicResourceId",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const NextHopResult = {
    type: {
        name: "Composite",
        className: "NextHopResult",
        modelProperties: {
            nextHopType: {
                serializedName: "nextHopType",
                type: {
                    name: "String"
                }
            },
            nextHopIpAddress: {
                serializedName: "nextHopIpAddress",
                type: {
                    name: "String"
                }
            },
            routeTableId: {
                serializedName: "routeTableId",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SecurityGroupViewParameters = {
    type: {
        name: "Composite",
        className: "SecurityGroupViewParameters",
        modelProperties: {
            targetResourceId: {
                serializedName: "targetResourceId",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SecurityGroupViewResult = {
    type: {
        name: "Composite",
        className: "SecurityGroupViewResult",
        modelProperties: {
            networkInterfaces: {
                serializedName: "networkInterfaces",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SecurityGroupNetworkInterface"
                        }
                    }
                }
            }
        }
    }
};
const SecurityGroupNetworkInterface = {
    type: {
        name: "Composite",
        className: "SecurityGroupNetworkInterface",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            securityRuleAssociations: {
                serializedName: "securityRuleAssociations",
                type: {
                    name: "Composite",
                    className: "SecurityRuleAssociations"
                }
            }
        }
    }
};
const SecurityRuleAssociations = {
    type: {
        name: "Composite",
        className: "SecurityRuleAssociations",
        modelProperties: {
            networkInterfaceAssociation: {
                serializedName: "networkInterfaceAssociation",
                type: {
                    name: "Composite",
                    className: "NetworkInterfaceAssociation"
                }
            },
            subnetAssociation: {
                serializedName: "subnetAssociation",
                type: {
                    name: "Composite",
                    className: "SubnetAssociation"
                }
            },
            defaultSecurityRules: {
                serializedName: "defaultSecurityRules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SecurityRule"
                        }
                    }
                }
            },
            effectiveSecurityRules: {
                serializedName: "effectiveSecurityRules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "EffectiveNetworkSecurityRule"
                        }
                    }
                }
            }
        }
    }
};
const NetworkInterfaceAssociation = {
    type: {
        name: "Composite",
        className: "NetworkInterfaceAssociation",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            securityRules: {
                serializedName: "securityRules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SecurityRule"
                        }
                    }
                }
            }
        }
    }
};
const SubnetAssociation = {
    type: {
        name: "Composite",
        className: "SubnetAssociation",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            securityRules: {
                serializedName: "securityRules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SecurityRule"
                        }
                    }
                }
            }
        }
    }
};
const PacketCapture = {
    type: {
        name: "Composite",
        className: "PacketCapture",
        modelProperties: {
            target: {
                serializedName: "properties.target",
                required: true,
                type: {
                    name: "String"
                }
            },
            bytesToCapturePerPacket: {
                defaultValue: 0,
                constraints: {
                    InclusiveMaximum: 4294967295,
                    InclusiveMinimum: 0
                },
                serializedName: "properties.bytesToCapturePerPacket",
                type: {
                    name: "Number"
                }
            },
            totalBytesPerSession: {
                defaultValue: 1073741824,
                constraints: {
                    InclusiveMaximum: 4294967295,
                    InclusiveMinimum: 0
                },
                serializedName: "properties.totalBytesPerSession",
                type: {
                    name: "Number"
                }
            },
            timeLimitInSeconds: {
                defaultValue: 18000,
                constraints: {
                    InclusiveMaximum: 18000,
                    InclusiveMinimum: 0
                },
                serializedName: "properties.timeLimitInSeconds",
                type: {
                    name: "Number"
                }
            },
            storageLocation: {
                serializedName: "properties.storageLocation",
                type: {
                    name: "Composite",
                    className: "PacketCaptureStorageLocation"
                }
            },
            filters: {
                serializedName: "properties.filters",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PacketCaptureFilter"
                        }
                    }
                }
            }
        }
    }
};
const PacketCaptureParameters = {
    type: {
        name: "Composite",
        className: "PacketCaptureParameters",
        modelProperties: {
            target: {
                serializedName: "target",
                required: true,
                type: {
                    name: "String"
                }
            },
            bytesToCapturePerPacket: {
                defaultValue: 0,
                constraints: {
                    InclusiveMaximum: 4294967295,
                    InclusiveMinimum: 0
                },
                serializedName: "bytesToCapturePerPacket",
                type: {
                    name: "Number"
                }
            },
            totalBytesPerSession: {
                defaultValue: 1073741824,
                constraints: {
                    InclusiveMaximum: 4294967295,
                    InclusiveMinimum: 0
                },
                serializedName: "totalBytesPerSession",
                type: {
                    name: "Number"
                }
            },
            timeLimitInSeconds: {
                defaultValue: 18000,
                constraints: {
                    InclusiveMaximum: 18000,
                    InclusiveMinimum: 0
                },
                serializedName: "timeLimitInSeconds",
                type: {
                    name: "Number"
                }
            },
            storageLocation: {
                serializedName: "storageLocation",
                type: {
                    name: "Composite",
                    className: "PacketCaptureStorageLocation"
                }
            },
            filters: {
                serializedName: "filters",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PacketCaptureFilter"
                        }
                    }
                }
            }
        }
    }
};
const PacketCaptureStorageLocation = {
    type: {
        name: "Composite",
        className: "PacketCaptureStorageLocation",
        modelProperties: {
            storageId: {
                serializedName: "storageId",
                type: {
                    name: "String"
                }
            },
            storagePath: {
                serializedName: "storagePath",
                type: {
                    name: "String"
                }
            },
            filePath: {
                serializedName: "filePath",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PacketCaptureFilter = {
    type: {
        name: "Composite",
        className: "PacketCaptureFilter",
        modelProperties: {
            protocol: {
                defaultValue: "Any",
                serializedName: "protocol",
                type: {
                    name: "String"
                }
            },
            localIPAddress: {
                serializedName: "localIPAddress",
                type: {
                    name: "String"
                }
            },
            remoteIPAddress: {
                serializedName: "remoteIPAddress",
                type: {
                    name: "String"
                }
            },
            localPort: {
                serializedName: "localPort",
                type: {
                    name: "String"
                }
            },
            remotePort: {
                serializedName: "remotePort",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PacketCaptureResult = {
    type: {
        name: "Composite",
        className: "PacketCaptureResult",
        modelProperties: {
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            target: {
                serializedName: "properties.target",
                type: {
                    name: "String"
                }
            },
            bytesToCapturePerPacket: {
                defaultValue: 0,
                constraints: {
                    InclusiveMaximum: 4294967295,
                    InclusiveMinimum: 0
                },
                serializedName: "properties.bytesToCapturePerPacket",
                type: {
                    name: "Number"
                }
            },
            totalBytesPerSession: {
                defaultValue: 1073741824,
                constraints: {
                    InclusiveMaximum: 4294967295,
                    InclusiveMinimum: 0
                },
                serializedName: "properties.totalBytesPerSession",
                type: {
                    name: "Number"
                }
            },
            timeLimitInSeconds: {
                defaultValue: 18000,
                constraints: {
                    InclusiveMaximum: 18000,
                    InclusiveMinimum: 0
                },
                serializedName: "properties.timeLimitInSeconds",
                type: {
                    name: "Number"
                }
            },
            storageLocation: {
                serializedName: "properties.storageLocation",
                type: {
                    name: "Composite",
                    className: "PacketCaptureStorageLocation"
                }
            },
            filters: {
                serializedName: "properties.filters",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PacketCaptureFilter"
                        }
                    }
                }
            },
            provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PacketCaptureQueryStatusResult = {
    type: {
        name: "Composite",
        className: "PacketCaptureQueryStatusResult",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            captureStartTime: {
                serializedName: "captureStartTime",
                type: {
                    name: "DateTime"
                }
            },
            packetCaptureStatus: {
                serializedName: "packetCaptureStatus",
                type: {
                    name: "String"
                }
            },
            stopReason: {
                serializedName: "stopReason",
                type: {
                    name: "String"
                }
            },
            packetCaptureError: {
                serializedName: "packetCaptureError",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const PacketCaptureListResult = {
    type: {
        name: "Composite",
        className: "PacketCaptureListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PacketCaptureResult"
                        }
                    }
                }
            }
        }
    }
};
const TroubleshootingParameters = {
    type: {
        name: "Composite",
        className: "TroubleshootingParameters",
        modelProperties: {
            targetResourceId: {
                serializedName: "targetResourceId",
                required: true,
                type: {
                    name: "String"
                }
            },
            storageId: {
                serializedName: "properties.storageId",
                required: true,
                type: {
                    name: "String"
                }
            },
            storagePath: {
                serializedName: "properties.storagePath",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TroubleshootingResult = {
    type: {
        name: "Composite",
        className: "TroubleshootingResult",
        modelProperties: {
            startTime: {
                serializedName: "startTime",
                type: {
                    name: "DateTime"
                }
            },
            endTime: {
                serializedName: "endTime",
                type: {
                    name: "DateTime"
                }
            },
            code: {
                serializedName: "code",
                type: {
                    name: "String"
                }
            },
            results: {
                serializedName: "results",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TroubleshootingDetails"
                        }
                    }
                }
            }
        }
    }
};
const TroubleshootingDetails = {
    type: {
        name: "Composite",
        className: "TroubleshootingDetails",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            reasonType: {
                serializedName: "reasonType",
                type: {
                    name: "String"
                }
            },
            summary: {
                serializedName: "summary",
                type: {
                    name: "String"
                }
            },
            detail: {
                serializedName: "detail",
                type: {
                    name: "String"
                }
            },
            recommendedActions: {
                serializedName: "recommendedActions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TroubleshootingRecommendedActions"
                        }
                    }
                }
            }
        }
    }
};
const TroubleshootingRecommendedActions = {
    type: {
        name: "Composite",
        className: "TroubleshootingRecommendedActions",
        modelProperties: {
            actionId: {
                serializedName: "actionId",
                type: {
                    name: "String"
                }
            },
            actionText: {
                serializedName: "actionText",
                type: {
                    name: "String"
                }
            },
            actionUri: {
                serializedName: "actionUri",
                type: {
                    name: "String"
                }
            },
            actionUriText: {
                serializedName: "actionUriText",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const QueryTroubleshootingParameters = {
    type: {
        name: "Composite",
        className: "QueryTroubleshootingParameters",
        modelProperties: {
            targetResourceId: {
                serializedName: "targetResourceId",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const FlowLogInformation = {
    type: {
        name: "Composite",
        className: "FlowLogInformation",
        modelProperties: {
            targetResourceId: {
                serializedName: "targetResourceId",
                required: true,
                type: {
                    name: "String"
                }
            },
            flowAnalyticsConfiguration: {
                serializedName: "flowAnalyticsConfiguration",
                type: {
                    name: "Composite",
                    className: "TrafficAnalyticsProperties"
                }
            },
            storageId: {
                serializedName: "properties.storageId",
                required: true,
                type: {
                    name: "String"
                }
            },
            enabled: {
                serializedName: "properties.enabled",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            retentionPolicy: {
                serializedName: "properties.retentionPolicy",
                type: {
                    name: "Composite",
                    className: "RetentionPolicyParameters"
                }
            },
            format: {
                serializedName: "properties.format",
                type: {
                    name: "Composite",
                    className: "FlowLogFormatParameters"
                }
            }
        }
    }
};
const FlowLogStatusParameters = {
    type: {
        name: "Composite",
        className: "FlowLogStatusParameters",
        modelProperties: {
            targetResourceId: {
                serializedName: "targetResourceId",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ConnectivityParameters = {
    type: {
        name: "Composite",
        className: "ConnectivityParameters",
        modelProperties: {
            source: {
                serializedName: "source",
                type: {
                    name: "Composite",
                    className: "ConnectivitySource"
                }
            },
            destination: {
                serializedName: "destination",
                type: {
                    name: "Composite",
                    className: "ConnectivityDestination"
                }
            },
            protocol: {
                serializedName: "protocol",
                type: {
                    name: "String"
                }
            },
            protocolConfiguration: {
                serializedName: "protocolConfiguration",
                type: {
                    name: "Composite",
                    className: "ProtocolConfiguration"
                }
            },
            preferredIPVersion: {
                serializedName: "preferredIPVersion",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ConnectivitySource = {
    type: {
        name: "Composite",
        className: "ConnectivitySource",
        modelProperties: {
            resourceId: {
                serializedName: "resourceId",
                required: true,
                type: {
                    name: "String"
                }
            },
            port: {
                constraints: {
                    InclusiveMaximum: 65535,
                    InclusiveMinimum: 0
                },
                serializedName: "port",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const ConnectivityDestination = {
    type: {
        name: "Composite",
        className: "ConnectivityDestination",
        modelProperties: {
            resourceId: {
                serializedName: "resourceId",
                type: {
                    name: "String"
                }
            },
            address: {
                serializedName: "address",
                type: {
                    name: "String"
                }
            },
            port: {
                constraints: {
                    InclusiveMaximum: 65535,
                    InclusiveMinimum: 0
                },
                serializedName: "port",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const ProtocolConfiguration = {
    type: {
        name: "Composite",
        className: "ProtocolConfiguration",
        modelProperties: {
            httpConfiguration: {
                serializedName: "HTTPConfiguration",
                type: {
                    name: "Composite",
                    className: "HttpConfiguration"
                }
            }
        }
    }
};
const HttpConfiguration = {
    type: {
        name: "Composite",
        className: "HttpConfiguration",
        modelProperties: {
            method: {
                serializedName: "method",
                type: {
                    name: "String"
                }
            },
            headers: {
                serializedName: "headers",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "HttpHeader"
                        }
                    }
                }
            },
            validStatusCodes: {
                serializedName: "validStatusCodes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Number"
                        }
                    }
                }
            }
        }
    }
};
const HttpHeader = {
    type: {
        name: "Composite",
        className: "HttpHeader",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ConnectivityInformation = {
    type: {
        name: "Composite",
        className: "ConnectivityInformation",
        modelProperties: {
            hops: {
                serializedName: "hops",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ConnectivityHop"
                        }
                    }
                }
            },
            connectionStatus: {
                serializedName: "connectionStatus",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            avgLatencyInMs: {
                serializedName: "avgLatencyInMs",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            minLatencyInMs: {
                serializedName: "minLatencyInMs",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            maxLatencyInMs: {
                serializedName: "maxLatencyInMs",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            probesSent: {
                serializedName: "probesSent",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            probesFailed: {
                serializedName: "probesFailed",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const ConnectivityHop = {
    type: {
        name: "Composite",
        className: "ConnectivityHop",
        modelProperties: {
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            address: {
                serializedName: "address",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            resourceId: {
                serializedName: "resourceId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            nextHopIds: {
                serializedName: "nextHopIds",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            previousHopIds: {
                serializedName: "previousHopIds",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            links: {
                serializedName: "links",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "HopLink"
                        }
                    }
                }
            },
            previousLinks: {
                serializedName: "previousLinks",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "HopLink"
                        }
                    }
                }
            },
            issues: {
                serializedName: "issues",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ConnectivityIssue"
                        }
                    }
                }
            }
        }
    }
};
const HopLink = {
    type: {
        name: "Composite",
        className: "HopLink",
        modelProperties: {
            nextHopId: {
                serializedName: "nextHopId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            linkType: {
                serializedName: "linkType",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            issues: {
                serializedName: "issues",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ConnectivityIssue"
                        }
                    }
                }
            },
            context: {
                serializedName: "context",
                readOnly: true,
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            resourceId: {
                serializedName: "resourceId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            roundTripTimeMin: {
                constraints: {
                    InclusiveMaximum: 4294967295,
                    InclusiveMinimum: 0
                },
                serializedName: "properties.roundTripTimeMin",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            roundTripTimeAvg: {
                constraints: {
                    InclusiveMaximum: 4294967295,
                    InclusiveMinimum: 0
                },
                serializedName: "properties.roundTripTimeAvg",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            roundTripTimeMax: {
                constraints: {
                    InclusiveMaximum: 4294967295,
                    InclusiveMinimum: 0
                },
                serializedName: "properties.roundTripTimeMax",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const ConnectivityIssue = {
    type: {
        name: "Composite",
        className: "ConnectivityIssue",
        modelProperties: {
            origin: {
                serializedName: "origin",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            severity: {
                serializedName: "severity",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            context: {
                serializedName: "context",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Dictionary",
                            value: { type: { name: "String" } }
                        }
                    }
                }
            }
        }
    }
};
const AzureReachabilityReportParameters = {
    type: {
        name: "Composite",
        className: "AzureReachabilityReportParameters",
        modelProperties: {
            providerLocation: {
                serializedName: "providerLocation",
                type: {
                    name: "Composite",
                    className: "AzureReachabilityReportLocation"
                }
            },
            providers: {
                serializedName: "providers",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            azureLocations: {
                serializedName: "azureLocations",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            startTime: {
                serializedName: "startTime",
                required: true,
                type: {
                    name: "DateTime"
                }
            },
            endTime: {
                serializedName: "endTime",
                required: true,
                type: {
                    name: "DateTime"
                }
            }
        }
    }
};
const AzureReachabilityReportLocation = {
    type: {
        name: "Composite",
        className: "AzureReachabilityReportLocation",
        modelProperties: {
            country: {
                serializedName: "country",
                required: true,
                type: {
                    name: "String"
                }
            },
            state: {
                serializedName: "state",
                type: {
                    name: "String"
                }
            },
            city: {
                serializedName: "city",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AzureReachabilityReport = {
    type: {
        name: "Composite",
        className: "AzureReachabilityReport",
        modelProperties: {
            aggregationLevel: {
                serializedName: "aggregationLevel",
                required: true,
                type: {
                    name: "String"
                }
            },
            providerLocation: {
                serializedName: "providerLocation",
                type: {
                    name: "Composite",
                    className: "AzureReachabilityReportLocation"
                }
            },
            reachabilityReport: {
                serializedName: "reachabilityReport",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AzureReachabilityReportItem"
                        }
                    }
                }
            }
        }
    }
};
const AzureReachabilityReportItem = {
    type: {
        name: "Composite",
        className: "AzureReachabilityReportItem",
        modelProperties: {
            provider: {
                serializedName: "provider",
                type: {
                    name: "String"
                }
            },
            azureLocation: {
                serializedName: "azureLocation",
                type: {
                    name: "String"
                }
            },
            latencies: {
                serializedName: "latencies",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AzureReachabilityReportLatencyInfo"
                        }
                    }
                }
            }
        }
    }
};
const AzureReachabilityReportLatencyInfo = {
    type: {
        name: "Composite",
        className: "AzureReachabilityReportLatencyInfo",
        modelProperties: {
            timeStamp: {
                serializedName: "timeStamp",
                type: {
                    name: "DateTime"
                }
            },
            score: {
                constraints: {
                    InclusiveMaximum: 100,
                    InclusiveMinimum: 1
                },
                serializedName: "score",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const AvailableProvidersListParameters = {
    type: {
        name: "Composite",
        className: "AvailableProvidersListParameters",
        modelProperties: {
            azureLocations: {
                serializedName: "azureLocations",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            country: {
                serializedName: "country",
                type: {
                    name: "String"
                }
            },
            state: {
                serializedName: "state",
                type: {
                    name: "String"
                }
            },
            city: {
                serializedName: "city",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AvailableProvidersList = {
    type: {
        name: "Composite",
        className: "AvailableProvidersList",
        modelProperties: {
            countries: {
                serializedName: "countries",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AvailableProvidersListCountry"
                        }
                    }
                }
            }
        }
    }
};
const AvailableProvidersListCountry = {
    type: {
        name: "Composite",
        className: "AvailableProvidersListCountry",
        modelProperties: {
            countryName: {
                serializedName: "countryName",
                type: {
                    name: "String"
                }
            },
            providers: {
                serializedName: "providers",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            states: {
                serializedName: "states",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AvailableProvidersListState"
                        }
                    }
                }
            }
        }
    }
};
const AvailableProvidersListState = {
    type: {
        name: "Composite",
        className: "AvailableProvidersListState",
        modelProperties: {
            stateName: {
                serializedName: "stateName",
                type: {
                    name: "String"
                }
            },
            providers: {
                serializedName: "providers",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            cities: {
                serializedName: "cities",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AvailableProvidersListCity"
                        }
                    }
                }
            }
        }
    }
};
const AvailableProvidersListCity = {
    type: {
        name: "Composite",
        className: "AvailableProvidersListCity",
        modelProperties: {
            cityName: {
                serializedName: "cityName",
                type: {
                    name: "String"
                }
            },
            providers: {
                serializedName: "providers",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const NetworkConfigurationDiagnosticParameters = {
    type: {
        name: "Composite",
        className: "NetworkConfigurationDiagnosticParameters",
        modelProperties: {
            targetResourceId: {
                serializedName: "targetResourceId",
                required: true,
                type: {
                    name: "String"
                }
            },
            verbosityLevel: {
                serializedName: "verbosityLevel",
                type: {
                    name: "String"
                }
            },
            profiles: {
                serializedName: "profiles",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "NetworkConfigurationDiagnosticProfile"
                        }
                    }
                }
            }
        }
    }
};
const NetworkConfigurationDiagnosticProfile = {
    type: {
        name: "Composite",
        className: "NetworkConfigurationDiagnosticProfile",
        modelProperties: {
            direction: {
                serializedName: "direction",
                required: true,
                type: {
                    name: "String"
                }
            },
            protocol: {
                serializedName: "protocol",
                required: true,
                type: {
                    name: "String"
                }
            },
            source: {
                serializedName: "source",
                required: true,
                type: {
                    name: "String"
                }
            },
            destination: {
                serializedName: "destination",
                required: true,
                type: {
                    name: "String"
                }
            },
            destinationPort: {
                serializedName: "destinationPort",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const NetworkConfigurationDiagnosticResponse = {
    type: {
        name: "Composite",
        className: "NetworkConfigurationDiagnosticResponse",
        modelProperties: {
            results: {
                serializedName: "results",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "NetworkConfigurationDiagnosticResult"
                        }
                    }
                }
            }
        }
    }
};
const NetworkConfigurationDiagnosticResult = {
    type: {
        name: "Composite",
        className: "NetworkConfigurationDiagnosticResult",
        modelProperties: {
            profile: {
                serializedName: "profile",
                type: {
                    name: "Composite",
                    className: "NetworkConfigurationDiagnosticProfile"
                }
            },
            networkSecurityGroupResult: {
                serializedName: "networkSecurityGroupResult",
                type: {
                    name: "Composite",
                    className: "NetworkSecurityGroupResult"
                }
            }
        }
    }
};
const NetworkSecurityGroupResult = {
    type: {
        name: "Composite",
        className: "NetworkSecurityGroupResult",
        modelProperties: {
            securityRuleAccessResult: {
                serializedName: "securityRuleAccessResult",
                type: {
                    name: "String"
                }
            },
            evaluatedNetworkSecurityGroups: {
                serializedName: "evaluatedNetworkSecurityGroups",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "EvaluatedNetworkSecurityGroup"
                        }
                    }
                }
            }
        }
    }
};
const EvaluatedNetworkSecurityGroup = {
    type: {
        name: "Composite",
        className: "EvaluatedNetworkSecurityGroup",
        modelProperties: {
            networkSecurityGroupId: {
                serializedName: "networkSecurityGroupId",
                type: {
                    name: "String"
                }
            },
            appliedTo: {
                serializedName: "appliedTo",
                type: {
                    name: "String"
                }
            },
            matchedRule: {
                serializedName: "matchedRule",
                type: {
                    name: "Composite",
                    className: "MatchedRule"
                }
            },
            rulesEvaluationResult: {
                serializedName: "rulesEvaluationResult",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "NetworkSecurityRulesEvaluationResult"
                        }
                    }
                }
            }
        }
    }
};
const MatchedRule = {
    type: {
        name: "Composite",
        className: "MatchedRule",
        modelProperties: {
            ruleName: {
                serializedName: "ruleName",
                type: {
                    name: "String"
                }
            },
            action: {
                serializedName: "action",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const NetworkSecurityRulesEvaluationResult = {
    type: {
        name: "Composite",
        className: "NetworkSecurityRulesEvaluationResult",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            protocolMatched: {
                serializedName: "protocolMatched",
                type: {
                    name: "Boolean"
                }
            },
            sourceMatched: {
                serializedName: "sourceMatched",
                type: {
                    name: "Boolean"
                }
            },
            sourcePortMatched: {
                serializedName: "sourcePortMatched",
                type: {
                    name: "Boolean"
                }
            },
            destinationMatched: {
                serializedName: "destinationMatched",
                type: {
                    name: "Boolean"
                }
            },
            destinationPortMatched: {
                serializedName: "destinationPortMatched",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const ConnectionMonitor = {
    type: {
        name: "Composite",
        className: "ConnectionMonitor",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            source: {
                serializedName: "properties.source",
                type: {
                    name: "Composite",
                    className: "ConnectionMonitorSource"
                }
            },
            destination: {
                serializedName: "properties.destination",
                type: {
                    name: "Composite",
                    className: "ConnectionMonitorDestination"
                }
            },
            autoStart: {
                defaultValue: true,
                serializedName: "properties.autoStart",
                type: {
                    name: "Boolean"
                }
            },
            monitoringIntervalInSeconds: {
                defaultValue: 60,
                constraints: {
                    InclusiveMaximum: 1800,
                    InclusiveMinimum: 30
                },
                serializedName: "properties.monitoringIntervalInSeconds",
                type: {
                    name: "Number"
                }
            },
            endpoints: {
                serializedName: "properties.endpoints",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ConnectionMonitorEndpoint"
                        }
                    }
                }
            },
            testConfigurations: {
                serializedName: "properties.testConfigurations",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ConnectionMonitorTestConfiguration"
                        }
                    }
                }
            },
            testGroups: {
                serializedName: "properties.testGroups",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ConnectionMonitorTestGroup"
                        }
                    }
                }
            },
            outputs: {
                serializedName: "properties.outputs",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ConnectionMonitorOutput"
                        }
                    }
                }
            },
            notes: {
                serializedName: "properties.notes",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ConnectionMonitorParameters = {
    type: {
        name: "Composite",
        className: "ConnectionMonitorParameters",
        modelProperties: {
            source: {
                serializedName: "source",
                type: {
                    name: "Composite",
                    className: "ConnectionMonitorSource"
                }
            },
            destination: {
                serializedName: "destination",
                type: {
                    name: "Composite",
                    className: "ConnectionMonitorDestination"
                }
            },
            autoStart: {
                defaultValue: true,
                serializedName: "autoStart",
                type: {
                    name: "Boolean"
                }
            },
            monitoringIntervalInSeconds: {
                defaultValue: 60,
                constraints: {
                    InclusiveMaximum: 1800,
                    InclusiveMinimum: 30
                },
                serializedName: "monitoringIntervalInSeconds",
                type: {
                    name: "Number"
                }
            },
            endpoints: {
                serializedName: "endpoints",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ConnectionMonitorEndpoint"
                        }
                    }
                }
            },
            testConfigurations: {
                serializedName: "testConfigurations",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ConnectionMonitorTestConfiguration"
                        }
                    }
                }
            },
            testGroups: {
                serializedName: "testGroups",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ConnectionMonitorTestGroup"
                        }
                    }
                }
            },
            outputs: {
                serializedName: "outputs",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ConnectionMonitorOutput"
                        }
                    }
                }
            },
            notes: {
                serializedName: "notes",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ConnectionMonitorSource = {
    type: {
        name: "Composite",
        className: "ConnectionMonitorSource",
        modelProperties: {
            resourceId: {
                serializedName: "resourceId",
                required: true,
                type: {
                    name: "String"
                }
            },
            port: {
                constraints: {
                    InclusiveMaximum: 65535,
                    InclusiveMinimum: 0
                },
                serializedName: "port",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const ConnectionMonitorDestination = {
    type: {
        name: "Composite",
        className: "ConnectionMonitorDestination",
        modelProperties: {
            resourceId: {
                serializedName: "resourceId",
                type: {
                    name: "String"
                }
            },
            address: {
                serializedName: "address",
                type: {
                    name: "String"
                }
            },
            port: {
                constraints: {
                    InclusiveMaximum: 65535,
                    InclusiveMinimum: 0
                },
                serializedName: "port",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const ConnectionMonitorEndpoint = {
    type: {
        name: "Composite",
        className: "ConnectionMonitorEndpoint",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            },
            resourceId: {
                serializedName: "resourceId",
                type: {
                    name: "String"
                }
            },
            address: {
                serializedName: "address",
                type: {
                    name: "String"
                }
            },
            filter: {
                serializedName: "filter",
                type: {
                    name: "Composite",
                    className: "ConnectionMonitorEndpointFilter"
                }
            },
            scope: {
                serializedName: "scope",
                type: {
                    name: "Composite",
                    className: "ConnectionMonitorEndpointScope"
                }
            },
            coverageLevel: {
                serializedName: "coverageLevel",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ConnectionMonitorEndpointFilter = {
    type: {
        name: "Composite",
        className: "ConnectionMonitorEndpointFilter",
        modelProperties: {
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            },
            items: {
                serializedName: "items",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ConnectionMonitorEndpointFilterItem"
                        }
                    }
                }
            }
        }
    }
};
const ConnectionMonitorEndpointFilterItem = {
    type: {
        name: "Composite",
        className: "ConnectionMonitorEndpointFilterItem",
        modelProperties: {
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            },
            address: {
                serializedName: "address",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ConnectionMonitorEndpointScope = {
    type: {
        name: "Composite",
        className: "ConnectionMonitorEndpointScope",
        modelProperties: {
            include: {
                serializedName: "include",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ConnectionMonitorEndpointScopeItem"
                        }
                    }
                }
            },
            exclude: {
                serializedName: "exclude",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ConnectionMonitorEndpointScopeItem"
                        }
                    }
                }
            }
        }
    }
};
const ConnectionMonitorEndpointScopeItem = {
    type: {
        name: "Composite",
        className: "ConnectionMonitorEndpointScopeItem",
        modelProperties: {
            address: {
                serializedName: "address",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ConnectionMonitorTestConfiguration = {
    type: {
        name: "Composite",
        className: "ConnectionMonitorTestConfiguration",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            testFrequencySec: {
                serializedName: "testFrequencySec",
                type: {
                    name: "Number"
                }
            },
            protocol: {
                serializedName: "protocol",
                required: true,
                type: {
                    name: "String"
                }
            },
            preferredIPVersion: {
                serializedName: "preferredIPVersion",
                type: {
                    name: "String"
                }
            },
            httpConfiguration: {
                serializedName: "httpConfiguration",
                type: {
                    name: "Composite",
                    className: "ConnectionMonitorHttpConfiguration"
                }
            },
            tcpConfiguration: {
                serializedName: "tcpConfiguration",
                type: {
                    name: "Composite",
                    className: "ConnectionMonitorTcpConfiguration"
                }
            },
            icmpConfiguration: {
                serializedName: "icmpConfiguration",
                type: {
                    name: "Composite",
                    className: "ConnectionMonitorIcmpConfiguration"
                }
            },
            successThreshold: {
                serializedName: "successThreshold",
                type: {
                    name: "Composite",
                    className: "ConnectionMonitorSuccessThreshold"
                }
            }
        }
    }
};
const ConnectionMonitorHttpConfiguration = {
    type: {
        name: "Composite",
        className: "ConnectionMonitorHttpConfiguration",
        modelProperties: {
            port: {
                constraints: {
                    InclusiveMaximum: 65535,
                    InclusiveMinimum: 0
                },
                serializedName: "port",
                type: {
                    name: "Number"
                }
            },
            method: {
                serializedName: "method",
                type: {
                    name: "String"
                }
            },
            path: {
                serializedName: "path",
                type: {
                    name: "String"
                }
            },
            requestHeaders: {
                serializedName: "requestHeaders",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "HttpHeader"
                        }
                    }
                }
            },
            validStatusCodeRanges: {
                serializedName: "validStatusCodeRanges",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            preferHttps: {
                serializedName: "preferHTTPS",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const ConnectionMonitorTcpConfiguration = {
    type: {
        name: "Composite",
        className: "ConnectionMonitorTcpConfiguration",
        modelProperties: {
            port: {
                constraints: {
                    InclusiveMaximum: 65535,
                    InclusiveMinimum: 0
                },
                serializedName: "port",
                type: {
                    name: "Number"
                }
            },
            disableTraceRoute: {
                serializedName: "disableTraceRoute",
                type: {
                    name: "Boolean"
                }
            },
            destinationPortBehavior: {
                serializedName: "destinationPortBehavior",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ConnectionMonitorIcmpConfiguration = {
    type: {
        name: "Composite",
        className: "ConnectionMonitorIcmpConfiguration",
        modelProperties: {
            disableTraceRoute: {
                serializedName: "disableTraceRoute",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const ConnectionMonitorSuccessThreshold = {
    type: {
        name: "Composite",
        className: "ConnectionMonitorSuccessThreshold",
        modelProperties: {
            checksFailedPercent: {
                serializedName: "checksFailedPercent",
                type: {
                    name: "Number"
                }
            },
            roundTripTimeMs: {
                serializedName: "roundTripTimeMs",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const ConnectionMonitorTestGroup = {
    type: {
        name: "Composite",
        className: "ConnectionMonitorTestGroup",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            disable: {
                serializedName: "disable",
                type: {
                    name: "Boolean"
                }
            },
            testConfigurations: {
                serializedName: "testConfigurations",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            sources: {
                serializedName: "sources",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            destinations: {
                serializedName: "destinations",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const ConnectionMonitorOutput = {
    type: {
        name: "Composite",
        className: "ConnectionMonitorOutput",
        modelProperties: {
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            },
            workspaceSettings: {
                serializedName: "workspaceSettings",
                type: {
                    name: "Composite",
                    className: "ConnectionMonitorWorkspaceSettings"
                }
            }
        }
    }
};
const ConnectionMonitorWorkspaceSettings = {
    type: {
        name: "Composite",
        className: "ConnectionMonitorWorkspaceSettings",
        modelProperties: {
            workspaceResourceId: {
                serializedName: "workspaceResourceId",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ConnectionMonitorResult = {
    type: {
        name: "Composite",
        className: "ConnectionMonitorResult",
        modelProperties: {
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            source: {
                serializedName: "properties.source",
                type: {
                    name: "Composite",
                    className: "ConnectionMonitorSource"
                }
            },
            destination: {
                serializedName: "properties.destination",
                type: {
                    name: "Composite",
                    className: "ConnectionMonitorDestination"
                }
            },
            autoStart: {
                defaultValue: true,
                serializedName: "properties.autoStart",
                type: {
                    name: "Boolean"
                }
            },
            monitoringIntervalInSeconds: {
                defaultValue: 60,
                constraints: {
                    InclusiveMaximum: 1800,
                    InclusiveMinimum: 30
                },
                serializedName: "properties.monitoringIntervalInSeconds",
                type: {
                    name: "Number"
                }
            },
            endpoints: {
                serializedName: "properties.endpoints",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ConnectionMonitorEndpoint"
                        }
                    }
                }
            },
            testConfigurations: {
                serializedName: "properties.testConfigurations",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ConnectionMonitorTestConfiguration"
                        }
                    }
                }
            },
            testGroups: {
                serializedName: "properties.testGroups",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ConnectionMonitorTestGroup"
                        }
                    }
                }
            },
            outputs: {
                serializedName: "properties.outputs",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ConnectionMonitorOutput"
                        }
                    }
                }
            },
            notes: {
                serializedName: "properties.notes",
                type: {
                    name: "String"
                }
            },
            provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            startTime: {
                serializedName: "properties.startTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            monitoringStatus: {
                serializedName: "properties.monitoringStatus",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            connectionMonitorType: {
                serializedName: "properties.connectionMonitorType",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ConnectionMonitorQueryResult = {
    type: {
        name: "Composite",
        className: "ConnectionMonitorQueryResult",
        modelProperties: {
            sourceStatus: {
                serializedName: "sourceStatus",
                type: {
                    name: "String"
                }
            },
            states: {
                serializedName: "states",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ConnectionStateSnapshot"
                        }
                    }
                }
            }
        }
    }
};
const ConnectionStateSnapshot = {
    type: {
        name: "Composite",
        className: "ConnectionStateSnapshot",
        modelProperties: {
            connectionState: {
                serializedName: "connectionState",
                type: {
                    name: "String"
                }
            },
            startTime: {
                serializedName: "startTime",
                type: {
                    name: "DateTime"
                }
            },
            endTime: {
                serializedName: "endTime",
                type: {
                    name: "DateTime"
                }
            },
            evaluationState: {
                serializedName: "evaluationState",
                type: {
                    name: "String"
                }
            },
            avgLatencyInMs: {
                constraints: {
                    InclusiveMaximum: 4294967295,
                    InclusiveMinimum: 0
                },
                serializedName: "avgLatencyInMs",
                type: {
                    name: "Number"
                }
            },
            minLatencyInMs: {
                constraints: {
                    InclusiveMaximum: 4294967295,
                    InclusiveMinimum: 0
                },
                serializedName: "minLatencyInMs",
                type: {
                    name: "Number"
                }
            },
            maxLatencyInMs: {
                constraints: {
                    InclusiveMaximum: 4294967295,
                    InclusiveMinimum: 0
                },
                serializedName: "maxLatencyInMs",
                type: {
                    name: "Number"
                }
            },
            probesSent: {
                constraints: {
                    InclusiveMaximum: 4294967295,
                    InclusiveMinimum: 0
                },
                serializedName: "probesSent",
                type: {
                    name: "Number"
                }
            },
            probesFailed: {
                constraints: {
                    InclusiveMaximum: 4294967295,
                    InclusiveMinimum: 0
                },
                serializedName: "probesFailed",
                type: {
                    name: "Number"
                }
            },
            hops: {
                serializedName: "hops",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ConnectivityHop"
                        }
                    }
                }
            }
        }
    }
};
const ConnectionMonitorListResult = {
    type: {
        name: "Composite",
        className: "ConnectionMonitorListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ConnectionMonitorResult"
                        }
                    }
                }
            }
        }
    }
};
const FlowLogListResult = {
    type: {
        name: "Composite",
        className: "FlowLogListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "FlowLog"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const OperationListResult = {
    type: {
        name: "Composite",
        className: "OperationListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Operation"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Operation = {
    type: {
        name: "Composite",
        className: "Operation",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            display: {
                serializedName: "display",
                type: {
                    name: "Composite",
                    className: "OperationDisplay"
                }
            },
            origin: {
                serializedName: "origin",
                type: {
                    name: "String"
                }
            },
            serviceSpecification: {
                serializedName: "properties.serviceSpecification",
                type: {
                    name: "Composite",
                    className: "OperationPropertiesFormatServiceSpecification"
                }
            }
        }
    }
};
const OperationDisplay = {
    type: {
        name: "Composite",
        className: "OperationDisplay",
        modelProperties: {
            provider: {
                serializedName: "provider",
                type: {
                    name: "String"
                }
            },
            resource: {
                serializedName: "resource",
                type: {
                    name: "String"
                }
            },
            operation: {
                serializedName: "operation",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const OperationPropertiesFormatServiceSpecification = {
    type: {
        name: "Composite",
        className: "OperationPropertiesFormatServiceSpecification",
        modelProperties: {
            metricSpecifications: {
                serializedName: "metricSpecifications",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "MetricSpecification"
                        }
                    }
                }
            },
            logSpecifications: {
                serializedName: "logSpecifications",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "LogSpecification"
                        }
                    }
                }
            }
        }
    }
};
const MetricSpecification = {
    type: {
        name: "Composite",
        className: "MetricSpecification",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            displayName: {
                serializedName: "displayName",
                type: {
                    name: "String"
                }
            },
            displayDescription: {
                serializedName: "displayDescription",
                type: {
                    name: "String"
                }
            },
            unit: {
                serializedName: "unit",
                type: {
                    name: "String"
                }
            },
            aggregationType: {
                serializedName: "aggregationType",
                type: {
                    name: "String"
                }
            },
            availabilities: {
                serializedName: "availabilities",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Availability"
                        }
                    }
                }
            },
            enableRegionalMdmAccount: {
                serializedName: "enableRegionalMdmAccount",
                type: {
                    name: "Boolean"
                }
            },
            fillGapWithZero: {
                serializedName: "fillGapWithZero",
                type: {
                    name: "Boolean"
                }
            },
            metricFilterPattern: {
                serializedName: "metricFilterPattern",
                type: {
                    name: "String"
                }
            },
            dimensions: {
                serializedName: "dimensions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Dimension"
                        }
                    }
                }
            },
            isInternal: {
                serializedName: "isInternal",
                type: {
                    name: "Boolean"
                }
            },
            sourceMdmAccount: {
                serializedName: "sourceMdmAccount",
                type: {
                    name: "String"
                }
            },
            sourceMdmNamespace: {
                serializedName: "sourceMdmNamespace",
                type: {
                    name: "String"
                }
            },
            resourceIdDimensionNameOverride: {
                serializedName: "resourceIdDimensionNameOverride",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Availability = {
    type: {
        name: "Composite",
        className: "Availability",
        modelProperties: {
            timeGrain: {
                serializedName: "timeGrain",
                type: {
                    name: "String"
                }
            },
            retention: {
                serializedName: "retention",
                type: {
                    name: "String"
                }
            },
            blobDuration: {
                serializedName: "blobDuration",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Dimension = {
    type: {
        name: "Composite",
        className: "Dimension",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            displayName: {
                serializedName: "displayName",
                type: {
                    name: "String"
                }
            },
            internalName: {
                serializedName: "internalName",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const LogSpecification = {
    type: {
        name: "Composite",
        className: "LogSpecification",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            displayName: {
                serializedName: "displayName",
                type: {
                    name: "String"
                }
            },
            blobDuration: {
                serializedName: "blobDuration",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PrivateEndpointListResult = {
    type: {
        name: "Composite",
        className: "PrivateEndpointListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PrivateEndpoint"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AvailablePrivateEndpointTypesResult = {
    type: {
        name: "Composite",
        className: "AvailablePrivateEndpointTypesResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AvailablePrivateEndpointType"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AvailablePrivateEndpointType = {
    type: {
        name: "Composite",
        className: "AvailablePrivateEndpointType",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            },
            resourceName: {
                serializedName: "resourceName",
                type: {
                    name: "String"
                }
            },
            displayName: {
                serializedName: "displayName",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PrivateDnsZoneConfig = {
    type: {
        name: "Composite",
        className: "PrivateDnsZoneConfig",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            privateDnsZoneId: {
                serializedName: "properties.privateDnsZoneId",
                type: {
                    name: "String"
                }
            },
            recordSets: {
                serializedName: "properties.recordSets",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RecordSet"
                        }
                    }
                }
            }
        }
    }
};
const RecordSet = {
    type: {
        name: "Composite",
        className: "RecordSet",
        modelProperties: {
            recordType: {
                serializedName: "recordType",
                type: {
                    name: "String"
                }
            },
            recordSetName: {
                serializedName: "recordSetName",
                type: {
                    name: "String"
                }
            },
            fqdn: {
                serializedName: "fqdn",
                type: {
                    name: "String"
                }
            },
            provisioningState: {
                serializedName: "provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            ttl: {
                serializedName: "ttl",
                type: {
                    name: "Number"
                }
            },
            ipAddresses: {
                serializedName: "ipAddresses",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const PrivateDnsZoneGroupListResult = {
    type: {
        name: "Composite",
        className: "PrivateDnsZoneGroupListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PrivateDnsZoneGroup"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PrivateLinkServiceListResult = {
    type: {
        name: "Composite",
        className: "PrivateLinkServiceListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PrivateLinkService"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PrivateEndpointConnectionListResult = {
    type: {
        name: "Composite",
        className: "PrivateEndpointConnectionListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PrivateEndpointConnection"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CheckPrivateLinkServiceVisibilityRequest = {
    type: {
        name: "Composite",
        className: "CheckPrivateLinkServiceVisibilityRequest",
        modelProperties: {
            privateLinkServiceAlias: {
                serializedName: "privateLinkServiceAlias",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PrivateLinkServiceVisibility = {
    type: {
        name: "Composite",
        className: "PrivateLinkServiceVisibility",
        modelProperties: {
            visible: {
                serializedName: "visible",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const AutoApprovedPrivateLinkServicesResult = {
    type: {
        name: "Composite",
        className: "AutoApprovedPrivateLinkServicesResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AutoApprovedPrivateLinkService"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AutoApprovedPrivateLinkService = {
    type: {
        name: "Composite",
        className: "AutoApprovedPrivateLinkService",
        modelProperties: {
            privateLinkService: {
                serializedName: "privateLinkService",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PublicIPPrefixSku = {
    type: {
        name: "Composite",
        className: "PublicIPPrefixSku",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            tier: {
                serializedName: "tier",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ReferencedPublicIpAddress = {
    type: {
        name: "Composite",
        className: "ReferencedPublicIpAddress",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PublicIPPrefixListResult = {
    type: {
        name: "Composite",
        className: "PublicIPPrefixListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PublicIPPrefix"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RouteFilterListResult = {
    type: {
        name: "Composite",
        className: "RouteFilterListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RouteFilter"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RouteFilterRuleListResult = {
    type: {
        name: "Composite",
        className: "RouteFilterRuleListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RouteFilterRule"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RouteTableListResult = {
    type: {
        name: "Composite",
        className: "RouteTableListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RouteTable"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RouteListResult = {
    type: {
        name: "Composite",
        className: "RouteListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Route"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SecurityPartnerProviderListResult = {
    type: {
        name: "Composite",
        className: "SecurityPartnerProviderListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SecurityPartnerProvider"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const BgpServiceCommunityListResult = {
    type: {
        name: "Composite",
        className: "BgpServiceCommunityListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "BgpServiceCommunity"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const BGPCommunity = {
    type: {
        name: "Composite",
        className: "BGPCommunity",
        modelProperties: {
            serviceSupportedRegion: {
                serializedName: "serviceSupportedRegion",
                type: {
                    name: "String"
                }
            },
            communityName: {
                serializedName: "communityName",
                type: {
                    name: "String"
                }
            },
            communityValue: {
                serializedName: "communityValue",
                type: {
                    name: "String"
                }
            },
            communityPrefixes: {
                serializedName: "communityPrefixes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            isAuthorizedToUse: {
                serializedName: "isAuthorizedToUse",
                type: {
                    name: "Boolean"
                }
            },
            serviceGroup: {
                serializedName: "serviceGroup",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ServiceEndpointPolicyListResult = {
    type: {
        name: "Composite",
        className: "ServiceEndpointPolicyListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ServiceEndpointPolicy"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ServiceEndpointPolicyDefinitionListResult = {
    type: {
        name: "Composite",
        className: "ServiceEndpointPolicyDefinitionListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ServiceEndpointPolicyDefinition"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ServiceTagsListResult = {
    type: {
        name: "Composite",
        className: "ServiceTagsListResult",
        modelProperties: {
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            changeNumber: {
                serializedName: "changeNumber",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            cloud: {
                serializedName: "cloud",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            values: {
                serializedName: "values",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ServiceTagInformation"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ServiceTagInformation = {
    type: {
        name: "Composite",
        className: "ServiceTagInformation",
        modelProperties: {
            properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "ServiceTagInformationPropertiesFormat"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            serviceTagChangeNumber: {
                serializedName: "serviceTagChangeNumber",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ServiceTagInformationPropertiesFormat = {
    type: {
        name: "Composite",
        className: "ServiceTagInformationPropertiesFormat",
        modelProperties: {
            changeNumber: {
                serializedName: "changeNumber",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            region: {
                serializedName: "region",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            systemService: {
                serializedName: "systemService",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            addressPrefixes: {
                serializedName: "addressPrefixes",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            state: {
                serializedName: "state",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ServiceTagInformationListResult = {
    type: {
        name: "Composite",
        className: "ServiceTagInformationListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ServiceTagInformation"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const UsagesListResult = {
    type: {
        name: "Composite",
        className: "UsagesListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Usage"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Usage = {
    type: {
        name: "Composite",
        className: "Usage",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            unit: {
                serializedName: "unit",
                required: true,
                type: {
                    name: "String"
                }
            },
            currentValue: {
                serializedName: "currentValue",
                required: true,
                type: {
                    name: "Number"
                }
            },
            limit: {
                serializedName: "limit",
                required: true,
                type: {
                    name: "Number"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "Composite",
                    className: "UsageName"
                }
            }
        }
    }
};
const UsageName = {
    type: {
        name: "Composite",
        className: "UsageName",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "String"
                }
            },
            localizedValue: {
                serializedName: "localizedValue",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AddressSpace = {
    type: {
        name: "Composite",
        className: "AddressSpace",
        modelProperties: {
            addressPrefixes: {
                serializedName: "addressPrefixes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const DhcpOptions = {
    type: {
        name: "Composite",
        className: "DhcpOptions",
        modelProperties: {
            dnsServers: {
                serializedName: "dnsServers",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const VirtualNetworkBgpCommunities = {
    type: {
        name: "Composite",
        className: "VirtualNetworkBgpCommunities",
        modelProperties: {
            virtualNetworkCommunity: {
                serializedName: "virtualNetworkCommunity",
                required: true,
                type: {
                    name: "String"
                }
            },
            regionalCommunity: {
                serializedName: "regionalCommunity",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VirtualNetworkEncryption = {
    type: {
        name: "Composite",
        className: "VirtualNetworkEncryption",
        modelProperties: {
            enabled: {
                serializedName: "enabled",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            enforcement: {
                serializedName: "enforcement",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VirtualNetworkListResult = {
    type: {
        name: "Composite",
        className: "VirtualNetworkListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualNetwork"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PrepareNetworkPoliciesRequest = {
    type: {
        name: "Composite",
        className: "PrepareNetworkPoliciesRequest",
        modelProperties: {
            serviceName: {
                serializedName: "serviceName",
                type: {
                    name: "String"
                }
            },
            networkIntentPolicyConfigurations: {
                serializedName: "networkIntentPolicyConfigurations",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "NetworkIntentPolicyConfiguration"
                        }
                    }
                }
            }
        }
    }
};
const NetworkIntentPolicyConfiguration = {
    type: {
        name: "Composite",
        className: "NetworkIntentPolicyConfiguration",
        modelProperties: {
            networkIntentPolicyName: {
                serializedName: "networkIntentPolicyName",
                type: {
                    name: "String"
                }
            },
            sourceNetworkIntentPolicy: {
                serializedName: "sourceNetworkIntentPolicy",
                type: {
                    name: "Composite",
                    className: "NetworkIntentPolicy"
                }
            }
        }
    }
};
const UnprepareNetworkPoliciesRequest = {
    type: {
        name: "Composite",
        className: "UnprepareNetworkPoliciesRequest",
        modelProperties: {
            serviceName: {
                serializedName: "serviceName",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ResourceNavigationLinksListResult = {
    type: {
        name: "Composite",
        className: "ResourceNavigationLinksListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ResourceNavigationLink"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ServiceAssociationLinksListResult = {
    type: {
        name: "Composite",
        className: "ServiceAssociationLinksListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ServiceAssociationLink"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SubnetListResult = {
    type: {
        name: "Composite",
        className: "SubnetListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Subnet"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VirtualNetworkPeeringListResult = {
    type: {
        name: "Composite",
        className: "VirtualNetworkPeeringListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualNetworkPeering"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const IPAddressAvailabilityResult = {
    type: {
        name: "Composite",
        className: "IPAddressAvailabilityResult",
        modelProperties: {
            available: {
                serializedName: "available",
                type: {
                    name: "Boolean"
                }
            },
            availableIPAddresses: {
                serializedName: "availableIPAddresses",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            isPlatformReserved: {
                serializedName: "isPlatformReserved",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const VirtualNetworkListUsageResult = {
    type: {
        name: "Composite",
        className: "VirtualNetworkListUsageResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualNetworkUsage"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VirtualNetworkUsage = {
    type: {
        name: "Composite",
        className: "VirtualNetworkUsage",
        modelProperties: {
            currentValue: {
                serializedName: "currentValue",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            limit: {
                serializedName: "limit",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "Composite",
                    className: "VirtualNetworkUsageName"
                }
            },
            unit: {
                serializedName: "unit",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VirtualNetworkUsageName = {
    type: {
        name: "Composite",
        className: "VirtualNetworkUsageName",
        modelProperties: {
            localizedValue: {
                serializedName: "localizedValue",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VirtualNetworkGatewaySku = {
    type: {
        name: "Composite",
        className: "VirtualNetworkGatewaySku",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            tier: {
                serializedName: "tier",
                type: {
                    name: "String"
                }
            },
            capacity: {
                serializedName: "capacity",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const VpnClientConfiguration = {
    type: {
        name: "Composite",
        className: "VpnClientConfiguration",
        modelProperties: {
            vpnClientAddressPool: {
                serializedName: "vpnClientAddressPool",
                type: {
                    name: "Composite",
                    className: "AddressSpace"
                }
            },
            vpnClientRootCertificates: {
                serializedName: "vpnClientRootCertificates",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VpnClientRootCertificate"
                        }
                    }
                }
            },
            vpnClientRevokedCertificates: {
                serializedName: "vpnClientRevokedCertificates",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VpnClientRevokedCertificate"
                        }
                    }
                }
            },
            vpnClientProtocols: {
                serializedName: "vpnClientProtocols",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            vpnAuthenticationTypes: {
                serializedName: "vpnAuthenticationTypes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            vpnClientIpsecPolicies: {
                serializedName: "vpnClientIpsecPolicies",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "IpsecPolicy"
                        }
                    }
                }
            },
            radiusServerAddress: {
                serializedName: "radiusServerAddress",
                type: {
                    name: "String"
                }
            },
            radiusServerSecret: {
                serializedName: "radiusServerSecret",
                type: {
                    name: "String"
                }
            },
            radiusServers: {
                serializedName: "radiusServers",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RadiusServer"
                        }
                    }
                }
            },
            aadTenant: {
                serializedName: "aadTenant",
                type: {
                    name: "String"
                }
            },
            aadAudience: {
                serializedName: "aadAudience",
                type: {
                    name: "String"
                }
            },
            aadIssuer: {
                serializedName: "aadIssuer",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const IpsecPolicy = {
    type: {
        name: "Composite",
        className: "IpsecPolicy",
        modelProperties: {
            saLifeTimeSeconds: {
                serializedName: "saLifeTimeSeconds",
                required: true,
                type: {
                    name: "Number"
                }
            },
            saDataSizeKilobytes: {
                serializedName: "saDataSizeKilobytes",
                required: true,
                type: {
                    name: "Number"
                }
            },
            ipsecEncryption: {
                serializedName: "ipsecEncryption",
                required: true,
                type: {
                    name: "String"
                }
            },
            ipsecIntegrity: {
                serializedName: "ipsecIntegrity",
                required: true,
                type: {
                    name: "String"
                }
            },
            ikeEncryption: {
                serializedName: "ikeEncryption",
                required: true,
                type: {
                    name: "String"
                }
            },
            ikeIntegrity: {
                serializedName: "ikeIntegrity",
                required: true,
                type: {
                    name: "String"
                }
            },
            dhGroup: {
                serializedName: "dhGroup",
                required: true,
                type: {
                    name: "String"
                }
            },
            pfsGroup: {
                serializedName: "pfsGroup",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RadiusServer = {
    type: {
        name: "Composite",
        className: "RadiusServer",
        modelProperties: {
            radiusServerAddress: {
                serializedName: "radiusServerAddress",
                required: true,
                type: {
                    name: "String"
                }
            },
            radiusServerScore: {
                serializedName: "radiusServerScore",
                type: {
                    name: "Number"
                }
            },
            radiusServerSecret: {
                serializedName: "radiusServerSecret",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const BgpSettings = {
    type: {
        name: "Composite",
        className: "BgpSettings",
        modelProperties: {
            asn: {
                constraints: {
                    InclusiveMaximum: 4294967295,
                    InclusiveMinimum: 0
                },
                serializedName: "asn",
                type: {
                    name: "Number"
                }
            },
            bgpPeeringAddress: {
                serializedName: "bgpPeeringAddress",
                type: {
                    name: "String"
                }
            },
            peerWeight: {
                serializedName: "peerWeight",
                type: {
                    name: "Number"
                }
            },
            bgpPeeringAddresses: {
                serializedName: "bgpPeeringAddresses",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "IPConfigurationBgpPeeringAddress"
                        }
                    }
                }
            }
        }
    }
};
const IPConfigurationBgpPeeringAddress = {
    type: {
        name: "Composite",
        className: "IPConfigurationBgpPeeringAddress",
        modelProperties: {
            ipconfigurationId: {
                serializedName: "ipconfigurationId",
                type: {
                    name: "String"
                }
            },
            defaultBgpIpAddresses: {
                serializedName: "defaultBgpIpAddresses",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            customBgpIpAddresses: {
                serializedName: "customBgpIpAddresses",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            tunnelIpAddresses: {
                serializedName: "tunnelIpAddresses",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const VpnNatRuleMapping = {
    type: {
        name: "Composite",
        className: "VpnNatRuleMapping",
        modelProperties: {
            addressSpace: {
                serializedName: "addressSpace",
                type: {
                    name: "String"
                }
            },
            portRange: {
                serializedName: "portRange",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VirtualNetworkGatewayListResult = {
    type: {
        name: "Composite",
        className: "VirtualNetworkGatewayListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualNetworkGateway"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VirtualNetworkGatewayListConnectionsResult = {
    type: {
        name: "Composite",
        className: "VirtualNetworkGatewayListConnectionsResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualNetworkGatewayConnectionListEntity"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VirtualNetworkConnectionGatewayReference = {
    type: {
        name: "Composite",
        className: "VirtualNetworkConnectionGatewayReference",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TunnelConnectionHealth = {
    type: {
        name: "Composite",
        className: "TunnelConnectionHealth",
        modelProperties: {
            tunnel: {
                serializedName: "tunnel",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            connectionStatus: {
                serializedName: "connectionStatus",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            ingressBytesTransferred: {
                serializedName: "ingressBytesTransferred",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            egressBytesTransferred: {
                serializedName: "egressBytesTransferred",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            lastConnectionEstablishedUtcTime: {
                serializedName: "lastConnectionEstablishedUtcTime",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TrafficSelectorPolicy = {
    type: {
        name: "Composite",
        className: "TrafficSelectorPolicy",
        modelProperties: {
            localAddressRanges: {
                serializedName: "localAddressRanges",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            remoteAddressRanges: {
                serializedName: "remoteAddressRanges",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const VpnClientParameters = {
    type: {
        name: "Composite",
        className: "VpnClientParameters",
        modelProperties: {
            processorArchitecture: {
                serializedName: "processorArchitecture",
                type: {
                    name: "String"
                }
            },
            authenticationMethod: {
                serializedName: "authenticationMethod",
                type: {
                    name: "String"
                }
            },
            radiusServerAuthCertificate: {
                serializedName: "radiusServerAuthCertificate",
                type: {
                    name: "String"
                }
            },
            clientRootCertificates: {
                serializedName: "clientRootCertificates",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const BgpPeerStatusListResult = {
    type: {
        name: "Composite",
        className: "BgpPeerStatusListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "BgpPeerStatus"
                        }
                    }
                }
            }
        }
    }
};
const BgpPeerStatus = {
    type: {
        name: "Composite",
        className: "BgpPeerStatus",
        modelProperties: {
            localAddress: {
                serializedName: "localAddress",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            neighbor: {
                serializedName: "neighbor",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            asn: {
                constraints: {
                    InclusiveMaximum: 4294967295,
                    InclusiveMinimum: 0
                },
                serializedName: "asn",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            state: {
                serializedName: "state",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            connectedDuration: {
                serializedName: "connectedDuration",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            routesReceived: {
                serializedName: "routesReceived",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            messagesSent: {
                serializedName: "messagesSent",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            messagesReceived: {
                serializedName: "messagesReceived",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const GatewayRouteListResult = {
    type: {
        name: "Composite",
        className: "GatewayRouteListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "GatewayRoute"
                        }
                    }
                }
            }
        }
    }
};
const GatewayRoute = {
    type: {
        name: "Composite",
        className: "GatewayRoute",
        modelProperties: {
            localAddress: {
                serializedName: "localAddress",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            network: {
                serializedName: "network",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            nextHop: {
                serializedName: "nextHop",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            sourcePeer: {
                serializedName: "sourcePeer",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            origin: {
                serializedName: "origin",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            asPath: {
                serializedName: "asPath",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            weight: {
                serializedName: "weight",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const VpnClientIPsecParameters = {
    type: {
        name: "Composite",
        className: "VpnClientIPsecParameters",
        modelProperties: {
            saLifeTimeSeconds: {
                serializedName: "saLifeTimeSeconds",
                required: true,
                type: {
                    name: "Number"
                }
            },
            saDataSizeKilobytes: {
                serializedName: "saDataSizeKilobytes",
                required: true,
                type: {
                    name: "Number"
                }
            },
            ipsecEncryption: {
                serializedName: "ipsecEncryption",
                required: true,
                type: {
                    name: "String"
                }
            },
            ipsecIntegrity: {
                serializedName: "ipsecIntegrity",
                required: true,
                type: {
                    name: "String"
                }
            },
            ikeEncryption: {
                serializedName: "ikeEncryption",
                required: true,
                type: {
                    name: "String"
                }
            },
            ikeIntegrity: {
                serializedName: "ikeIntegrity",
                required: true,
                type: {
                    name: "String"
                }
            },
            dhGroup: {
                serializedName: "dhGroup",
                required: true,
                type: {
                    name: "String"
                }
            },
            pfsGroup: {
                serializedName: "pfsGroup",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VpnDeviceScriptParameters = {
    type: {
        name: "Composite",
        className: "VpnDeviceScriptParameters",
        modelProperties: {
            vendor: {
                serializedName: "vendor",
                type: {
                    name: "String"
                }
            },
            deviceFamily: {
                serializedName: "deviceFamily",
                type: {
                    name: "String"
                }
            },
            firmwareVersion: {
                serializedName: "firmwareVersion",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VpnPacketCaptureStartParameters = {
    type: {
        name: "Composite",
        className: "VpnPacketCaptureStartParameters",
        modelProperties: {
            filterData: {
                serializedName: "filterData",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VpnPacketCaptureStopParameters = {
    type: {
        name: "Composite",
        className: "VpnPacketCaptureStopParameters",
        modelProperties: {
            sasUrl: {
                serializedName: "sasUrl",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VirtualNetworkGatewayConnectionListResult = {
    type: {
        name: "Composite",
        className: "VirtualNetworkGatewayConnectionListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualNetworkGatewayConnection"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ConnectionResetSharedKey = {
    type: {
        name: "Composite",
        className: "ConnectionResetSharedKey",
        modelProperties: {
            keyLength: {
                constraints: {
                    InclusiveMaximum: 128,
                    InclusiveMinimum: 1
                },
                serializedName: "keyLength",
                required: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const LocalNetworkGatewayListResult = {
    type: {
        name: "Composite",
        className: "LocalNetworkGatewayListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "LocalNetworkGateway"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VpnClientConnectionHealthDetailListResult = {
    type: {
        name: "Composite",
        className: "VpnClientConnectionHealthDetailListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VpnClientConnectionHealthDetail"
                        }
                    }
                }
            }
        }
    }
};
const VpnClientConnectionHealthDetail = {
    type: {
        name: "Composite",
        className: "VpnClientConnectionHealthDetail",
        modelProperties: {
            vpnConnectionId: {
                serializedName: "vpnConnectionId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            vpnConnectionDuration: {
                serializedName: "vpnConnectionDuration",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            vpnConnectionTime: {
                serializedName: "vpnConnectionTime",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            publicIpAddress: {
                serializedName: "publicIpAddress",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            privateIpAddress: {
                serializedName: "privateIpAddress",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            vpnUserName: {
                serializedName: "vpnUserName",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            maxBandwidth: {
                serializedName: "maxBandwidth",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            egressPacketsTransferred: {
                serializedName: "egressPacketsTransferred",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            egressBytesTransferred: {
                serializedName: "egressBytesTransferred",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            ingressPacketsTransferred: {
                serializedName: "ingressPacketsTransferred",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            ingressBytesTransferred: {
                serializedName: "ingressBytesTransferred",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            maxPacketsPerSecond: {
                serializedName: "maxPacketsPerSecond",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const P2SVpnConnectionRequest = {
    type: {
        name: "Composite",
        className: "P2SVpnConnectionRequest",
        modelProperties: {
            vpnConnectionIds: {
                serializedName: "vpnConnectionIds",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const ListVirtualNetworkGatewayNatRulesResult = {
    type: {
        name: "Composite",
        className: "ListVirtualNetworkGatewayNatRulesResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualNetworkGatewayNatRule"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VirtualNetworkTapListResult = {
    type: {
        name: "Composite",
        className: "VirtualNetworkTapListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualNetworkTap"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VirtualRouterListResult = {
    type: {
        name: "Composite",
        className: "VirtualRouterListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualRouter"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VirtualRouterPeeringListResult = {
    type: {
        name: "Composite",
        className: "VirtualRouterPeeringListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualRouterPeering"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ListVirtualWANsResult = {
    type: {
        name: "Composite",
        className: "ListVirtualWANsResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualWAN"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DeviceProperties = {
    type: {
        name: "Composite",
        className: "DeviceProperties",
        modelProperties: {
            deviceVendor: {
                serializedName: "deviceVendor",
                type: {
                    name: "String"
                }
            },
            deviceModel: {
                serializedName: "deviceModel",
                type: {
                    name: "String"
                }
            },
            linkSpeedInMbps: {
                serializedName: "linkSpeedInMbps",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const VpnLinkProviderProperties = {
    type: {
        name: "Composite",
        className: "VpnLinkProviderProperties",
        modelProperties: {
            linkProviderName: {
                serializedName: "linkProviderName",
                type: {
                    name: "String"
                }
            },
            linkSpeedInMbps: {
                serializedName: "linkSpeedInMbps",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const VpnLinkBgpSettings = {
    type: {
        name: "Composite",
        className: "VpnLinkBgpSettings",
        modelProperties: {
            asn: {
                serializedName: "asn",
                type: {
                    name: "Number"
                }
            },
            bgpPeeringAddress: {
                serializedName: "bgpPeeringAddress",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const O365PolicyProperties = {
    type: {
        name: "Composite",
        className: "O365PolicyProperties",
        modelProperties: {
            breakOutCategories: {
                serializedName: "breakOutCategories",
                type: {
                    name: "Composite",
                    className: "O365BreakOutCategoryPolicies"
                }
            }
        }
    }
};
const O365BreakOutCategoryPolicies = {
    type: {
        name: "Composite",
        className: "O365BreakOutCategoryPolicies",
        modelProperties: {
            allow: {
                serializedName: "allow",
                type: {
                    name: "Boolean"
                }
            },
            optimize: {
                serializedName: "optimize",
                type: {
                    name: "Boolean"
                }
            },
            default: {
                serializedName: "default",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const ListVpnSitesResult = {
    type: {
        name: "Composite",
        className: "ListVpnSitesResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VpnSite"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ListVpnSiteLinksResult = {
    type: {
        name: "Composite",
        className: "ListVpnSiteLinksResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VpnSiteLink"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const GetVpnSitesConfigurationRequest = {
    type: {
        name: "Composite",
        className: "GetVpnSitesConfigurationRequest",
        modelProperties: {
            vpnSites: {
                serializedName: "vpnSites",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            outputBlobSasUrl: {
                serializedName: "outputBlobSasUrl",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VirtualWanSecurityProviders = {
    type: {
        name: "Composite",
        className: "VirtualWanSecurityProviders",
        modelProperties: {
            supportedProviders: {
                serializedName: "supportedProviders",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualWanSecurityProvider"
                        }
                    }
                }
            }
        }
    }
};
const VirtualWanSecurityProvider = {
    type: {
        name: "Composite",
        className: "VirtualWanSecurityProvider",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            url: {
                serializedName: "url",
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VpnServerConfigVpnClientRootCertificate = {
    type: {
        name: "Composite",
        className: "VpnServerConfigVpnClientRootCertificate",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            publicCertData: {
                serializedName: "publicCertData",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VpnServerConfigVpnClientRevokedCertificate = {
    type: {
        name: "Composite",
        className: "VpnServerConfigVpnClientRevokedCertificate",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            thumbprint: {
                serializedName: "thumbprint",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VpnServerConfigRadiusServerRootCertificate = {
    type: {
        name: "Composite",
        className: "VpnServerConfigRadiusServerRootCertificate",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            publicCertData: {
                serializedName: "publicCertData",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VpnServerConfigRadiusClientRootCertificate = {
    type: {
        name: "Composite",
        className: "VpnServerConfigRadiusClientRootCertificate",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            thumbprint: {
                serializedName: "thumbprint",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AadAuthenticationParameters = {
    type: {
        name: "Composite",
        className: "AadAuthenticationParameters",
        modelProperties: {
            aadTenant: {
                serializedName: "aadTenant",
                type: {
                    name: "String"
                }
            },
            aadAudience: {
                serializedName: "aadAudience",
                type: {
                    name: "String"
                }
            },
            aadIssuer: {
                serializedName: "aadIssuer",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RoutingConfiguration = {
    type: {
        name: "Composite",
        className: "RoutingConfiguration",
        modelProperties: {
            associatedRouteTable: {
                serializedName: "associatedRouteTable",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            },
            propagatedRouteTables: {
                serializedName: "propagatedRouteTables",
                type: {
                    name: "Composite",
                    className: "PropagatedRouteTable"
                }
            },
            vnetRoutes: {
                serializedName: "vnetRoutes",
                type: {
                    name: "Composite",
                    className: "VnetRoute"
                }
            }
        }
    }
};
const PropagatedRouteTable = {
    type: {
        name: "Composite",
        className: "PropagatedRouteTable",
        modelProperties: {
            labels: {
                serializedName: "labels",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            ids: {
                serializedName: "ids",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            }
        }
    }
};
const VnetRoute = {
    type: {
        name: "Composite",
        className: "VnetRoute",
        modelProperties: {
            staticRoutes: {
                serializedName: "staticRoutes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "StaticRoute"
                        }
                    }
                }
            },
            bgpConnections: {
                serializedName: "bgpConnections",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            }
        }
    }
};
const StaticRoute = {
    type: {
        name: "Composite",
        className: "StaticRoute",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            addressPrefixes: {
                serializedName: "addressPrefixes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            nextHopIpAddress: {
                serializedName: "nextHopIpAddress",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VpnClientConnectionHealth = {
    type: {
        name: "Composite",
        className: "VpnClientConnectionHealth",
        modelProperties: {
            totalIngressBytesTransferred: {
                serializedName: "totalIngressBytesTransferred",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            totalEgressBytesTransferred: {
                serializedName: "totalEgressBytesTransferred",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            vpnClientConnectionsCount: {
                serializedName: "vpnClientConnectionsCount",
                type: {
                    name: "Number"
                }
            },
            allocatedIpAddresses: {
                serializedName: "allocatedIpAddresses",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const ListVpnServerConfigurationsResult = {
    type: {
        name: "Composite",
        className: "ListVpnServerConfigurationsResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VpnServerConfiguration"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VirtualHubRouteTable = {
    type: {
        name: "Composite",
        className: "VirtualHubRouteTable",
        modelProperties: {
            routes: {
                serializedName: "routes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualHubRoute"
                        }
                    }
                }
            }
        }
    }
};
const VirtualHubRoute = {
    type: {
        name: "Composite",
        className: "VirtualHubRoute",
        modelProperties: {
            addressPrefixes: {
                serializedName: "addressPrefixes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            nextHopIpAddress: {
                serializedName: "nextHopIpAddress",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VirtualHubRouteV2 = {
    type: {
        name: "Composite",
        className: "VirtualHubRouteV2",
        modelProperties: {
            destinationType: {
                serializedName: "destinationType",
                type: {
                    name: "String"
                }
            },
            destinations: {
                serializedName: "destinations",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            nextHopType: {
                serializedName: "nextHopType",
                type: {
                    name: "String"
                }
            },
            nextHops: {
                serializedName: "nextHops",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const ListVirtualHubsResult = {
    type: {
        name: "Composite",
        className: "ListVirtualHubsResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualHub"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ListHubVirtualNetworkConnectionsResult = {
    type: {
        name: "Composite",
        className: "ListHubVirtualNetworkConnectionsResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "HubVirtualNetworkConnection"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VpnGatewayIpConfiguration = {
    type: {
        name: "Composite",
        className: "VpnGatewayIpConfiguration",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            publicIpAddress: {
                serializedName: "publicIpAddress",
                type: {
                    name: "String"
                }
            },
            privateIpAddress: {
                serializedName: "privateIpAddress",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VpnGatewayPacketCaptureStartParameters = {
    type: {
        name: "Composite",
        className: "VpnGatewayPacketCaptureStartParameters",
        modelProperties: {
            filterData: {
                serializedName: "filterData",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VpnGatewayPacketCaptureStopParameters = {
    type: {
        name: "Composite",
        className: "VpnGatewayPacketCaptureStopParameters",
        modelProperties: {
            sasUrl: {
                serializedName: "sasUrl",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ListVpnGatewaysResult = {
    type: {
        name: "Composite",
        className: "ListVpnGatewaysResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VpnGateway"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VpnConnectionPacketCaptureStartParameters = {
    type: {
        name: "Composite",
        className: "VpnConnectionPacketCaptureStartParameters",
        modelProperties: {
            filterData: {
                serializedName: "filterData",
                type: {
                    name: "String"
                }
            },
            linkConnectionNames: {
                serializedName: "linkConnectionNames",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const VpnConnectionPacketCaptureStopParameters = {
    type: {
        name: "Composite",
        className: "VpnConnectionPacketCaptureStopParameters",
        modelProperties: {
            sasUrl: {
                serializedName: "sasUrl",
                type: {
                    name: "String"
                }
            },
            linkConnectionNames: {
                serializedName: "linkConnectionNames",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const ListVpnConnectionsResult = {
    type: {
        name: "Composite",
        className: "ListVpnConnectionsResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VpnConnection"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ListVpnSiteLinkConnectionsResult = {
    type: {
        name: "Composite",
        className: "ListVpnSiteLinkConnectionsResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VpnSiteLinkConnection"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ListVpnGatewayNatRulesResult = {
    type: {
        name: "Composite",
        className: "ListVpnGatewayNatRulesResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VpnGatewayNatRule"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ListP2SVpnGatewaysResult = {
    type: {
        name: "Composite",
        className: "ListP2SVpnGatewaysResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "P2SVpnGateway"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const P2SVpnProfileParameters = {
    type: {
        name: "Composite",
        className: "P2SVpnProfileParameters",
        modelProperties: {
            authenticationMethod: {
                serializedName: "authenticationMethod",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VpnProfileResponse = {
    type: {
        name: "Composite",
        className: "VpnProfileResponse",
        modelProperties: {
            profileUrl: {
                serializedName: "profileUrl",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const P2SVpnConnectionHealthRequest = {
    type: {
        name: "Composite",
        className: "P2SVpnConnectionHealthRequest",
        modelProperties: {
            vpnUserNamesFilter: {
                serializedName: "vpnUserNamesFilter",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            outputBlobSasUrl: {
                serializedName: "outputBlobSasUrl",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const P2SVpnConnectionHealth = {
    type: {
        name: "Composite",
        className: "P2SVpnConnectionHealth",
        modelProperties: {
            sasUrl: {
                serializedName: "sasUrl",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VpnServerConfigurationsResponse = {
    type: {
        name: "Composite",
        className: "VpnServerConfigurationsResponse",
        modelProperties: {
            vpnServerConfigurationResourceIds: {
                serializedName: "vpnServerConfigurationResourceIds",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const VirtualWanVpnProfileParameters = {
    type: {
        name: "Composite",
        className: "VirtualWanVpnProfileParameters",
        modelProperties: {
            vpnServerConfigurationResourceId: {
                serializedName: "vpnServerConfigurationResourceId",
                type: {
                    name: "String"
                }
            },
            authenticationMethod: {
                serializedName: "authenticationMethod",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ListVirtualHubRouteTableV2SResult = {
    type: {
        name: "Composite",
        className: "ListVirtualHubRouteTableV2SResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualHubRouteTableV2"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ExpressRouteGatewayList = {
    type: {
        name: "Composite",
        className: "ExpressRouteGatewayList",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ExpressRouteGateway"
                        }
                    }
                }
            }
        }
    }
};
const ExpressRouteGatewayPropertiesAutoScaleConfiguration = {
    type: {
        name: "Composite",
        className: "ExpressRouteGatewayPropertiesAutoScaleConfiguration",
        modelProperties: {
            bounds: {
                serializedName: "bounds",
                type: {
                    name: "Composite",
                    className: "ExpressRouteGatewayPropertiesAutoScaleConfigurationBounds"
                }
            }
        }
    }
};
const ExpressRouteGatewayPropertiesAutoScaleConfigurationBounds = {
    type: {
        name: "Composite",
        className: "ExpressRouteGatewayPropertiesAutoScaleConfigurationBounds",
        modelProperties: {
            min: {
                serializedName: "min",
                type: {
                    name: "Number"
                }
            },
            max: {
                serializedName: "max",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const ExpressRouteCircuitPeeringId = {
    type: {
        name: "Composite",
        className: "ExpressRouteCircuitPeeringId",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VirtualHubId = {
    type: {
        name: "Composite",
        className: "VirtualHubId",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ExpressRouteConnectionList = {
    type: {
        name: "Composite",
        className: "ExpressRouteConnectionList",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ExpressRouteConnection"
                        }
                    }
                }
            }
        }
    }
};
const ListVirtualHubBgpConnectionResults = {
    type: {
        name: "Composite",
        className: "ListVirtualHubBgpConnectionResults",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "BgpConnection"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PeerRouteList = {
    type: {
        name: "Composite",
        className: "PeerRouteList",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PeerRoute"
                        }
                    }
                }
            }
        }
    }
};
const PeerRoute = {
    type: {
        name: "Composite",
        className: "PeerRoute",
        modelProperties: {
            localAddress: {
                serializedName: "localAddress",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            network: {
                serializedName: "network",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            nextHop: {
                serializedName: "nextHop",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            sourcePeer: {
                serializedName: "sourcePeer",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            origin: {
                serializedName: "origin",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            asPath: {
                serializedName: "asPath",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            weight: {
                serializedName: "weight",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const ListVirtualHubIpConfigurationResults = {
    type: {
        name: "Composite",
        className: "ListVirtualHubIpConfigurationResults",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "HubIpConfiguration"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const HubRoute = {
    type: {
        name: "Composite",
        className: "HubRoute",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            destinationType: {
                serializedName: "destinationType",
                required: true,
                type: {
                    name: "String"
                }
            },
            destinations: {
                serializedName: "destinations",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            nextHopType: {
                serializedName: "nextHopType",
                required: true,
                type: {
                    name: "String"
                }
            },
            nextHop: {
                serializedName: "nextHop",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ListHubRouteTablesResult = {
    type: {
        name: "Composite",
        className: "ListHubRouteTablesResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "HubRouteTable"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const EffectiveRoutesParameters = {
    type: {
        name: "Composite",
        className: "EffectiveRoutesParameters",
        modelProperties: {
            resourceId: {
                serializedName: "resourceId",
                type: {
                    name: "String"
                }
            },
            virtualWanResourceType: {
                serializedName: "virtualWanResourceType",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RoutingPolicy = {
    type: {
        name: "Composite",
        className: "RoutingPolicy",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            destinations: {
                serializedName: "destinations",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            nextHop: {
                serializedName: "nextHop",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ListRoutingIntentResult = {
    type: {
        name: "Composite",
        className: "ListRoutingIntentResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RoutingIntent"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const WebApplicationFirewallPolicyListResult = {
    type: {
        name: "Composite",
        className: "WebApplicationFirewallPolicyListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "WebApplicationFirewallPolicy"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PolicySettings = {
    type: {
        name: "Composite",
        className: "PolicySettings",
        modelProperties: {
            state: {
                serializedName: "state",
                type: {
                    name: "String"
                }
            },
            mode: {
                serializedName: "mode",
                type: {
                    name: "String"
                }
            },
            requestBodyCheck: {
                serializedName: "requestBodyCheck",
                type: {
                    name: "Boolean"
                }
            },
            maxRequestBodySizeInKb: {
                constraints: {
                    InclusiveMinimum: 8
                },
                serializedName: "maxRequestBodySizeInKb",
                type: {
                    name: "Number"
                }
            },
            fileUploadLimitInMb: {
                constraints: {
                    InclusiveMinimum: 0
                },
                serializedName: "fileUploadLimitInMb",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const WebApplicationFirewallCustomRule = {
    type: {
        name: "Composite",
        className: "WebApplicationFirewallCustomRule",
        modelProperties: {
            name: {
                constraints: {
                    MaxLength: 128
                },
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            priority: {
                serializedName: "priority",
                required: true,
                type: {
                    name: "Number"
                }
            },
            ruleType: {
                serializedName: "ruleType",
                required: true,
                type: {
                    name: "String"
                }
            },
            matchConditions: {
                serializedName: "matchConditions",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "MatchCondition"
                        }
                    }
                }
            },
            action: {
                serializedName: "action",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const MatchCondition = {
    type: {
        name: "Composite",
        className: "MatchCondition",
        modelProperties: {
            matchVariables: {
                serializedName: "matchVariables",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "MatchVariable"
                        }
                    }
                }
            },
            operator: {
                serializedName: "operator",
                required: true,
                type: {
                    name: "String"
                }
            },
            negationConditon: {
                serializedName: "negationConditon",
                type: {
                    name: "Boolean"
                }
            },
            matchValues: {
                serializedName: "matchValues",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            transforms: {
                serializedName: "transforms",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const MatchVariable = {
    type: {
        name: "Composite",
        className: "MatchVariable",
        modelProperties: {
            variableName: {
                serializedName: "variableName",
                required: true,
                type: {
                    name: "String"
                }
            },
            selector: {
                serializedName: "selector",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ManagedRulesDefinition = {
    type: {
        name: "Composite",
        className: "ManagedRulesDefinition",
        modelProperties: {
            exclusions: {
                serializedName: "exclusions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "OwaspCrsExclusionEntry"
                        }
                    }
                }
            },
            managedRuleSets: {
                serializedName: "managedRuleSets",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ManagedRuleSet"
                        }
                    }
                }
            }
        }
    }
};
const OwaspCrsExclusionEntry = {
    type: {
        name: "Composite",
        className: "OwaspCrsExclusionEntry",
        modelProperties: {
            matchVariable: {
                serializedName: "matchVariable",
                required: true,
                type: {
                    name: "String"
                }
            },
            selectorMatchOperator: {
                serializedName: "selectorMatchOperator",
                required: true,
                type: {
                    name: "String"
                }
            },
            selector: {
                serializedName: "selector",
                required: true,
                type: {
                    name: "String"
                }
            },
            exclusionManagedRuleSets: {
                serializedName: "exclusionManagedRuleSets",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ExclusionManagedRuleSet"
                        }
                    }
                }
            }
        }
    }
};
const ExclusionManagedRuleSet = {
    type: {
        name: "Composite",
        className: "ExclusionManagedRuleSet",
        modelProperties: {
            ruleSetType: {
                serializedName: "ruleSetType",
                required: true,
                type: {
                    name: "String"
                }
            },
            ruleSetVersion: {
                serializedName: "ruleSetVersion",
                required: true,
                type: {
                    name: "String"
                }
            },
            ruleGroups: {
                serializedName: "ruleGroups",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ExclusionManagedRuleGroup"
                        }
                    }
                }
            }
        }
    }
};
const ExclusionManagedRuleGroup = {
    type: {
        name: "Composite",
        className: "ExclusionManagedRuleGroup",
        modelProperties: {
            ruleGroupName: {
                serializedName: "ruleGroupName",
                required: true,
                type: {
                    name: "String"
                }
            },
            rules: {
                serializedName: "rules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ExclusionManagedRule"
                        }
                    }
                }
            }
        }
    }
};
const ExclusionManagedRule = {
    type: {
        name: "Composite",
        className: "ExclusionManagedRule",
        modelProperties: {
            ruleId: {
                serializedName: "ruleId",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ManagedRuleSet = {
    type: {
        name: "Composite",
        className: "ManagedRuleSet",
        modelProperties: {
            ruleSetType: {
                serializedName: "ruleSetType",
                required: true,
                type: {
                    name: "String"
                }
            },
            ruleSetVersion: {
                serializedName: "ruleSetVersion",
                required: true,
                type: {
                    name: "String"
                }
            },
            ruleGroupOverrides: {
                serializedName: "ruleGroupOverrides",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ManagedRuleGroupOverride"
                        }
                    }
                }
            }
        }
    }
};
const ManagedRuleGroupOverride = {
    type: {
        name: "Composite",
        className: "ManagedRuleGroupOverride",
        modelProperties: {
            ruleGroupName: {
                serializedName: "ruleGroupName",
                required: true,
                type: {
                    name: "String"
                }
            },
            rules: {
                serializedName: "rules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ManagedRuleOverride"
                        }
                    }
                }
            }
        }
    }
};
const ManagedRuleOverride = {
    type: {
        name: "Composite",
        className: "ManagedRuleOverride",
        modelProperties: {
            ruleId: {
                serializedName: "ruleId",
                required: true,
                type: {
                    name: "String"
                }
            },
            state: {
                serializedName: "state",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const FirewallPolicyNatRuleCollectionAction = {
    type: {
        name: "Composite",
        className: "FirewallPolicyNatRuleCollectionAction",
        modelProperties: {
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const FirewallPolicyRule = {
    type: {
        name: "Composite",
        className: "FirewallPolicyRule",
        uberParent: "FirewallPolicyRule",
        polymorphicDiscriminator: {
            serializedName: "ruleType",
            clientName: "ruleType"
        },
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            },
            ruleType: {
                serializedName: "ruleType",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const FirewallPolicyFilterRuleCollectionAction = {
    type: {
        name: "Composite",
        className: "FirewallPolicyFilterRuleCollectionAction",
        modelProperties: {
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const FirewallPolicyRuleApplicationProtocol = {
    type: {
        name: "Composite",
        className: "FirewallPolicyRuleApplicationProtocol",
        modelProperties: {
            protocolType: {
                serializedName: "protocolType",
                type: {
                    name: "String"
                }
            },
            port: {
                constraints: {
                    InclusiveMaximum: 64000,
                    InclusiveMinimum: 0
                },
                serializedName: "port",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const AzureAsyncOperationResult = {
    type: {
        name: "Composite",
        className: "AzureAsyncOperationResult",
        modelProperties: {
            status: {
                serializedName: "status",
                type: {
                    name: "String"
                }
            },
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "ErrorModel"
                }
            }
        }
    }
};
const VpnSiteId = {
    type: {
        name: "Composite",
        className: "VpnSiteId",
        modelProperties: {
            vpnSite: {
                serializedName: "vpnSite",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VirtualHubEffectiveRouteList = {
    type: {
        name: "Composite",
        className: "VirtualHubEffectiveRouteList",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualHubEffectiveRoute"
                        }
                    }
                }
            }
        }
    }
};
const VirtualHubEffectiveRoute = {
    type: {
        name: "Composite",
        className: "VirtualHubEffectiveRoute",
        modelProperties: {
            addressPrefixes: {
                serializedName: "addressPrefixes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            nextHops: {
                serializedName: "nextHops",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            nextHopType: {
                serializedName: "nextHopType",
                type: {
                    name: "String"
                }
            },
            asPath: {
                serializedName: "asPath",
                type: {
                    name: "String"
                }
            },
            routeOrigin: {
                serializedName: "routeOrigin",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ApplicationGatewayIPConfiguration = {
    type: {
        name: "Composite",
        className: "ApplicationGatewayIPConfiguration",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, subnet: {
                serializedName: "properties.subnet",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const ApplicationGatewayAuthenticationCertificate = {
    type: {
        name: "Composite",
        className: "ApplicationGatewayAuthenticationCertificate",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, data: {
                serializedName: "properties.data",
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const ApplicationGatewayTrustedRootCertificate = {
    type: {
        name: "Composite",
        className: "ApplicationGatewayTrustedRootCertificate",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, data: {
                serializedName: "properties.data",
                type: {
                    name: "String"
                }
            }, keyVaultSecretId: {
                serializedName: "properties.keyVaultSecretId",
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const ApplicationGatewayTrustedClientCertificate = {
    type: {
        name: "Composite",
        className: "ApplicationGatewayTrustedClientCertificate",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, data: {
                serializedName: "properties.data",
                type: {
                    name: "String"
                }
            }, validatedCertData: {
                serializedName: "properties.validatedCertData",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, clientCertIssuerDN: {
                serializedName: "properties.clientCertIssuerDN",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const ApplicationGatewaySslCertificate = {
    type: {
        name: "Composite",
        className: "ApplicationGatewaySslCertificate",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, data: {
                serializedName: "properties.data",
                type: {
                    name: "String"
                }
            }, password: {
                serializedName: "properties.password",
                type: {
                    name: "String"
                }
            }, publicCertData: {
                serializedName: "properties.publicCertData",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, keyVaultSecretId: {
                serializedName: "properties.keyVaultSecretId",
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const ApplicationGatewayFrontendIPConfiguration = {
    type: {
        name: "Composite",
        className: "ApplicationGatewayFrontendIPConfiguration",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, privateIPAddress: {
                serializedName: "properties.privateIPAddress",
                type: {
                    name: "String"
                }
            }, privateIPAllocationMethod: {
                serializedName: "properties.privateIPAllocationMethod",
                type: {
                    name: "String"
                }
            }, subnet: {
                serializedName: "properties.subnet",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, publicIPAddress: {
                serializedName: "properties.publicIPAddress",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, privateLinkConfiguration: {
                serializedName: "properties.privateLinkConfiguration",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const ApplicationGatewayFrontendPort = {
    type: {
        name: "Composite",
        className: "ApplicationGatewayFrontendPort",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, port: {
                serializedName: "properties.port",
                type: {
                    name: "Number"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const ApplicationGatewayProbe = {
    type: {
        name: "Composite",
        className: "ApplicationGatewayProbe",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, protocol: {
                serializedName: "properties.protocol",
                type: {
                    name: "String"
                }
            }, host: {
                serializedName: "properties.host",
                type: {
                    name: "String"
                }
            }, path: {
                serializedName: "properties.path",
                type: {
                    name: "String"
                }
            }, interval: {
                serializedName: "properties.interval",
                type: {
                    name: "Number"
                }
            }, timeout: {
                serializedName: "properties.timeout",
                type: {
                    name: "Number"
                }
            }, unhealthyThreshold: {
                serializedName: "properties.unhealthyThreshold",
                type: {
                    name: "Number"
                }
            }, pickHostNameFromBackendHttpSettings: {
                serializedName: "properties.pickHostNameFromBackendHttpSettings",
                type: {
                    name: "Boolean"
                }
            }, minServers: {
                serializedName: "properties.minServers",
                type: {
                    name: "Number"
                }
            }, match: {
                serializedName: "properties.match",
                type: {
                    name: "Composite",
                    className: "ApplicationGatewayProbeHealthResponseMatch"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, port: {
                constraints: {
                    InclusiveMaximum: 65535,
                    InclusiveMinimum: 1
                },
                serializedName: "properties.port",
                type: {
                    name: "Number"
                }
            } })
    }
};
const NetworkInterfaceTapConfiguration = {
    type: {
        name: "Composite",
        className: "NetworkInterfaceTapConfiguration",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, virtualNetworkTap: {
                serializedName: "properties.virtualNetworkTap",
                type: {
                    name: "Composite",
                    className: "VirtualNetworkTap"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const SecurityRule = {
    type: {
        name: "Composite",
        className: "SecurityRule",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            }, description: {
                serializedName: "properties.description",
                type: {
                    name: "String"
                }
            }, protocol: {
                serializedName: "properties.protocol",
                type: {
                    name: "String"
                }
            }, sourcePortRange: {
                serializedName: "properties.sourcePortRange",
                type: {
                    name: "String"
                }
            }, destinationPortRange: {
                serializedName: "properties.destinationPortRange",
                type: {
                    name: "String"
                }
            }, sourceAddressPrefix: {
                serializedName: "properties.sourceAddressPrefix",
                type: {
                    name: "String"
                }
            }, sourceAddressPrefixes: {
                serializedName: "properties.sourceAddressPrefixes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, sourceApplicationSecurityGroups: {
                serializedName: "properties.sourceApplicationSecurityGroups",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationSecurityGroup"
                        }
                    }
                }
            }, destinationAddressPrefix: {
                serializedName: "properties.destinationAddressPrefix",
                type: {
                    name: "String"
                }
            }, destinationAddressPrefixes: {
                serializedName: "properties.destinationAddressPrefixes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, destinationApplicationSecurityGroups: {
                serializedName: "properties.destinationApplicationSecurityGroups",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationSecurityGroup"
                        }
                    }
                }
            }, sourcePortRanges: {
                serializedName: "properties.sourcePortRanges",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, destinationPortRanges: {
                serializedName: "properties.destinationPortRanges",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, access: {
                serializedName: "properties.access",
                type: {
                    name: "String"
                }
            }, priority: {
                serializedName: "properties.priority",
                type: {
                    name: "Number"
                }
            }, direction: {
                serializedName: "properties.direction",
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const PrivateLinkServiceConnection = {
    type: {
        name: "Composite",
        className: "PrivateLinkServiceConnection",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, privateLinkServiceId: {
                serializedName: "properties.privateLinkServiceId",
                type: {
                    name: "String"
                }
            }, groupIds: {
                serializedName: "properties.groupIds",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, requestMessage: {
                serializedName: "properties.requestMessage",
                type: {
                    name: "String"
                }
            }, privateLinkServiceConnectionState: {
                serializedName: "properties.privateLinkServiceConnectionState",
                type: {
                    name: "Composite",
                    className: "PrivateLinkServiceConnectionState"
                }
            } })
    }
};
const PrivateLinkServiceIpConfiguration = {
    type: {
        name: "Composite",
        className: "PrivateLinkServiceIpConfiguration",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, privateIPAddress: {
                serializedName: "properties.privateIPAddress",
                type: {
                    name: "String"
                }
            }, privateIPAllocationMethod: {
                serializedName: "properties.privateIPAllocationMethod",
                type: {
                    name: "String"
                }
            }, subnet: {
                serializedName: "properties.subnet",
                type: {
                    name: "Composite",
                    className: "Subnet"
                }
            }, primary: {
                serializedName: "properties.primary",
                type: {
                    name: "Boolean"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, privateIPAddressVersion: {
                serializedName: "properties.privateIPAddressVersion",
                type: {
                    name: "String"
                }
            } })
    }
};
const PrivateEndpointConnection = {
    type: {
        name: "Composite",
        className: "PrivateEndpointConnection",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, privateEndpoint: {
                serializedName: "properties.privateEndpoint",
                type: {
                    name: "Composite",
                    className: "PrivateEndpoint"
                }
            }, privateLinkServiceConnectionState: {
                serializedName: "properties.privateLinkServiceConnectionState",
                type: {
                    name: "Composite",
                    className: "PrivateLinkServiceConnectionState"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, linkIdentifier: {
                serializedName: "properties.linkIdentifier",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const Route = {
    type: {
        name: "Composite",
        className: "Route",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            }, addressPrefix: {
                serializedName: "properties.addressPrefix",
                type: {
                    name: "String"
                }
            }, nextHopType: {
                serializedName: "properties.nextHopType",
                type: {
                    name: "String"
                }
            }, nextHopIpAddress: {
                serializedName: "properties.nextHopIpAddress",
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, hasBgpOverride: {
                serializedName: "properties.hasBgpOverride",
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const ServiceEndpointPolicyDefinition = {
    type: {
        name: "Composite",
        className: "ServiceEndpointPolicyDefinition",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            }, description: {
                serializedName: "properties.description",
                type: {
                    name: "String"
                }
            }, service: {
                serializedName: "properties.service",
                type: {
                    name: "String"
                }
            }, serviceResources: {
                serializedName: "properties.serviceResources",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const IPConfiguration = {
    type: {
        name: "Composite",
        className: "IPConfiguration",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, privateIPAddress: {
                serializedName: "properties.privateIPAddress",
                type: {
                    name: "String"
                }
            }, privateIPAllocationMethod: {
                serializedName: "properties.privateIPAllocationMethod",
                type: {
                    name: "String"
                }
            }, subnet: {
                serializedName: "properties.subnet",
                type: {
                    name: "Composite",
                    className: "Subnet"
                }
            }, publicIPAddress: {
                serializedName: "properties.publicIPAddress",
                type: {
                    name: "Composite",
                    className: "PublicIPAddress"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const IPConfigurationProfile = {
    type: {
        name: "Composite",
        className: "IPConfigurationProfile",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, subnet: {
                serializedName: "properties.subnet",
                type: {
                    name: "Composite",
                    className: "Subnet"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const ResourceNavigationLink = {
    type: {
        name: "Composite",
        className: "ResourceNavigationLink",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, linkedResourceType: {
                serializedName: "properties.linkedResourceType",
                type: {
                    name: "String"
                }
            }, link: {
                serializedName: "properties.link",
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const ServiceAssociationLink = {
    type: {
        name: "Composite",
        className: "ServiceAssociationLink",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, linkedResourceType: {
                serializedName: "properties.linkedResourceType",
                type: {
                    name: "String"
                }
            }, link: {
                serializedName: "properties.link",
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, allowDelete: {
                serializedName: "properties.allowDelete",
                type: {
                    name: "Boolean"
                }
            }, locations: {
                serializedName: "properties.locations",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            } })
    }
};
const Delegation = {
    type: {
        name: "Composite",
        className: "Delegation",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            }, serviceName: {
                serializedName: "properties.serviceName",
                type: {
                    name: "String"
                }
            }, actions: {
                serializedName: "properties.actions",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const Subnet = {
    type: {
        name: "Composite",
        className: "Subnet",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            }, addressPrefix: {
                serializedName: "properties.addressPrefix",
                type: {
                    name: "String"
                }
            }, addressPrefixes: {
                serializedName: "properties.addressPrefixes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, networkSecurityGroup: {
                serializedName: "properties.networkSecurityGroup",
                type: {
                    name: "Composite",
                    className: "NetworkSecurityGroup"
                }
            }, routeTable: {
                serializedName: "properties.routeTable",
                type: {
                    name: "Composite",
                    className: "RouteTable"
                }
            }, natGateway: {
                serializedName: "properties.natGateway",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, serviceEndpoints: {
                serializedName: "properties.serviceEndpoints",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ServiceEndpointPropertiesFormat"
                        }
                    }
                }
            }, serviceEndpointPolicies: {
                serializedName: "properties.serviceEndpointPolicies",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ServiceEndpointPolicy"
                        }
                    }
                }
            }, privateEndpoints: {
                serializedName: "properties.privateEndpoints",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PrivateEndpoint"
                        }
                    }
                }
            }, ipConfigurations: {
                serializedName: "properties.ipConfigurations",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "IPConfiguration"
                        }
                    }
                }
            }, ipConfigurationProfiles: {
                serializedName: "properties.ipConfigurationProfiles",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "IPConfigurationProfile"
                        }
                    }
                }
            }, ipAllocations: {
                serializedName: "properties.ipAllocations",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            }, resourceNavigationLinks: {
                serializedName: "properties.resourceNavigationLinks",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ResourceNavigationLink"
                        }
                    }
                }
            }, serviceAssociationLinks: {
                serializedName: "properties.serviceAssociationLinks",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ServiceAssociationLink"
                        }
                    }
                }
            }, delegations: {
                serializedName: "properties.delegations",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Delegation"
                        }
                    }
                }
            }, purpose: {
                serializedName: "properties.purpose",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, privateEndpointNetworkPolicies: {
                defaultValue: "Enabled",
                serializedName: "properties.privateEndpointNetworkPolicies",
                type: {
                    name: "String"
                }
            }, privateLinkServiceNetworkPolicies: {
                defaultValue: "Enabled",
                serializedName: "properties.privateLinkServiceNetworkPolicies",
                type: {
                    name: "String"
                }
            }, applicationGatewayIpConfigurations: {
                serializedName: "properties.applicationGatewayIpConfigurations",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationGatewayIPConfiguration"
                        }
                    }
                }
            } })
    }
};
const FrontendIPConfiguration = {
    type: {
        name: "Composite",
        className: "FrontendIPConfiguration",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, zones: {
                serializedName: "zones",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, inboundNatRules: {
                serializedName: "properties.inboundNatRules",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            }, inboundNatPools: {
                serializedName: "properties.inboundNatPools",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            }, outboundRules: {
                serializedName: "properties.outboundRules",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            }, loadBalancingRules: {
                serializedName: "properties.loadBalancingRules",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            }, privateIPAddress: {
                serializedName: "properties.privateIPAddress",
                type: {
                    name: "String"
                }
            }, privateIPAllocationMethod: {
                serializedName: "properties.privateIPAllocationMethod",
                type: {
                    name: "String"
                }
            }, privateIPAddressVersion: {
                serializedName: "properties.privateIPAddressVersion",
                type: {
                    name: "String"
                }
            }, subnet: {
                serializedName: "properties.subnet",
                type: {
                    name: "Composite",
                    className: "Subnet"
                }
            }, publicIPAddress: {
                serializedName: "properties.publicIPAddress",
                type: {
                    name: "Composite",
                    className: "PublicIPAddress"
                }
            }, publicIPPrefix: {
                serializedName: "properties.publicIPPrefix",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, gatewayLoadBalancer: {
                serializedName: "properties.gatewayLoadBalancer",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const BackendAddressPool = {
    type: {
        name: "Composite",
        className: "BackendAddressPool",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, location: {
                serializedName: "properties.location",
                type: {
                    name: "String"
                }
            }, tunnelInterfaces: {
                serializedName: "properties.tunnelInterfaces",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "GatewayLoadBalancerTunnelInterface"
                        }
                    }
                }
            }, loadBalancerBackendAddresses: {
                serializedName: "properties.loadBalancerBackendAddresses",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "LoadBalancerBackendAddress"
                        }
                    }
                }
            }, backendIPConfigurations: {
                serializedName: "properties.backendIPConfigurations",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "NetworkInterfaceIPConfiguration"
                        }
                    }
                }
            }, loadBalancingRules: {
                serializedName: "properties.loadBalancingRules",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            }, outboundRule: {
                serializedName: "properties.outboundRule",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, outboundRules: {
                serializedName: "properties.outboundRules",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            }, inboundNatRules: {
                serializedName: "properties.inboundNatRules",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const InboundNatRule = {
    type: {
        name: "Composite",
        className: "InboundNatRule",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, frontendIPConfiguration: {
                serializedName: "properties.frontendIPConfiguration",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, backendIPConfiguration: {
                serializedName: "properties.backendIPConfiguration",
                type: {
                    name: "Composite",
                    className: "NetworkInterfaceIPConfiguration"
                }
            }, protocol: {
                serializedName: "properties.protocol",
                type: {
                    name: "String"
                }
            }, frontendPort: {
                serializedName: "properties.frontendPort",
                type: {
                    name: "Number"
                }
            }, backendPort: {
                serializedName: "properties.backendPort",
                type: {
                    name: "Number"
                }
            }, idleTimeoutInMinutes: {
                serializedName: "properties.idleTimeoutInMinutes",
                type: {
                    name: "Number"
                }
            }, enableFloatingIP: {
                serializedName: "properties.enableFloatingIP",
                type: {
                    name: "Boolean"
                }
            }, enableTcpReset: {
                serializedName: "properties.enableTcpReset",
                type: {
                    name: "Boolean"
                }
            }, frontendPortRangeStart: {
                serializedName: "properties.frontendPortRangeStart",
                type: {
                    name: "Number"
                }
            }, frontendPortRangeEnd: {
                serializedName: "properties.frontendPortRangeEnd",
                type: {
                    name: "Number"
                }
            }, backendAddressPool: {
                serializedName: "properties.backendAddressPool",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const NetworkInterfaceIPConfiguration = {
    type: {
        name: "Composite",
        className: "NetworkInterfaceIPConfiguration",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            }, gatewayLoadBalancer: {
                serializedName: "properties.gatewayLoadBalancer",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, virtualNetworkTaps: {
                serializedName: "properties.virtualNetworkTaps",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualNetworkTap"
                        }
                    }
                }
            }, applicationGatewayBackendAddressPools: {
                serializedName: "properties.applicationGatewayBackendAddressPools",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationGatewayBackendAddressPool"
                        }
                    }
                }
            }, loadBalancerBackendAddressPools: {
                serializedName: "properties.loadBalancerBackendAddressPools",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "BackendAddressPool"
                        }
                    }
                }
            }, loadBalancerInboundNatRules: {
                serializedName: "properties.loadBalancerInboundNatRules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "InboundNatRule"
                        }
                    }
                }
            }, privateIPAddress: {
                serializedName: "properties.privateIPAddress",
                type: {
                    name: "String"
                }
            }, privateIPAllocationMethod: {
                serializedName: "properties.privateIPAllocationMethod",
                type: {
                    name: "String"
                }
            }, privateIPAddressVersion: {
                serializedName: "properties.privateIPAddressVersion",
                type: {
                    name: "String"
                }
            }, subnet: {
                serializedName: "properties.subnet",
                type: {
                    name: "Composite",
                    className: "Subnet"
                }
            }, primary: {
                serializedName: "properties.primary",
                type: {
                    name: "Boolean"
                }
            }, publicIPAddress: {
                serializedName: "properties.publicIPAddress",
                type: {
                    name: "Composite",
                    className: "PublicIPAddress"
                }
            }, applicationSecurityGroups: {
                serializedName: "properties.applicationSecurityGroups",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationSecurityGroup"
                        }
                    }
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, privateLinkConnectionProperties: {
                serializedName: "properties.privateLinkConnectionProperties",
                type: {
                    name: "Composite",
                    className: "NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties"
                }
            } })
    }
};
const ApplicationGatewayBackendAddressPool = {
    type: {
        name: "Composite",
        className: "ApplicationGatewayBackendAddressPool",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, backendIPConfigurations: {
                serializedName: "properties.backendIPConfigurations",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "NetworkInterfaceIPConfiguration"
                        }
                    }
                }
            }, backendAddresses: {
                serializedName: "properties.backendAddresses",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationGatewayBackendAddress"
                        }
                    }
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const ApplicationGatewayBackendHttpSettings = {
    type: {
        name: "Composite",
        className: "ApplicationGatewayBackendHttpSettings",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, port: {
                serializedName: "properties.port",
                type: {
                    name: "Number"
                }
            }, protocol: {
                serializedName: "properties.protocol",
                type: {
                    name: "String"
                }
            }, cookieBasedAffinity: {
                serializedName: "properties.cookieBasedAffinity",
                type: {
                    name: "String"
                }
            }, requestTimeout: {
                serializedName: "properties.requestTimeout",
                type: {
                    name: "Number"
                }
            }, probe: {
                serializedName: "properties.probe",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, authenticationCertificates: {
                serializedName: "properties.authenticationCertificates",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            }, trustedRootCertificates: {
                serializedName: "properties.trustedRootCertificates",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            }, connectionDraining: {
                serializedName: "properties.connectionDraining",
                type: {
                    name: "Composite",
                    className: "ApplicationGatewayConnectionDraining"
                }
            }, hostName: {
                serializedName: "properties.hostName",
                type: {
                    name: "String"
                }
            }, pickHostNameFromBackendAddress: {
                serializedName: "properties.pickHostNameFromBackendAddress",
                type: {
                    name: "Boolean"
                }
            }, affinityCookieName: {
                serializedName: "properties.affinityCookieName",
                type: {
                    name: "String"
                }
            }, probeEnabled: {
                serializedName: "properties.probeEnabled",
                type: {
                    name: "Boolean"
                }
            }, path: {
                serializedName: "properties.path",
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const ApplicationGatewayHttpListener = {
    type: {
        name: "Composite",
        className: "ApplicationGatewayHttpListener",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, frontendIPConfiguration: {
                serializedName: "properties.frontendIPConfiguration",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, frontendPort: {
                serializedName: "properties.frontendPort",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, protocol: {
                serializedName: "properties.protocol",
                type: {
                    name: "String"
                }
            }, hostName: {
                serializedName: "properties.hostName",
                type: {
                    name: "String"
                }
            }, sslCertificate: {
                serializedName: "properties.sslCertificate",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, sslProfile: {
                serializedName: "properties.sslProfile",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, requireServerNameIndication: {
                serializedName: "properties.requireServerNameIndication",
                type: {
                    name: "Boolean"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, customErrorConfigurations: {
                serializedName: "properties.customErrorConfigurations",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationGatewayCustomError"
                        }
                    }
                }
            }, firewallPolicy: {
                serializedName: "properties.firewallPolicy",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, hostNames: {
                serializedName: "properties.hostNames",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            } })
    }
};
const ApplicationGatewaySslProfile = {
    type: {
        name: "Composite",
        className: "ApplicationGatewaySslProfile",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, trustedClientCertificates: {
                serializedName: "properties.trustedClientCertificates",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            }, sslPolicy: {
                serializedName: "properties.sslPolicy",
                type: {
                    name: "Composite",
                    className: "ApplicationGatewaySslPolicy"
                }
            }, clientAuthConfiguration: {
                serializedName: "properties.clientAuthConfiguration",
                type: {
                    name: "Composite",
                    className: "ApplicationGatewayClientAuthConfiguration"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const ApplicationGatewayPathRule = {
    type: {
        name: "Composite",
        className: "ApplicationGatewayPathRule",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, paths: {
                serializedName: "properties.paths",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, backendAddressPool: {
                serializedName: "properties.backendAddressPool",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, backendHttpSettings: {
                serializedName: "properties.backendHttpSettings",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, redirectConfiguration: {
                serializedName: "properties.redirectConfiguration",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, rewriteRuleSet: {
                serializedName: "properties.rewriteRuleSet",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, loadDistributionPolicy: {
                serializedName: "properties.loadDistributionPolicy",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, firewallPolicy: {
                serializedName: "properties.firewallPolicy",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            } })
    }
};
const ApplicationGatewayUrlPathMap = {
    type: {
        name: "Composite",
        className: "ApplicationGatewayUrlPathMap",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, defaultBackendAddressPool: {
                serializedName: "properties.defaultBackendAddressPool",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, defaultBackendHttpSettings: {
                serializedName: "properties.defaultBackendHttpSettings",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, defaultRewriteRuleSet: {
                serializedName: "properties.defaultRewriteRuleSet",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, defaultRedirectConfiguration: {
                serializedName: "properties.defaultRedirectConfiguration",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, defaultLoadDistributionPolicy: {
                serializedName: "properties.defaultLoadDistributionPolicy",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, pathRules: {
                serializedName: "properties.pathRules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationGatewayPathRule"
                        }
                    }
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const ApplicationGatewayRequestRoutingRule = {
    type: {
        name: "Composite",
        className: "ApplicationGatewayRequestRoutingRule",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, ruleType: {
                serializedName: "properties.ruleType",
                type: {
                    name: "String"
                }
            }, priority: {
                constraints: {
                    InclusiveMaximum: 20000,
                    InclusiveMinimum: 1
                },
                serializedName: "properties.priority",
                type: {
                    name: "Number"
                }
            }, backendAddressPool: {
                serializedName: "properties.backendAddressPool",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, backendHttpSettings: {
                serializedName: "properties.backendHttpSettings",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, httpListener: {
                serializedName: "properties.httpListener",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, urlPathMap: {
                serializedName: "properties.urlPathMap",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, rewriteRuleSet: {
                serializedName: "properties.rewriteRuleSet",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, redirectConfiguration: {
                serializedName: "properties.redirectConfiguration",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, loadDistributionPolicy: {
                serializedName: "properties.loadDistributionPolicy",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const ApplicationGatewayRewriteRuleSet = {
    type: {
        name: "Composite",
        className: "ApplicationGatewayRewriteRuleSet",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, rewriteRules: {
                serializedName: "properties.rewriteRules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationGatewayRewriteRule"
                        }
                    }
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const ApplicationGatewayRedirectConfiguration = {
    type: {
        name: "Composite",
        className: "ApplicationGatewayRedirectConfiguration",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, redirectType: {
                serializedName: "properties.redirectType",
                type: {
                    name: "String"
                }
            }, targetListener: {
                serializedName: "properties.targetListener",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, targetUrl: {
                serializedName: "properties.targetUrl",
                type: {
                    name: "String"
                }
            }, includePath: {
                serializedName: "properties.includePath",
                type: {
                    name: "Boolean"
                }
            }, includeQueryString: {
                serializedName: "properties.includeQueryString",
                type: {
                    name: "Boolean"
                }
            }, requestRoutingRules: {
                serializedName: "properties.requestRoutingRules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            }, urlPathMaps: {
                serializedName: "properties.urlPathMaps",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            }, pathRules: {
                serializedName: "properties.pathRules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            } })
    }
};
const ApplicationGatewayPrivateLinkIpConfiguration = {
    type: {
        name: "Composite",
        className: "ApplicationGatewayPrivateLinkIpConfiguration",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, privateIPAddress: {
                serializedName: "properties.privateIPAddress",
                type: {
                    name: "String"
                }
            }, privateIPAllocationMethod: {
                serializedName: "properties.privateIPAllocationMethod",
                type: {
                    name: "String"
                }
            }, subnet: {
                serializedName: "properties.subnet",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, primary: {
                serializedName: "properties.primary",
                type: {
                    name: "Boolean"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const ApplicationGatewayPrivateLinkConfiguration = {
    type: {
        name: "Composite",
        className: "ApplicationGatewayPrivateLinkConfiguration",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, ipConfigurations: {
                serializedName: "properties.ipConfigurations",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationGatewayPrivateLinkIpConfiguration"
                        }
                    }
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const ApplicationGatewayPrivateEndpointConnection = {
    type: {
        name: "Composite",
        className: "ApplicationGatewayPrivateEndpointConnection",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, privateEndpoint: {
                serializedName: "properties.privateEndpoint",
                type: {
                    name: "Composite",
                    className: "PrivateEndpoint"
                }
            }, privateLinkServiceConnectionState: {
                serializedName: "properties.privateLinkServiceConnectionState",
                type: {
                    name: "Composite",
                    className: "PrivateLinkServiceConnectionState"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, linkIdentifier: {
                serializedName: "properties.linkIdentifier",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const ApplicationGatewayLoadDistributionTarget = {
    type: {
        name: "Composite",
        className: "ApplicationGatewayLoadDistributionTarget",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, weightPerServer: {
                constraints: {
                    InclusiveMaximum: 100,
                    InclusiveMinimum: 1
                },
                serializedName: "properties.weightPerServer",
                type: {
                    name: "Number"
                }
            }, backendAddressPool: {
                serializedName: "properties.backendAddressPool",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            } })
    }
};
const ApplicationGatewayLoadDistributionPolicy = {
    type: {
        name: "Composite",
        className: "ApplicationGatewayLoadDistributionPolicy",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, loadDistributionTargets: {
                serializedName: "properties.loadDistributionTargets",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationGatewayLoadDistributionTarget"
                        }
                    }
                }
            }, loadDistributionAlgorithm: {
                serializedName: "properties.loadDistributionAlgorithm",
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const ApplicationGatewayPrivateLinkResource = {
    type: {
        name: "Composite",
        className: "ApplicationGatewayPrivateLinkResource",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, groupId: {
                serializedName: "properties.groupId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, requiredMembers: {
                serializedName: "properties.requiredMembers",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, requiredZoneNames: {
                serializedName: "properties.requiredZoneNames",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            } })
    }
};
const ApplicationGatewaySslPredefinedPolicy = {
    type: {
        name: "Composite",
        className: "ApplicationGatewaySslPredefinedPolicy",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, cipherSuites: {
                serializedName: "properties.cipherSuites",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, minProtocolVersion: {
                serializedName: "properties.minProtocolVersion",
                type: {
                    name: "String"
                }
            } })
    }
};
const AzureFirewallApplicationRuleCollection = {
    type: {
        name: "Composite",
        className: "AzureFirewallApplicationRuleCollection",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, priority: {
                constraints: {
                    InclusiveMaximum: 65000,
                    InclusiveMinimum: 100
                },
                serializedName: "properties.priority",
                type: {
                    name: "Number"
                }
            }, action: {
                serializedName: "properties.action",
                type: {
                    name: "Composite",
                    className: "AzureFirewallRCAction"
                }
            }, rules: {
                serializedName: "properties.rules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AzureFirewallApplicationRule"
                        }
                    }
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const AzureFirewallNatRuleCollection = {
    type: {
        name: "Composite",
        className: "AzureFirewallNatRuleCollection",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, priority: {
                constraints: {
                    InclusiveMaximum: 65000,
                    InclusiveMinimum: 100
                },
                serializedName: "properties.priority",
                type: {
                    name: "Number"
                }
            }, action: {
                serializedName: "properties.action",
                type: {
                    name: "Composite",
                    className: "AzureFirewallNatRCAction"
                }
            }, rules: {
                serializedName: "properties.rules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AzureFirewallNatRule"
                        }
                    }
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const AzureFirewallNetworkRuleCollection = {
    type: {
        name: "Composite",
        className: "AzureFirewallNetworkRuleCollection",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, priority: {
                constraints: {
                    InclusiveMaximum: 65000,
                    InclusiveMinimum: 100
                },
                serializedName: "properties.priority",
                type: {
                    name: "Number"
                }
            }, action: {
                serializedName: "properties.action",
                type: {
                    name: "Composite",
                    className: "AzureFirewallRCAction"
                }
            }, rules: {
                serializedName: "properties.rules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AzureFirewallNetworkRule"
                        }
                    }
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const AzureFirewallIPConfiguration = {
    type: {
        name: "Composite",
        className: "AzureFirewallIPConfiguration",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, privateIPAddress: {
                serializedName: "properties.privateIPAddress",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, subnet: {
                serializedName: "properties.subnet",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, publicIPAddress: {
                serializedName: "properties.publicIPAddress",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const BastionHostIPConfiguration = {
    type: {
        name: "Composite",
        className: "BastionHostIPConfiguration",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, subnet: {
                serializedName: "properties.subnet",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, publicIPAddress: {
                serializedName: "properties.publicIPAddress",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, privateIPAllocationMethod: {
                serializedName: "properties.privateIPAllocationMethod",
                type: {
                    name: "String"
                }
            } })
    }
};
const EndpointServiceResult = {
    type: {
        name: "Composite",
        className: "EndpointServiceResult",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const ExpressRouteCircuitAuthorization = {
    type: {
        name: "Composite",
        className: "ExpressRouteCircuitAuthorization",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, authorizationKey: {
                serializedName: "properties.authorizationKey",
                type: {
                    name: "String"
                }
            }, authorizationUseStatus: {
                serializedName: "properties.authorizationUseStatus",
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const ExpressRouteCircuitConnection = {
    type: {
        name: "Composite",
        className: "ExpressRouteCircuitConnection",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, expressRouteCircuitPeering: {
                serializedName: "properties.expressRouteCircuitPeering",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, peerExpressRouteCircuitPeering: {
                serializedName: "properties.peerExpressRouteCircuitPeering",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, addressPrefix: {
                serializedName: "properties.addressPrefix",
                type: {
                    name: "String"
                }
            }, authorizationKey: {
                serializedName: "properties.authorizationKey",
                type: {
                    name: "String"
                }
            }, ipv6CircuitConnectionConfig: {
                serializedName: "properties.ipv6CircuitConnectionConfig",
                type: {
                    name: "Composite",
                    className: "Ipv6CircuitConnectionConfig"
                }
            }, circuitConnectionStatus: {
                serializedName: "properties.circuitConnectionStatus",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const PeerExpressRouteCircuitConnection = {
    type: {
        name: "Composite",
        className: "PeerExpressRouteCircuitConnection",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, expressRouteCircuitPeering: {
                serializedName: "properties.expressRouteCircuitPeering",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, peerExpressRouteCircuitPeering: {
                serializedName: "properties.peerExpressRouteCircuitPeering",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, addressPrefix: {
                serializedName: "properties.addressPrefix",
                type: {
                    name: "String"
                }
            }, circuitConnectionStatus: {
                serializedName: "properties.circuitConnectionStatus",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, connectionName: {
                serializedName: "properties.connectionName",
                type: {
                    name: "String"
                }
            }, authResourceGuid: {
                serializedName: "properties.authResourceGuid",
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const ExpressRouteCircuitPeering = {
    type: {
        name: "Composite",
        className: "ExpressRouteCircuitPeering",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, peeringType: {
                serializedName: "properties.peeringType",
                type: {
                    name: "String"
                }
            }, state: {
                serializedName: "properties.state",
                type: {
                    name: "String"
                }
            }, azureASN: {
                serializedName: "properties.azureASN",
                type: {
                    name: "Number"
                }
            }, peerASN: {
                constraints: {
                    InclusiveMaximum: 4294967295,
                    InclusiveMinimum: 1
                },
                serializedName: "properties.peerASN",
                type: {
                    name: "Number"
                }
            }, primaryPeerAddressPrefix: {
                serializedName: "properties.primaryPeerAddressPrefix",
                type: {
                    name: "String"
                }
            }, secondaryPeerAddressPrefix: {
                serializedName: "properties.secondaryPeerAddressPrefix",
                type: {
                    name: "String"
                }
            }, primaryAzurePort: {
                serializedName: "properties.primaryAzurePort",
                type: {
                    name: "String"
                }
            }, secondaryAzurePort: {
                serializedName: "properties.secondaryAzurePort",
                type: {
                    name: "String"
                }
            }, sharedKey: {
                serializedName: "properties.sharedKey",
                type: {
                    name: "String"
                }
            }, vlanId: {
                serializedName: "properties.vlanId",
                type: {
                    name: "Number"
                }
            }, microsoftPeeringConfig: {
                serializedName: "properties.microsoftPeeringConfig",
                type: {
                    name: "Composite",
                    className: "ExpressRouteCircuitPeeringConfig"
                }
            }, stats: {
                serializedName: "properties.stats",
                type: {
                    name: "Composite",
                    className: "ExpressRouteCircuitStats"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, gatewayManagerEtag: {
                serializedName: "properties.gatewayManagerEtag",
                type: {
                    name: "String"
                }
            }, lastModifiedBy: {
                serializedName: "properties.lastModifiedBy",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, routeFilter: {
                serializedName: "properties.routeFilter",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, ipv6PeeringConfig: {
                serializedName: "properties.ipv6PeeringConfig",
                type: {
                    name: "Composite",
                    className: "Ipv6ExpressRouteCircuitPeeringConfig"
                }
            }, expressRouteConnection: {
                serializedName: "properties.expressRouteConnection",
                type: {
                    name: "Composite",
                    className: "ExpressRouteConnectionId"
                }
            }, connections: {
                serializedName: "properties.connections",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ExpressRouteCircuitConnection"
                        }
                    }
                }
            }, peeredConnections: {
                serializedName: "properties.peeredConnections",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PeerExpressRouteCircuitConnection"
                        }
                    }
                }
            } })
    }
};
const ExpressRouteCrossConnectionPeering = {
    type: {
        name: "Composite",
        className: "ExpressRouteCrossConnectionPeering",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, peeringType: {
                serializedName: "properties.peeringType",
                type: {
                    name: "String"
                }
            }, state: {
                serializedName: "properties.state",
                type: {
                    name: "String"
                }
            }, azureASN: {
                serializedName: "properties.azureASN",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, peerASN: {
                constraints: {
                    InclusiveMaximum: 4294967295,
                    InclusiveMinimum: 1
                },
                serializedName: "properties.peerASN",
                type: {
                    name: "Number"
                }
            }, primaryPeerAddressPrefix: {
                serializedName: "properties.primaryPeerAddressPrefix",
                type: {
                    name: "String"
                }
            }, secondaryPeerAddressPrefix: {
                serializedName: "properties.secondaryPeerAddressPrefix",
                type: {
                    name: "String"
                }
            }, primaryAzurePort: {
                serializedName: "properties.primaryAzurePort",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, secondaryAzurePort: {
                serializedName: "properties.secondaryAzurePort",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, sharedKey: {
                serializedName: "properties.sharedKey",
                type: {
                    name: "String"
                }
            }, vlanId: {
                serializedName: "properties.vlanId",
                type: {
                    name: "Number"
                }
            }, microsoftPeeringConfig: {
                serializedName: "properties.microsoftPeeringConfig",
                type: {
                    name: "Composite",
                    className: "ExpressRouteCircuitPeeringConfig"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, gatewayManagerEtag: {
                serializedName: "properties.gatewayManagerEtag",
                type: {
                    name: "String"
                }
            }, lastModifiedBy: {
                serializedName: "properties.lastModifiedBy",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, ipv6PeeringConfig: {
                serializedName: "properties.ipv6PeeringConfig",
                type: {
                    name: "Composite",
                    className: "Ipv6ExpressRouteCircuitPeeringConfig"
                }
            } })
    }
};
const ExpressRouteLink = {
    type: {
        name: "Composite",
        className: "ExpressRouteLink",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, routerName: {
                serializedName: "properties.routerName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, interfaceName: {
                serializedName: "properties.interfaceName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, patchPanelId: {
                serializedName: "properties.patchPanelId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, rackId: {
                serializedName: "properties.rackId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, connectorType: {
                serializedName: "properties.connectorType",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, adminState: {
                serializedName: "properties.adminState",
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, macSecConfig: {
                serializedName: "properties.macSecConfig",
                type: {
                    name: "Composite",
                    className: "ExpressRouteLinkMacSecConfig"
                }
            } })
    }
};
const FirewallPolicyRuleCollectionGroup = {
    type: {
        name: "Composite",
        className: "FirewallPolicyRuleCollectionGroup",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, priority: {
                constraints: {
                    InclusiveMaximum: 65000,
                    InclusiveMinimum: 100
                },
                serializedName: "properties.priority",
                type: {
                    name: "Number"
                }
            }, ruleCollections: {
                serializedName: "properties.ruleCollections",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "FirewallPolicyRuleCollection"
                        }
                    }
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const LoadBalancingRule = {
    type: {
        name: "Composite",
        className: "LoadBalancingRule",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, frontendIPConfiguration: {
                serializedName: "properties.frontendIPConfiguration",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, backendAddressPool: {
                serializedName: "properties.backendAddressPool",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, backendAddressPools: {
                serializedName: "properties.backendAddressPools",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            }, probe: {
                serializedName: "properties.probe",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, protocol: {
                serializedName: "properties.protocol",
                type: {
                    name: "String"
                }
            }, loadDistribution: {
                serializedName: "properties.loadDistribution",
                type: {
                    name: "String"
                }
            }, frontendPort: {
                serializedName: "properties.frontendPort",
                type: {
                    name: "Number"
                }
            }, backendPort: {
                serializedName: "properties.backendPort",
                type: {
                    name: "Number"
                }
            }, idleTimeoutInMinutes: {
                serializedName: "properties.idleTimeoutInMinutes",
                type: {
                    name: "Number"
                }
            }, enableFloatingIP: {
                serializedName: "properties.enableFloatingIP",
                type: {
                    name: "Boolean"
                }
            }, enableTcpReset: {
                serializedName: "properties.enableTcpReset",
                type: {
                    name: "Boolean"
                }
            }, disableOutboundSnat: {
                serializedName: "properties.disableOutboundSnat",
                type: {
                    name: "Boolean"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const Probe = {
    type: {
        name: "Composite",
        className: "Probe",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, loadBalancingRules: {
                serializedName: "properties.loadBalancingRules",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            }, protocol: {
                serializedName: "properties.protocol",
                type: {
                    name: "String"
                }
            }, port: {
                serializedName: "properties.port",
                type: {
                    name: "Number"
                }
            }, intervalInSeconds: {
                serializedName: "properties.intervalInSeconds",
                type: {
                    name: "Number"
                }
            }, numberOfProbes: {
                serializedName: "properties.numberOfProbes",
                type: {
                    name: "Number"
                }
            }, requestPath: {
                serializedName: "properties.requestPath",
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const InboundNatPool = {
    type: {
        name: "Composite",
        className: "InboundNatPool",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, frontendIPConfiguration: {
                serializedName: "properties.frontendIPConfiguration",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, protocol: {
                serializedName: "properties.protocol",
                type: {
                    name: "String"
                }
            }, frontendPortRangeStart: {
                serializedName: "properties.frontendPortRangeStart",
                type: {
                    name: "Number"
                }
            }, frontendPortRangeEnd: {
                serializedName: "properties.frontendPortRangeEnd",
                type: {
                    name: "Number"
                }
            }, backendPort: {
                serializedName: "properties.backendPort",
                type: {
                    name: "Number"
                }
            }, idleTimeoutInMinutes: {
                serializedName: "properties.idleTimeoutInMinutes",
                type: {
                    name: "Number"
                }
            }, enableFloatingIP: {
                serializedName: "properties.enableFloatingIP",
                type: {
                    name: "Boolean"
                }
            }, enableTcpReset: {
                serializedName: "properties.enableTcpReset",
                type: {
                    name: "Boolean"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const OutboundRule = {
    type: {
        name: "Composite",
        className: "OutboundRule",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, allocatedOutboundPorts: {
                serializedName: "properties.allocatedOutboundPorts",
                type: {
                    name: "Number"
                }
            }, frontendIPConfigurations: {
                serializedName: "properties.frontendIPConfigurations",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            }, backendAddressPool: {
                serializedName: "properties.backendAddressPool",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, protocol: {
                serializedName: "properties.protocol",
                type: {
                    name: "String"
                }
            }, enableTcpReset: {
                serializedName: "properties.enableTcpReset",
                type: {
                    name: "Boolean"
                }
            }, idleTimeoutInMinutes: {
                serializedName: "properties.idleTimeoutInMinutes",
                type: {
                    name: "Number"
                }
            } })
    }
};
const ContainerNetworkInterfaceConfiguration = {
    type: {
        name: "Composite",
        className: "ContainerNetworkInterfaceConfiguration",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, ipConfigurations: {
                serializedName: "properties.ipConfigurations",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "IPConfigurationProfile"
                        }
                    }
                }
            }, containerNetworkInterfaces: {
                serializedName: "properties.containerNetworkInterfaces",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const Container = {
    type: {
        name: "Composite",
        className: "Container",
        modelProperties: Object.assign({}, SubResource.type.modelProperties)
    }
};
const ContainerNetworkInterface = {
    type: {
        name: "Composite",
        className: "ContainerNetworkInterface",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, containerNetworkInterfaceConfiguration: {
                serializedName: "properties.containerNetworkInterfaceConfiguration",
                type: {
                    name: "Composite",
                    className: "ContainerNetworkInterfaceConfiguration"
                }
            }, container: {
                serializedName: "properties.container",
                type: {
                    name: "Composite",
                    className: "Container"
                }
            }, ipConfigurations: {
                serializedName: "properties.ipConfigurations",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ContainerNetworkInterfaceIpConfiguration"
                        }
                    }
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const VirtualApplianceSite = {
    type: {
        name: "Composite",
        className: "VirtualApplianceSite",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, addressPrefix: {
                serializedName: "properties.addressPrefix",
                type: {
                    name: "String"
                }
            }, o365Policy: {
                serializedName: "properties.o365Policy",
                type: {
                    name: "Composite",
                    className: "Office365PolicyProperties"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const InboundSecurityRule = {
    type: {
        name: "Composite",
        className: "InboundSecurityRule",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, rules: {
                serializedName: "properties.rules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "InboundSecurityRules"
                        }
                    }
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const PrivateDnsZoneGroup = {
    type: {
        name: "Composite",
        className: "PrivateDnsZoneGroup",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, privateDnsZoneConfigs: {
                serializedName: "properties.privateDnsZoneConfigs",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PrivateDnsZoneConfig"
                        }
                    }
                }
            } })
    }
};
const RouteFilterRule = {
    type: {
        name: "Composite",
        className: "RouteFilterRule",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, access: {
                serializedName: "properties.access",
                type: {
                    name: "String"
                }
            }, routeFilterRuleType: {
                serializedName: "properties.routeFilterRuleType",
                type: {
                    name: "String"
                }
            }, communities: {
                serializedName: "properties.communities",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const VirtualNetworkPeering = {
    type: {
        name: "Composite",
        className: "VirtualNetworkPeering",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            }, allowVirtualNetworkAccess: {
                serializedName: "properties.allowVirtualNetworkAccess",
                type: {
                    name: "Boolean"
                }
            }, allowForwardedTraffic: {
                serializedName: "properties.allowForwardedTraffic",
                type: {
                    name: "Boolean"
                }
            }, allowGatewayTransit: {
                serializedName: "properties.allowGatewayTransit",
                type: {
                    name: "Boolean"
                }
            }, useRemoteGateways: {
                serializedName: "properties.useRemoteGateways",
                type: {
                    name: "Boolean"
                }
            }, remoteVirtualNetwork: {
                serializedName: "properties.remoteVirtualNetwork",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, remoteAddressSpace: {
                serializedName: "properties.remoteAddressSpace",
                type: {
                    name: "Composite",
                    className: "AddressSpace"
                }
            }, remoteVirtualNetworkAddressSpace: {
                serializedName: "properties.remoteVirtualNetworkAddressSpace",
                type: {
                    name: "Composite",
                    className: "AddressSpace"
                }
            }, remoteBgpCommunities: {
                serializedName: "properties.remoteBgpCommunities",
                type: {
                    name: "Composite",
                    className: "VirtualNetworkBgpCommunities"
                }
            }, remoteVirtualNetworkEncryption: {
                serializedName: "properties.remoteVirtualNetworkEncryption",
                type: {
                    name: "Composite",
                    className: "VirtualNetworkEncryption"
                }
            }, peeringState: {
                serializedName: "properties.peeringState",
                type: {
                    name: "String"
                }
            }, peeringSyncLevel: {
                serializedName: "properties.peeringSyncLevel",
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, doNotVerifyRemoteGateways: {
                serializedName: "properties.doNotVerifyRemoteGateways",
                type: {
                    name: "Boolean"
                }
            }, resourceGuid: {
                serializedName: "properties.resourceGuid",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const VirtualNetworkGatewayIPConfiguration = {
    type: {
        name: "Composite",
        className: "VirtualNetworkGatewayIPConfiguration",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, privateIPAllocationMethod: {
                serializedName: "properties.privateIPAllocationMethod",
                type: {
                    name: "String"
                }
            }, subnet: {
                serializedName: "properties.subnet",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, publicIPAddress: {
                serializedName: "properties.publicIPAddress",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, privateIPAddress: {
                serializedName: "properties.privateIPAddress",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const VpnClientRootCertificate = {
    type: {
        name: "Composite",
        className: "VpnClientRootCertificate",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, publicCertData: {
                serializedName: "properties.publicCertData",
                required: true,
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const VpnClientRevokedCertificate = {
    type: {
        name: "Composite",
        className: "VpnClientRevokedCertificate",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, thumbprint: {
                serializedName: "properties.thumbprint",
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const VirtualNetworkGatewayNatRule = {
    type: {
        name: "Composite",
        className: "VirtualNetworkGatewayNatRule",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, typePropertiesType: {
                serializedName: "properties.type",
                type: {
                    name: "String"
                }
            }, mode: {
                serializedName: "properties.mode",
                type: {
                    name: "String"
                }
            }, internalMappings: {
                serializedName: "properties.internalMappings",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VpnNatRuleMapping"
                        }
                    }
                }
            }, externalMappings: {
                serializedName: "properties.externalMappings",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VpnNatRuleMapping"
                        }
                    }
                }
            }, ipConfigurationId: {
                serializedName: "properties.ipConfigurationId",
                type: {
                    name: "String"
                }
            } })
    }
};
const ConnectionSharedKey = {
    type: {
        name: "Composite",
        className: "ConnectionSharedKey",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const VirtualRouterPeering = {
    type: {
        name: "Composite",
        className: "VirtualRouterPeering",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, peerAsn: {
                constraints: {
                    InclusiveMaximum: 4294967295,
                    InclusiveMinimum: 0
                },
                serializedName: "properties.peerAsn",
                type: {
                    name: "Number"
                }
            }, peerIp: {
                serializedName: "properties.peerIp",
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const VpnSiteLink = {
    type: {
        name: "Composite",
        className: "VpnSiteLink",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, linkProperties: {
                serializedName: "properties.linkProperties",
                type: {
                    name: "Composite",
                    className: "VpnLinkProviderProperties"
                }
            }, ipAddress: {
                serializedName: "properties.ipAddress",
                type: {
                    name: "String"
                }
            }, fqdn: {
                serializedName: "properties.fqdn",
                type: {
                    name: "String"
                }
            }, bgpProperties: {
                serializedName: "properties.bgpProperties",
                type: {
                    name: "Composite",
                    className: "VpnLinkBgpSettings"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const P2SConnectionConfiguration = {
    type: {
        name: "Composite",
        className: "P2SConnectionConfiguration",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, vpnClientAddressPool: {
                serializedName: "properties.vpnClientAddressPool",
                type: {
                    name: "Composite",
                    className: "AddressSpace"
                }
            }, routingConfiguration: {
                serializedName: "properties.routingConfiguration",
                type: {
                    name: "Composite",
                    className: "RoutingConfiguration"
                }
            }, enableInternetSecurity: {
                serializedName: "properties.enableInternetSecurity",
                type: {
                    name: "Boolean"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const VirtualHubRouteTableV2 = {
    type: {
        name: "Composite",
        className: "VirtualHubRouteTableV2",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, routes: {
                serializedName: "properties.routes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualHubRouteV2"
                        }
                    }
                }
            }, attachedConnections: {
                serializedName: "properties.attachedConnections",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const HubVirtualNetworkConnection = {
    type: {
        name: "Composite",
        className: "HubVirtualNetworkConnection",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, remoteVirtualNetwork: {
                serializedName: "properties.remoteVirtualNetwork",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, allowHubToRemoteVnetTransit: {
                serializedName: "properties.allowHubToRemoteVnetTransit",
                type: {
                    name: "Boolean"
                }
            }, allowRemoteVnetToUseHubVnetGateways: {
                serializedName: "properties.allowRemoteVnetToUseHubVnetGateways",
                type: {
                    name: "Boolean"
                }
            }, enableInternetSecurity: {
                serializedName: "properties.enableInternetSecurity",
                type: {
                    name: "Boolean"
                }
            }, routingConfiguration: {
                serializedName: "properties.routingConfiguration",
                type: {
                    name: "Composite",
                    className: "RoutingConfiguration"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const VpnSiteLinkConnection = {
    type: {
        name: "Composite",
        className: "VpnSiteLinkConnection",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, vpnSiteLink: {
                serializedName: "properties.vpnSiteLink",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, routingWeight: {
                serializedName: "properties.routingWeight",
                type: {
                    name: "Number"
                }
            }, vpnLinkConnectionMode: {
                serializedName: "properties.vpnLinkConnectionMode",
                type: {
                    name: "String"
                }
            }, connectionStatus: {
                serializedName: "properties.connectionStatus",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, vpnConnectionProtocolType: {
                serializedName: "properties.vpnConnectionProtocolType",
                type: {
                    name: "String"
                }
            }, ingressBytesTransferred: {
                serializedName: "properties.ingressBytesTransferred",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, egressBytesTransferred: {
                serializedName: "properties.egressBytesTransferred",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, connectionBandwidth: {
                serializedName: "properties.connectionBandwidth",
                type: {
                    name: "Number"
                }
            }, sharedKey: {
                serializedName: "properties.sharedKey",
                type: {
                    name: "String"
                }
            }, enableBgp: {
                serializedName: "properties.enableBgp",
                type: {
                    name: "Boolean"
                }
            }, usePolicyBasedTrafficSelectors: {
                serializedName: "properties.usePolicyBasedTrafficSelectors",
                type: {
                    name: "Boolean"
                }
            }, ipsecPolicies: {
                serializedName: "properties.ipsecPolicies",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "IpsecPolicy"
                        }
                    }
                }
            }, enableRateLimiting: {
                serializedName: "properties.enableRateLimiting",
                type: {
                    name: "Boolean"
                }
            }, useLocalAzureIpAddress: {
                serializedName: "properties.useLocalAzureIpAddress",
                type: {
                    name: "Boolean"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, ingressNatRules: {
                serializedName: "properties.ingressNatRules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            }, egressNatRules: {
                serializedName: "properties.egressNatRules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            } })
    }
};
const VpnConnection = {
    type: {
        name: "Composite",
        className: "VpnConnection",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, remoteVpnSite: {
                serializedName: "properties.remoteVpnSite",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, routingWeight: {
                serializedName: "properties.routingWeight",
                type: {
                    name: "Number"
                }
            }, dpdTimeoutSeconds: {
                serializedName: "properties.dpdTimeoutSeconds",
                type: {
                    name: "Number"
                }
            }, connectionStatus: {
                serializedName: "properties.connectionStatus",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, vpnConnectionProtocolType: {
                serializedName: "properties.vpnConnectionProtocolType",
                type: {
                    name: "String"
                }
            }, ingressBytesTransferred: {
                serializedName: "properties.ingressBytesTransferred",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, egressBytesTransferred: {
                serializedName: "properties.egressBytesTransferred",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, connectionBandwidth: {
                serializedName: "properties.connectionBandwidth",
                type: {
                    name: "Number"
                }
            }, sharedKey: {
                serializedName: "properties.sharedKey",
                type: {
                    name: "String"
                }
            }, enableBgp: {
                serializedName: "properties.enableBgp",
                type: {
                    name: "Boolean"
                }
            }, usePolicyBasedTrafficSelectors: {
                serializedName: "properties.usePolicyBasedTrafficSelectors",
                type: {
                    name: "Boolean"
                }
            }, ipsecPolicies: {
                serializedName: "properties.ipsecPolicies",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "IpsecPolicy"
                        }
                    }
                }
            }, trafficSelectorPolicies: {
                serializedName: "properties.trafficSelectorPolicies",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TrafficSelectorPolicy"
                        }
                    }
                }
            }, enableRateLimiting: {
                serializedName: "properties.enableRateLimiting",
                type: {
                    name: "Boolean"
                }
            }, enableInternetSecurity: {
                serializedName: "properties.enableInternetSecurity",
                type: {
                    name: "Boolean"
                }
            }, useLocalAzureIpAddress: {
                serializedName: "properties.useLocalAzureIpAddress",
                type: {
                    name: "Boolean"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, vpnLinkConnections: {
                serializedName: "properties.vpnLinkConnections",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VpnSiteLinkConnection"
                        }
                    }
                }
            }, routingConfiguration: {
                serializedName: "properties.routingConfiguration",
                type: {
                    name: "Composite",
                    className: "RoutingConfiguration"
                }
            } })
    }
};
const VpnGatewayNatRule = {
    type: {
        name: "Composite",
        className: "VpnGatewayNatRule",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, typePropertiesType: {
                serializedName: "properties.type",
                type: {
                    name: "String"
                }
            }, mode: {
                serializedName: "properties.mode",
                type: {
                    name: "String"
                }
            }, internalMappings: {
                serializedName: "properties.internalMappings",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VpnNatRuleMapping"
                        }
                    }
                }
            }, externalMappings: {
                serializedName: "properties.externalMappings",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VpnNatRuleMapping"
                        }
                    }
                }
            }, ipConfigurationId: {
                serializedName: "properties.ipConfigurationId",
                type: {
                    name: "String"
                }
            }, egressVpnSiteLinkConnections: {
                serializedName: "properties.egressVpnSiteLinkConnections",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            }, ingressVpnSiteLinkConnections: {
                serializedName: "properties.ingressVpnSiteLinkConnections",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            } })
    }
};
const ExpressRouteConnection = {
    type: {
        name: "Composite",
        className: "ExpressRouteConnection",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, expressRouteCircuitPeering: {
                serializedName: "properties.expressRouteCircuitPeering",
                type: {
                    name: "Composite",
                    className: "ExpressRouteCircuitPeeringId"
                }
            }, authorizationKey: {
                serializedName: "properties.authorizationKey",
                type: {
                    name: "String"
                }
            }, routingWeight: {
                serializedName: "properties.routingWeight",
                type: {
                    name: "Number"
                }
            }, enableInternetSecurity: {
                serializedName: "properties.enableInternetSecurity",
                type: {
                    name: "Boolean"
                }
            }, expressRouteGatewayBypass: {
                serializedName: "properties.expressRouteGatewayBypass",
                type: {
                    name: "Boolean"
                }
            }, routingConfiguration: {
                serializedName: "properties.routingConfiguration",
                type: {
                    name: "Composite",
                    className: "RoutingConfiguration"
                }
            } })
    }
};
const BgpConnection = {
    type: {
        name: "Composite",
        className: "BgpConnection",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, peerAsn: {
                constraints: {
                    InclusiveMaximum: 4294967295,
                    InclusiveMinimum: 0
                },
                serializedName: "properties.peerAsn",
                type: {
                    name: "Number"
                }
            }, peerIp: {
                serializedName: "properties.peerIp",
                type: {
                    name: "String"
                }
            }, hubVirtualNetworkConnection: {
                serializedName: "properties.hubVirtualNetworkConnection",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, connectionState: {
                serializedName: "properties.connectionState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const HubIpConfiguration = {
    type: {
        name: "Composite",
        className: "HubIpConfiguration",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, privateIPAddress: {
                serializedName: "properties.privateIPAddress",
                type: {
                    name: "String"
                }
            }, privateIPAllocationMethod: {
                serializedName: "properties.privateIPAllocationMethod",
                type: {
                    name: "String"
                }
            }, subnet: {
                serializedName: "properties.subnet",
                type: {
                    name: "Composite",
                    className: "Subnet"
                }
            }, publicIPAddress: {
                serializedName: "properties.publicIPAddress",
                type: {
                    name: "Composite",
                    className: "PublicIPAddress"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const HubRouteTable = {
    type: {
        name: "Composite",
        className: "HubRouteTable",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, routes: {
                serializedName: "properties.routes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "HubRoute"
                        }
                    }
                }
            }, labels: {
                serializedName: "properties.labels",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, associatedConnections: {
                serializedName: "properties.associatedConnections",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, propagatingConnections: {
                serializedName: "properties.propagatingConnections",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const RoutingIntent = {
    type: {
        name: "Composite",
        className: "RoutingIntent",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, routingPolicies: {
                serializedName: "properties.routingPolicies",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RoutingPolicy"
                        }
                    }
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const PatchRouteFilterRule = {
    type: {
        name: "Composite",
        className: "PatchRouteFilterRule",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, access: {
                serializedName: "properties.access",
                type: {
                    name: "String"
                }
            }, routeFilterRuleType: {
                serializedName: "properties.routeFilterRuleType",
                type: {
                    name: "String"
                }
            }, communities: {
                serializedName: "properties.communities",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const PatchRouteFilter = {
    type: {
        name: "Composite",
        className: "PatchRouteFilter",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }, rules: {
                serializedName: "properties.rules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RouteFilterRule"
                        }
                    }
                }
            }, peerings: {
                serializedName: "properties.peerings",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ExpressRouteCircuitPeering"
                        }
                    }
                }
            }, ipv6Peerings: {
                serializedName: "properties.ipv6Peerings",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ExpressRouteCircuitPeering"
                        }
                    }
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const ApplicationSecurityGroup = {
    type: {
        name: "Composite",
        className: "ApplicationSecurityGroup",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, resourceGuid: {
                serializedName: "properties.resourceGuid",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const PrivateEndpoint = {
    type: {
        name: "Composite",
        className: "PrivateEndpoint",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { extendedLocation: {
                serializedName: "extendedLocation",
                type: {
                    name: "Composite",
                    className: "ExtendedLocation"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, subnet: {
                serializedName: "properties.subnet",
                type: {
                    name: "Composite",
                    className: "Subnet"
                }
            }, networkInterfaces: {
                serializedName: "properties.networkInterfaces",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "NetworkInterface"
                        }
                    }
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, privateLinkServiceConnections: {
                serializedName: "properties.privateLinkServiceConnections",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PrivateLinkServiceConnection"
                        }
                    }
                }
            }, manualPrivateLinkServiceConnections: {
                serializedName: "properties.manualPrivateLinkServiceConnections",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PrivateLinkServiceConnection"
                        }
                    }
                }
            }, customDnsConfigs: {
                serializedName: "properties.customDnsConfigs",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "CustomDnsConfigPropertiesFormat"
                        }
                    }
                }
            }, applicationSecurityGroups: {
                serializedName: "properties.applicationSecurityGroups",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationSecurityGroup"
                        }
                    }
                }
            }, ipConfigurations: {
                serializedName: "properties.ipConfigurations",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PrivateEndpointIPConfiguration"
                        }
                    }
                }
            }, customNetworkInterfaceName: {
                serializedName: "properties.customNetworkInterfaceName",
                type: {
                    name: "String"
                }
            } })
    }
};
const PrivateLinkService = {
    type: {
        name: "Composite",
        className: "PrivateLinkService",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { extendedLocation: {
                serializedName: "extendedLocation",
                type: {
                    name: "Composite",
                    className: "ExtendedLocation"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, loadBalancerFrontendIpConfigurations: {
                serializedName: "properties.loadBalancerFrontendIpConfigurations",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "FrontendIPConfiguration"
                        }
                    }
                }
            }, ipConfigurations: {
                serializedName: "properties.ipConfigurations",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PrivateLinkServiceIpConfiguration"
                        }
                    }
                }
            }, networkInterfaces: {
                serializedName: "properties.networkInterfaces",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "NetworkInterface"
                        }
                    }
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, privateEndpointConnections: {
                serializedName: "properties.privateEndpointConnections",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PrivateEndpointConnection"
                        }
                    }
                }
            }, visibility: {
                serializedName: "properties.visibility",
                type: {
                    name: "Composite",
                    className: "PrivateLinkServicePropertiesVisibility"
                }
            }, autoApproval: {
                serializedName: "properties.autoApproval",
                type: {
                    name: "Composite",
                    className: "PrivateLinkServicePropertiesAutoApproval"
                }
            }, fqdns: {
                serializedName: "properties.fqdns",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, alias: {
                serializedName: "properties.alias",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, enableProxyProtocol: {
                serializedName: "properties.enableProxyProtocol",
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const NetworkInterface = {
    type: {
        name: "Composite",
        className: "NetworkInterface",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { extendedLocation: {
                serializedName: "extendedLocation",
                type: {
                    name: "Composite",
                    className: "ExtendedLocation"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, virtualMachine: {
                serializedName: "properties.virtualMachine",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, networkSecurityGroup: {
                serializedName: "properties.networkSecurityGroup",
                type: {
                    name: "Composite",
                    className: "NetworkSecurityGroup"
                }
            }, privateEndpoint: {
                serializedName: "properties.privateEndpoint",
                type: {
                    name: "Composite",
                    className: "PrivateEndpoint"
                }
            }, ipConfigurations: {
                serializedName: "properties.ipConfigurations",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "NetworkInterfaceIPConfiguration"
                        }
                    }
                }
            }, tapConfigurations: {
                serializedName: "properties.tapConfigurations",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "NetworkInterfaceTapConfiguration"
                        }
                    }
                }
            }, dnsSettings: {
                serializedName: "properties.dnsSettings",
                type: {
                    name: "Composite",
                    className: "NetworkInterfaceDnsSettings"
                }
            }, macAddress: {
                serializedName: "properties.macAddress",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, primary: {
                serializedName: "properties.primary",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            }, vnetEncryptionSupported: {
                serializedName: "properties.vnetEncryptionSupported",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            }, enableAcceleratedNetworking: {
                serializedName: "properties.enableAcceleratedNetworking",
                type: {
                    name: "Boolean"
                }
            }, enableIPForwarding: {
                serializedName: "properties.enableIPForwarding",
                type: {
                    name: "Boolean"
                }
            }, hostedWorkloads: {
                serializedName: "properties.hostedWorkloads",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, dscpConfiguration: {
                serializedName: "properties.dscpConfiguration",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, resourceGuid: {
                serializedName: "properties.resourceGuid",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, workloadType: {
                serializedName: "properties.workloadType",
                type: {
                    name: "String"
                }
            }, nicType: {
                serializedName: "properties.nicType",
                type: {
                    name: "String"
                }
            }, privateLinkService: {
                serializedName: "properties.privateLinkService",
                type: {
                    name: "Composite",
                    className: "PrivateLinkService"
                }
            }, migrationPhase: {
                serializedName: "properties.migrationPhase",
                type: {
                    name: "String"
                }
            } })
    }
};
const FlowLog = {
    type: {
        name: "Composite",
        className: "FlowLog",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, targetResourceId: {
                serializedName: "properties.targetResourceId",
                type: {
                    name: "String"
                }
            }, targetResourceGuid: {
                serializedName: "properties.targetResourceGuid",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, storageId: {
                serializedName: "properties.storageId",
                type: {
                    name: "String"
                }
            }, enabled: {
                serializedName: "properties.enabled",
                type: {
                    name: "Boolean"
                }
            }, retentionPolicy: {
                serializedName: "properties.retentionPolicy",
                type: {
                    name: "Composite",
                    className: "RetentionPolicyParameters"
                }
            }, format: {
                serializedName: "properties.format",
                type: {
                    name: "Composite",
                    className: "FlowLogFormatParameters"
                }
            }, flowAnalyticsConfiguration: {
                serializedName: "properties.flowAnalyticsConfiguration",
                type: {
                    name: "Composite",
                    className: "TrafficAnalyticsProperties"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const NetworkSecurityGroup = {
    type: {
        name: "Composite",
        className: "NetworkSecurityGroup",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, securityRules: {
                serializedName: "properties.securityRules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SecurityRule"
                        }
                    }
                }
            }, defaultSecurityRules: {
                serializedName: "properties.defaultSecurityRules",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SecurityRule"
                        }
                    }
                }
            }, networkInterfaces: {
                serializedName: "properties.networkInterfaces",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "NetworkInterface"
                        }
                    }
                }
            }, subnets: {
                serializedName: "properties.subnets",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Subnet"
                        }
                    }
                }
            }, flowLogs: {
                serializedName: "properties.flowLogs",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "FlowLog"
                        }
                    }
                }
            }, resourceGuid: {
                serializedName: "properties.resourceGuid",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const RouteTable = {
    type: {
        name: "Composite",
        className: "RouteTable",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, routes: {
                serializedName: "properties.routes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Route"
                        }
                    }
                }
            }, subnets: {
                serializedName: "properties.subnets",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Subnet"
                        }
                    }
                }
            }, disableBgpRoutePropagation: {
                serializedName: "properties.disableBgpRoutePropagation",
                type: {
                    name: "Boolean"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, resourceGuid: {
                serializedName: "properties.resourceGuid",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const ServiceEndpointPolicy = {
    type: {
        name: "Composite",
        className: "ServiceEndpointPolicy",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, kind: {
                serializedName: "kind",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, serviceEndpointPolicyDefinitions: {
                serializedName: "properties.serviceEndpointPolicyDefinitions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ServiceEndpointPolicyDefinition"
                        }
                    }
                }
            }, subnets: {
                serializedName: "properties.subnets",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Subnet"
                        }
                    }
                }
            }, resourceGuid: {
                serializedName: "properties.resourceGuid",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, serviceAlias: {
                serializedName: "properties.serviceAlias",
                type: {
                    name: "String"
                }
            }, contextualServiceEndpointPolicies: {
                serializedName: "properties.contextualServiceEndpointPolicies",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            } })
    }
};
const NatGateway = {
    type: {
        name: "Composite",
        className: "NatGateway",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { sku: {
                serializedName: "sku",
                type: {
                    name: "Composite",
                    className: "NatGatewaySku"
                }
            }, zones: {
                serializedName: "zones",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, idleTimeoutInMinutes: {
                serializedName: "properties.idleTimeoutInMinutes",
                type: {
                    name: "Number"
                }
            }, publicIpAddresses: {
                serializedName: "properties.publicIpAddresses",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            }, publicIpPrefixes: {
                serializedName: "properties.publicIpPrefixes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            }, subnets: {
                serializedName: "properties.subnets",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            }, resourceGuid: {
                serializedName: "properties.resourceGuid",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const PublicIPAddress = {
    type: {
        name: "Composite",
        className: "PublicIPAddress",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { extendedLocation: {
                serializedName: "extendedLocation",
                type: {
                    name: "Composite",
                    className: "ExtendedLocation"
                }
            }, sku: {
                serializedName: "sku",
                type: {
                    name: "Composite",
                    className: "PublicIPAddressSku"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, zones: {
                serializedName: "zones",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, publicIPAllocationMethod: {
                serializedName: "properties.publicIPAllocationMethod",
                type: {
                    name: "String"
                }
            }, publicIPAddressVersion: {
                serializedName: "properties.publicIPAddressVersion",
                type: {
                    name: "String"
                }
            }, ipConfiguration: {
                serializedName: "properties.ipConfiguration",
                type: {
                    name: "Composite",
                    className: "IPConfiguration"
                }
            }, dnsSettings: {
                serializedName: "properties.dnsSettings",
                type: {
                    name: "Composite",
                    className: "PublicIPAddressDnsSettings"
                }
            }, ddosSettings: {
                serializedName: "properties.ddosSettings",
                type: {
                    name: "Composite",
                    className: "DdosSettings"
                }
            }, ipTags: {
                serializedName: "properties.ipTags",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "IpTag"
                        }
                    }
                }
            }, ipAddress: {
                serializedName: "properties.ipAddress",
                type: {
                    name: "String"
                }
            }, publicIPPrefix: {
                serializedName: "properties.publicIPPrefix",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, idleTimeoutInMinutes: {
                serializedName: "properties.idleTimeoutInMinutes",
                type: {
                    name: "Number"
                }
            }, resourceGuid: {
                serializedName: "properties.resourceGuid",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, servicePublicIPAddress: {
                serializedName: "properties.servicePublicIPAddress",
                type: {
                    name: "Composite",
                    className: "PublicIPAddress"
                }
            }, natGateway: {
                serializedName: "properties.natGateway",
                type: {
                    name: "Composite",
                    className: "NatGateway"
                }
            }, migrationPhase: {
                serializedName: "properties.migrationPhase",
                type: {
                    name: "String"
                }
            }, linkedPublicIPAddress: {
                serializedName: "properties.linkedPublicIPAddress",
                type: {
                    name: "Composite",
                    className: "PublicIPAddress"
                }
            }, deleteOption: {
                serializedName: "properties.deleteOption",
                type: {
                    name: "String"
                }
            } })
    }
};
const VirtualNetworkTap = {
    type: {
        name: "Composite",
        className: "VirtualNetworkTap",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, networkInterfaceTapConfigurations: {
                serializedName: "properties.networkInterfaceTapConfigurations",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "NetworkInterfaceTapConfiguration"
                        }
                    }
                }
            }, resourceGuid: {
                serializedName: "properties.resourceGuid",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, destinationNetworkInterfaceIPConfiguration: {
                serializedName: "properties.destinationNetworkInterfaceIPConfiguration",
                type: {
                    name: "Composite",
                    className: "NetworkInterfaceIPConfiguration"
                }
            }, destinationLoadBalancerFrontEndIPConfiguration: {
                serializedName: "properties.destinationLoadBalancerFrontEndIPConfiguration",
                type: {
                    name: "Composite",
                    className: "FrontendIPConfiguration"
                }
            }, destinationPort: {
                serializedName: "properties.destinationPort",
                type: {
                    name: "Number"
                }
            } })
    }
};
const ApplicationGateway = {
    type: {
        name: "Composite",
        className: "ApplicationGateway",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, zones: {
                serializedName: "zones",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, identity: {
                serializedName: "identity",
                type: {
                    name: "Composite",
                    className: "ManagedServiceIdentity"
                }
            }, sku: {
                serializedName: "properties.sku",
                type: {
                    name: "Composite",
                    className: "ApplicationGatewaySku"
                }
            }, sslPolicy: {
                serializedName: "properties.sslPolicy",
                type: {
                    name: "Composite",
                    className: "ApplicationGatewaySslPolicy"
                }
            }, operationalState: {
                serializedName: "properties.operationalState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, gatewayIPConfigurations: {
                serializedName: "properties.gatewayIPConfigurations",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationGatewayIPConfiguration"
                        }
                    }
                }
            }, authenticationCertificates: {
                serializedName: "properties.authenticationCertificates",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationGatewayAuthenticationCertificate"
                        }
                    }
                }
            }, trustedRootCertificates: {
                serializedName: "properties.trustedRootCertificates",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationGatewayTrustedRootCertificate"
                        }
                    }
                }
            }, trustedClientCertificates: {
                serializedName: "properties.trustedClientCertificates",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationGatewayTrustedClientCertificate"
                        }
                    }
                }
            }, sslCertificates: {
                serializedName: "properties.sslCertificates",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationGatewaySslCertificate"
                        }
                    }
                }
            }, frontendIPConfigurations: {
                serializedName: "properties.frontendIPConfigurations",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationGatewayFrontendIPConfiguration"
                        }
                    }
                }
            }, frontendPorts: {
                serializedName: "properties.frontendPorts",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationGatewayFrontendPort"
                        }
                    }
                }
            }, probes: {
                serializedName: "properties.probes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationGatewayProbe"
                        }
                    }
                }
            }, backendAddressPools: {
                serializedName: "properties.backendAddressPools",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationGatewayBackendAddressPool"
                        }
                    }
                }
            }, backendHttpSettingsCollection: {
                serializedName: "properties.backendHttpSettingsCollection",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationGatewayBackendHttpSettings"
                        }
                    }
                }
            }, httpListeners: {
                serializedName: "properties.httpListeners",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationGatewayHttpListener"
                        }
                    }
                }
            }, sslProfiles: {
                serializedName: "properties.sslProfiles",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationGatewaySslProfile"
                        }
                    }
                }
            }, urlPathMaps: {
                serializedName: "properties.urlPathMaps",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationGatewayUrlPathMap"
                        }
                    }
                }
            }, requestRoutingRules: {
                serializedName: "properties.requestRoutingRules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationGatewayRequestRoutingRule"
                        }
                    }
                }
            }, rewriteRuleSets: {
                serializedName: "properties.rewriteRuleSets",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationGatewayRewriteRuleSet"
                        }
                    }
                }
            }, redirectConfigurations: {
                serializedName: "properties.redirectConfigurations",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationGatewayRedirectConfiguration"
                        }
                    }
                }
            }, webApplicationFirewallConfiguration: {
                serializedName: "properties.webApplicationFirewallConfiguration",
                type: {
                    name: "Composite",
                    className: "ApplicationGatewayWebApplicationFirewallConfiguration"
                }
            }, firewallPolicy: {
                serializedName: "properties.firewallPolicy",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, enableHttp2: {
                serializedName: "properties.enableHttp2",
                type: {
                    name: "Boolean"
                }
            }, enableFips: {
                serializedName: "properties.enableFips",
                type: {
                    name: "Boolean"
                }
            }, autoscaleConfiguration: {
                serializedName: "properties.autoscaleConfiguration",
                type: {
                    name: "Composite",
                    className: "ApplicationGatewayAutoscaleConfiguration"
                }
            }, privateLinkConfigurations: {
                serializedName: "properties.privateLinkConfigurations",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationGatewayPrivateLinkConfiguration"
                        }
                    }
                }
            }, privateEndpointConnections: {
                serializedName: "properties.privateEndpointConnections",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationGatewayPrivateEndpointConnection"
                        }
                    }
                }
            }, resourceGuid: {
                serializedName: "properties.resourceGuid",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, customErrorConfigurations: {
                serializedName: "properties.customErrorConfigurations",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationGatewayCustomError"
                        }
                    }
                }
            }, forceFirewallPolicyAssociation: {
                serializedName: "properties.forceFirewallPolicyAssociation",
                type: {
                    name: "Boolean"
                }
            }, loadDistributionPolicies: {
                serializedName: "properties.loadDistributionPolicies",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationGatewayLoadDistributionPolicy"
                        }
                    }
                }
            }, globalConfiguration: {
                serializedName: "properties.globalConfiguration",
                type: {
                    name: "Composite",
                    className: "ApplicationGatewayGlobalConfiguration"
                }
            } })
    }
};
const ApplicationGatewayFirewallRuleSet = {
    type: {
        name: "Composite",
        className: "ApplicationGatewayFirewallRuleSet",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, ruleSetType: {
                serializedName: "properties.ruleSetType",
                type: {
                    name: "String"
                }
            }, ruleSetVersion: {
                serializedName: "properties.ruleSetVersion",
                type: {
                    name: "String"
                }
            }, ruleGroups: {
                serializedName: "properties.ruleGroups",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationGatewayFirewallRuleGroup"
                        }
                    }
                }
            } })
    }
};
const ApplicationGatewayAvailableSslOptions = {
    type: {
        name: "Composite",
        className: "ApplicationGatewayAvailableSslOptions",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { predefinedPolicies: {
                serializedName: "properties.predefinedPolicies",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            }, defaultPolicy: {
                serializedName: "properties.defaultPolicy",
                type: {
                    name: "String"
                }
            }, availableCipherSuites: {
                serializedName: "properties.availableCipherSuites",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, availableProtocols: {
                serializedName: "properties.availableProtocols",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            } })
    }
};
const AzureFirewall = {
    type: {
        name: "Composite",
        className: "AzureFirewall",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { zones: {
                serializedName: "zones",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, applicationRuleCollections: {
                serializedName: "properties.applicationRuleCollections",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AzureFirewallApplicationRuleCollection"
                        }
                    }
                }
            }, natRuleCollections: {
                serializedName: "properties.natRuleCollections",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AzureFirewallNatRuleCollection"
                        }
                    }
                }
            }, networkRuleCollections: {
                serializedName: "properties.networkRuleCollections",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AzureFirewallNetworkRuleCollection"
                        }
                    }
                }
            }, ipConfigurations: {
                serializedName: "properties.ipConfigurations",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AzureFirewallIPConfiguration"
                        }
                    }
                }
            }, managementIpConfiguration: {
                serializedName: "properties.managementIpConfiguration",
                type: {
                    name: "Composite",
                    className: "AzureFirewallIPConfiguration"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, threatIntelMode: {
                serializedName: "properties.threatIntelMode",
                type: {
                    name: "String"
                }
            }, virtualHub: {
                serializedName: "properties.virtualHub",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, firewallPolicy: {
                serializedName: "properties.firewallPolicy",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, hubIPAddresses: {
                serializedName: "properties.hubIPAddresses",
                type: {
                    name: "Composite",
                    className: "HubIPAddresses"
                }
            }, ipGroups: {
                serializedName: "properties.ipGroups",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AzureFirewallIpGroups"
                        }
                    }
                }
            }, sku: {
                serializedName: "properties.sku",
                type: {
                    name: "Composite",
                    className: "AzureFirewallSku"
                }
            }, additionalProperties: {
                serializedName: "properties.additionalProperties",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            } })
    }
};
const AzureFirewallFqdnTag = {
    type: {
        name: "Composite",
        className: "AzureFirewallFqdnTag",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, fqdnTagName: {
                serializedName: "properties.fqdnTagName",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const BastionHost = {
    type: {
        name: "Composite",
        className: "BastionHost",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, sku: {
                serializedName: "sku",
                type: {
                    name: "Composite",
                    className: "Sku"
                }
            }, ipConfigurations: {
                serializedName: "properties.ipConfigurations",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "BastionHostIPConfiguration"
                        }
                    }
                }
            }, dnsName: {
                serializedName: "properties.dnsName",
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, scaleUnits: {
                constraints: {
                    InclusiveMaximum: 50,
                    InclusiveMinimum: 2
                },
                serializedName: "properties.scaleUnits",
                type: {
                    name: "Number"
                }
            }, disableCopyPaste: {
                defaultValue: false,
                serializedName: "properties.disableCopyPaste",
                type: {
                    name: "Boolean"
                }
            }, enableFileCopy: {
                defaultValue: false,
                serializedName: "properties.enableFileCopy",
                type: {
                    name: "Boolean"
                }
            }, enableIpConnect: {
                defaultValue: false,
                serializedName: "properties.enableIpConnect",
                type: {
                    name: "Boolean"
                }
            }, enableShareableLink: {
                defaultValue: false,
                serializedName: "properties.enableShareableLink",
                type: {
                    name: "Boolean"
                }
            }, enableTunneling: {
                defaultValue: false,
                serializedName: "properties.enableTunneling",
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const Vm = {
    type: {
        name: "Composite",
        className: "Vm",
        modelProperties: Object.assign({}, Resource.type.modelProperties)
    }
};
const CustomIpPrefix = {
    type: {
        name: "Composite",
        className: "CustomIpPrefix",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { extendedLocation: {
                serializedName: "extendedLocation",
                type: {
                    name: "Composite",
                    className: "ExtendedLocation"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, zones: {
                serializedName: "zones",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, cidr: {
                serializedName: "properties.cidr",
                type: {
                    name: "String"
                }
            }, signedMessage: {
                serializedName: "properties.signedMessage",
                type: {
                    name: "String"
                }
            }, authorizationMessage: {
                serializedName: "properties.authorizationMessage",
                type: {
                    name: "String"
                }
            }, customIpPrefixParent: {
                serializedName: "properties.customIpPrefixParent",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, childCustomIpPrefixes: {
                serializedName: "properties.childCustomIpPrefixes",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            }, commissionedState: {
                serializedName: "properties.commissionedState",
                type: {
                    name: "String"
                }
            }, publicIpPrefixes: {
                serializedName: "properties.publicIpPrefixes",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            }, resourceGuid: {
                serializedName: "properties.resourceGuid",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, failedReason: {
                serializedName: "properties.failedReason",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const DdosCustomPolicy = {
    type: {
        name: "Composite",
        className: "DdosCustomPolicy",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, resourceGuid: {
                serializedName: "properties.resourceGuid",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, publicIPAddresses: {
                serializedName: "properties.publicIPAddresses",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            }, protocolCustomSettings: {
                serializedName: "properties.protocolCustomSettings",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ProtocolCustomSettingsFormat"
                        }
                    }
                }
            } })
    }
};
const DscpConfiguration = {
    type: {
        name: "Composite",
        className: "DscpConfiguration",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, markings: {
                serializedName: "properties.markings",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Number"
                        }
                    }
                }
            }, sourceIpRanges: {
                serializedName: "properties.sourceIpRanges",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "QosIpRange"
                        }
                    }
                }
            }, destinationIpRanges: {
                serializedName: "properties.destinationIpRanges",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "QosIpRange"
                        }
                    }
                }
            }, sourcePortRanges: {
                serializedName: "properties.sourcePortRanges",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "QosPortRange"
                        }
                    }
                }
            }, destinationPortRanges: {
                serializedName: "properties.destinationPortRanges",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "QosPortRange"
                        }
                    }
                }
            }, protocol: {
                serializedName: "properties.protocol",
                type: {
                    name: "String"
                }
            }, qosDefinitionCollection: {
                serializedName: "properties.qosDefinitionCollection",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "QosDefinition"
                        }
                    }
                }
            }, qosCollectionId: {
                serializedName: "properties.qosCollectionId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, associatedNetworkInterfaces: {
                serializedName: "properties.associatedNetworkInterfaces",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "NetworkInterface"
                        }
                    }
                }
            }, resourceGuid: {
                serializedName: "properties.resourceGuid",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const ExpressRouteCircuit = {
    type: {
        name: "Composite",
        className: "ExpressRouteCircuit",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { sku: {
                serializedName: "sku",
                type: {
                    name: "Composite",
                    className: "ExpressRouteCircuitSku"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, allowClassicOperations: {
                serializedName: "properties.allowClassicOperations",
                type: {
                    name: "Boolean"
                }
            }, circuitProvisioningState: {
                serializedName: "properties.circuitProvisioningState",
                type: {
                    name: "String"
                }
            }, serviceProviderProvisioningState: {
                serializedName: "properties.serviceProviderProvisioningState",
                type: {
                    name: "String"
                }
            }, authorizations: {
                serializedName: "properties.authorizations",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ExpressRouteCircuitAuthorization"
                        }
                    }
                }
            }, peerings: {
                serializedName: "properties.peerings",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ExpressRouteCircuitPeering"
                        }
                    }
                }
            }, serviceKey: {
                serializedName: "properties.serviceKey",
                type: {
                    name: "String"
                }
            }, serviceProviderNotes: {
                serializedName: "properties.serviceProviderNotes",
                type: {
                    name: "String"
                }
            }, serviceProviderProperties: {
                serializedName: "properties.serviceProviderProperties",
                type: {
                    name: "Composite",
                    className: "ExpressRouteCircuitServiceProviderProperties"
                }
            }, expressRoutePort: {
                serializedName: "properties.expressRoutePort",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, bandwidthInGbps: {
                serializedName: "properties.bandwidthInGbps",
                type: {
                    name: "Number"
                }
            }, stag: {
                serializedName: "properties.stag",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, gatewayManagerEtag: {
                serializedName: "properties.gatewayManagerEtag",
                type: {
                    name: "String"
                }
            }, globalReachEnabled: {
                serializedName: "properties.globalReachEnabled",
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const ExpressRouteServiceProvider = {
    type: {
        name: "Composite",
        className: "ExpressRouteServiceProvider",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { peeringLocations: {
                serializedName: "properties.peeringLocations",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, bandwidthsOffered: {
                serializedName: "properties.bandwidthsOffered",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ExpressRouteServiceProviderBandwidthsOffered"
                        }
                    }
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const ExpressRouteCrossConnection = {
    type: {
        name: "Composite",
        className: "ExpressRouteCrossConnection",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, primaryAzurePort: {
                serializedName: "properties.primaryAzurePort",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, secondaryAzurePort: {
                serializedName: "properties.secondaryAzurePort",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, sTag: {
                serializedName: "properties.sTag",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, peeringLocation: {
                serializedName: "properties.peeringLocation",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, bandwidthInMbps: {
                serializedName: "properties.bandwidthInMbps",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, expressRouteCircuit: {
                serializedName: "properties.expressRouteCircuit",
                type: {
                    name: "Composite",
                    className: "ExpressRouteCircuitReference"
                }
            }, serviceProviderProvisioningState: {
                serializedName: "properties.serviceProviderProvisioningState",
                type: {
                    name: "String"
                }
            }, serviceProviderNotes: {
                serializedName: "properties.serviceProviderNotes",
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, peerings: {
                serializedName: "properties.peerings",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ExpressRouteCrossConnectionPeering"
                        }
                    }
                }
            } })
    }
};
const ExpressRoutePortsLocation = {
    type: {
        name: "Composite",
        className: "ExpressRoutePortsLocation",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { address: {
                serializedName: "properties.address",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, contact: {
                serializedName: "properties.contact",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, availableBandwidths: {
                serializedName: "properties.availableBandwidths",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ExpressRoutePortsLocationBandwidths"
                        }
                    }
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const ExpressRoutePort = {
    type: {
        name: "Composite",
        className: "ExpressRoutePort",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, identity: {
                serializedName: "identity",
                type: {
                    name: "Composite",
                    className: "ManagedServiceIdentity"
                }
            }, peeringLocation: {
                serializedName: "properties.peeringLocation",
                type: {
                    name: "String"
                }
            }, bandwidthInGbps: {
                serializedName: "properties.bandwidthInGbps",
                type: {
                    name: "Number"
                }
            }, provisionedBandwidthInGbps: {
                serializedName: "properties.provisionedBandwidthInGbps",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, mtu: {
                serializedName: "properties.mtu",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, encapsulation: {
                serializedName: "properties.encapsulation",
                type: {
                    name: "String"
                }
            }, etherType: {
                serializedName: "properties.etherType",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, allocationDate: {
                serializedName: "properties.allocationDate",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, links: {
                serializedName: "properties.links",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ExpressRouteLink"
                        }
                    }
                }
            }, circuits: {
                serializedName: "properties.circuits",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, resourceGuid: {
                serializedName: "properties.resourceGuid",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const FirewallPolicy = {
    type: {
        name: "Composite",
        className: "FirewallPolicy",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, identity: {
                serializedName: "identity",
                type: {
                    name: "Composite",
                    className: "ManagedServiceIdentity"
                }
            }, ruleCollectionGroups: {
                serializedName: "properties.ruleCollectionGroups",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, basePolicy: {
                serializedName: "properties.basePolicy",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, firewalls: {
                serializedName: "properties.firewalls",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            }, childPolicies: {
                serializedName: "properties.childPolicies",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            }, threatIntelMode: {
                serializedName: "properties.threatIntelMode",
                type: {
                    name: "String"
                }
            }, threatIntelWhitelist: {
                serializedName: "properties.threatIntelWhitelist",
                type: {
                    name: "Composite",
                    className: "FirewallPolicyThreatIntelWhitelist"
                }
            }, insights: {
                serializedName: "properties.insights",
                type: {
                    name: "Composite",
                    className: "FirewallPolicyInsights"
                }
            }, snat: {
                serializedName: "properties.snat",
                type: {
                    name: "Composite",
                    className: "FirewallPolicySnat"
                }
            }, sql: {
                serializedName: "properties.sql",
                type: {
                    name: "Composite",
                    className: "FirewallPolicySQL"
                }
            }, dnsSettings: {
                serializedName: "properties.dnsSettings",
                type: {
                    name: "Composite",
                    className: "DnsSettings"
                }
            }, explicitProxySettings: {
                serializedName: "properties.explicitProxySettings",
                type: {
                    name: "Composite",
                    className: "ExplicitProxySettings"
                }
            }, intrusionDetection: {
                serializedName: "properties.intrusionDetection",
                type: {
                    name: "Composite",
                    className: "FirewallPolicyIntrusionDetection"
                }
            }, transportSecurity: {
                serializedName: "properties.transportSecurity",
                type: {
                    name: "Composite",
                    className: "FirewallPolicyTransportSecurity"
                }
            }, sku: {
                serializedName: "properties.sku",
                type: {
                    name: "Composite",
                    className: "FirewallPolicySku"
                }
            } })
    }
};
const IpAllocation = {
    type: {
        name: "Composite",
        className: "IpAllocation",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, subnet: {
                serializedName: "properties.subnet",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, virtualNetwork: {
                serializedName: "properties.virtualNetwork",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, typePropertiesType: {
                serializedName: "properties.type",
                type: {
                    name: "String"
                }
            }, prefix: {
                serializedName: "properties.prefix",
                type: {
                    name: "String"
                }
            }, prefixLength: {
                defaultValue: 0,
                serializedName: "properties.prefixLength",
                nullable: true,
                type: {
                    name: "Number"
                }
            }, prefixType: {
                serializedName: "properties.prefixType",
                type: {
                    name: "String"
                }
            }, ipamAllocationId: {
                serializedName: "properties.ipamAllocationId",
                type: {
                    name: "String"
                }
            }, allocationTags: {
                serializedName: "properties.allocationTags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            } })
    }
};
const IpGroup = {
    type: {
        name: "Composite",
        className: "IpGroup",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, ipAddresses: {
                serializedName: "properties.ipAddresses",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, firewalls: {
                serializedName: "properties.firewalls",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            }, firewallPolicies: {
                serializedName: "properties.firewallPolicies",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            } })
    }
};
const LoadBalancer = {
    type: {
        name: "Composite",
        className: "LoadBalancer",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { extendedLocation: {
                serializedName: "extendedLocation",
                type: {
                    name: "Composite",
                    className: "ExtendedLocation"
                }
            }, sku: {
                serializedName: "sku",
                type: {
                    name: "Composite",
                    className: "LoadBalancerSku"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, frontendIPConfigurations: {
                serializedName: "properties.frontendIPConfigurations",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "FrontendIPConfiguration"
                        }
                    }
                }
            }, backendAddressPools: {
                serializedName: "properties.backendAddressPools",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "BackendAddressPool"
                        }
                    }
                }
            }, loadBalancingRules: {
                serializedName: "properties.loadBalancingRules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "LoadBalancingRule"
                        }
                    }
                }
            }, probes: {
                serializedName: "properties.probes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Probe"
                        }
                    }
                }
            }, inboundNatRules: {
                serializedName: "properties.inboundNatRules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "InboundNatRule"
                        }
                    }
                }
            }, inboundNatPools: {
                serializedName: "properties.inboundNatPools",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "InboundNatPool"
                        }
                    }
                }
            }, outboundRules: {
                serializedName: "properties.outboundRules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "OutboundRule"
                        }
                    }
                }
            }, resourceGuid: {
                serializedName: "properties.resourceGuid",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const NetworkProfile = {
    type: {
        name: "Composite",
        className: "NetworkProfile",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, containerNetworkInterfaces: {
                serializedName: "properties.containerNetworkInterfaces",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ContainerNetworkInterface"
                        }
                    }
                }
            }, containerNetworkInterfaceConfigurations: {
                serializedName: "properties.containerNetworkInterfaceConfigurations",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ContainerNetworkInterfaceConfiguration"
                        }
                    }
                }
            }, resourceGuid: {
                serializedName: "properties.resourceGuid",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const NetworkVirtualAppliance = {
    type: {
        name: "Composite",
        className: "NetworkVirtualAppliance",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { identity: {
                serializedName: "identity",
                type: {
                    name: "Composite",
                    className: "ManagedServiceIdentity"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, nvaSku: {
                serializedName: "properties.nvaSku",
                type: {
                    name: "Composite",
                    className: "VirtualApplianceSkuProperties"
                }
            }, addressPrefix: {
                serializedName: "properties.addressPrefix",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, bootStrapConfigurationBlobs: {
                serializedName: "properties.bootStrapConfigurationBlobs",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, virtualHub: {
                serializedName: "properties.virtualHub",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, cloudInitConfigurationBlobs: {
                serializedName: "properties.cloudInitConfigurationBlobs",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, cloudInitConfiguration: {
                serializedName: "properties.cloudInitConfiguration",
                type: {
                    name: "String"
                }
            }, virtualApplianceAsn: {
                constraints: {
                    InclusiveMaximum: 4294967295,
                    InclusiveMinimum: 0
                },
                serializedName: "properties.virtualApplianceAsn",
                type: {
                    name: "Number"
                }
            }, sshPublicKey: {
                serializedName: "properties.sshPublicKey",
                type: {
                    name: "String"
                }
            }, virtualApplianceNics: {
                serializedName: "properties.virtualApplianceNics",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualApplianceNicProperties"
                        }
                    }
                }
            }, virtualApplianceSites: {
                serializedName: "properties.virtualApplianceSites",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            }, inboundSecurityRules: {
                serializedName: "properties.inboundSecurityRules",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const NetworkVirtualApplianceSku = {
    type: {
        name: "Composite",
        className: "NetworkVirtualApplianceSku",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, vendor: {
                serializedName: "properties.vendor",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, availableVersions: {
                serializedName: "properties.availableVersions",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, availableScaleUnits: {
                serializedName: "properties.availableScaleUnits",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "NetworkVirtualApplianceSkuInstances"
                        }
                    }
                }
            } })
    }
};
const NetworkWatcher = {
    type: {
        name: "Composite",
        className: "NetworkWatcher",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const PublicIPPrefix = {
    type: {
        name: "Composite",
        className: "PublicIPPrefix",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { extendedLocation: {
                serializedName: "extendedLocation",
                type: {
                    name: "Composite",
                    className: "ExtendedLocation"
                }
            }, sku: {
                serializedName: "sku",
                type: {
                    name: "Composite",
                    className: "PublicIPPrefixSku"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, zones: {
                serializedName: "zones",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, publicIPAddressVersion: {
                serializedName: "properties.publicIPAddressVersion",
                type: {
                    name: "String"
                }
            }, ipTags: {
                serializedName: "properties.ipTags",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "IpTag"
                        }
                    }
                }
            }, prefixLength: {
                serializedName: "properties.prefixLength",
                type: {
                    name: "Number"
                }
            }, ipPrefix: {
                serializedName: "properties.ipPrefix",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, publicIPAddresses: {
                serializedName: "properties.publicIPAddresses",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ReferencedPublicIpAddress"
                        }
                    }
                }
            }, loadBalancerFrontendIpConfiguration: {
                serializedName: "properties.loadBalancerFrontendIpConfiguration",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, customIPPrefix: {
                serializedName: "properties.customIPPrefix",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, resourceGuid: {
                serializedName: "properties.resourceGuid",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, natGateway: {
                serializedName: "properties.natGateway",
                type: {
                    name: "Composite",
                    className: "NatGateway"
                }
            } })
    }
};
const RouteFilter = {
    type: {
        name: "Composite",
        className: "RouteFilter",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, rules: {
                serializedName: "properties.rules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RouteFilterRule"
                        }
                    }
                }
            }, peerings: {
                serializedName: "properties.peerings",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ExpressRouteCircuitPeering"
                        }
                    }
                }
            }, ipv6Peerings: {
                serializedName: "properties.ipv6Peerings",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ExpressRouteCircuitPeering"
                        }
                    }
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const SecurityPartnerProvider = {
    type: {
        name: "Composite",
        className: "SecurityPartnerProvider",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, securityProviderName: {
                serializedName: "properties.securityProviderName",
                type: {
                    name: "String"
                }
            }, connectionStatus: {
                serializedName: "properties.connectionStatus",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, virtualHub: {
                serializedName: "properties.virtualHub",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            } })
    }
};
const BgpServiceCommunity = {
    type: {
        name: "Composite",
        className: "BgpServiceCommunity",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { serviceName: {
                serializedName: "properties.serviceName",
                type: {
                    name: "String"
                }
            }, bgpCommunities: {
                serializedName: "properties.bgpCommunities",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "BGPCommunity"
                        }
                    }
                }
            } })
    }
};
const VirtualNetwork = {
    type: {
        name: "Composite",
        className: "VirtualNetwork",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { extendedLocation: {
                serializedName: "extendedLocation",
                type: {
                    name: "Composite",
                    className: "ExtendedLocation"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, addressSpace: {
                serializedName: "properties.addressSpace",
                type: {
                    name: "Composite",
                    className: "AddressSpace"
                }
            }, dhcpOptions: {
                serializedName: "properties.dhcpOptions",
                type: {
                    name: "Composite",
                    className: "DhcpOptions"
                }
            }, flowTimeoutInMinutes: {
                serializedName: "properties.flowTimeoutInMinutes",
                type: {
                    name: "Number"
                }
            }, subnets: {
                serializedName: "properties.subnets",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Subnet"
                        }
                    }
                }
            }, virtualNetworkPeerings: {
                serializedName: "properties.virtualNetworkPeerings",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualNetworkPeering"
                        }
                    }
                }
            }, resourceGuid: {
                serializedName: "properties.resourceGuid",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, enableDdosProtection: {
                defaultValue: false,
                serializedName: "properties.enableDdosProtection",
                type: {
                    name: "Boolean"
                }
            }, enableVmProtection: {
                defaultValue: false,
                serializedName: "properties.enableVmProtection",
                type: {
                    name: "Boolean"
                }
            }, ddosProtectionPlan: {
                serializedName: "properties.ddosProtectionPlan",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, bgpCommunities: {
                serializedName: "properties.bgpCommunities",
                type: {
                    name: "Composite",
                    className: "VirtualNetworkBgpCommunities"
                }
            }, encryption: {
                serializedName: "properties.encryption",
                type: {
                    name: "Composite",
                    className: "VirtualNetworkEncryption"
                }
            }, ipAllocations: {
                serializedName: "properties.ipAllocations",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            } })
    }
};
const NetworkIntentPolicy = {
    type: {
        name: "Composite",
        className: "NetworkIntentPolicy",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const VirtualNetworkGateway = {
    type: {
        name: "Composite",
        className: "VirtualNetworkGateway",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { extendedLocation: {
                serializedName: "extendedLocation",
                type: {
                    name: "Composite",
                    className: "ExtendedLocation"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, ipConfigurations: {
                serializedName: "properties.ipConfigurations",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualNetworkGatewayIPConfiguration"
                        }
                    }
                }
            }, gatewayType: {
                serializedName: "properties.gatewayType",
                type: {
                    name: "String"
                }
            }, vpnType: {
                serializedName: "properties.vpnType",
                type: {
                    name: "String"
                }
            }, vpnGatewayGeneration: {
                serializedName: "properties.vpnGatewayGeneration",
                type: {
                    name: "String"
                }
            }, enableBgp: {
                serializedName: "properties.enableBgp",
                type: {
                    name: "Boolean"
                }
            }, enablePrivateIpAddress: {
                serializedName: "properties.enablePrivateIpAddress",
                type: {
                    name: "Boolean"
                }
            }, active: {
                serializedName: "properties.activeActive",
                type: {
                    name: "Boolean"
                }
            }, disableIPSecReplayProtection: {
                serializedName: "properties.disableIPSecReplayProtection",
                type: {
                    name: "Boolean"
                }
            }, gatewayDefaultSite: {
                serializedName: "properties.gatewayDefaultSite",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, sku: {
                serializedName: "properties.sku",
                type: {
                    name: "Composite",
                    className: "VirtualNetworkGatewaySku"
                }
            }, vpnClientConfiguration: {
                serializedName: "properties.vpnClientConfiguration",
                type: {
                    name: "Composite",
                    className: "VpnClientConfiguration"
                }
            }, bgpSettings: {
                serializedName: "properties.bgpSettings",
                type: {
                    name: "Composite",
                    className: "BgpSettings"
                }
            }, customRoutes: {
                serializedName: "properties.customRoutes",
                type: {
                    name: "Composite",
                    className: "AddressSpace"
                }
            }, resourceGuid: {
                serializedName: "properties.resourceGuid",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, enableDnsForwarding: {
                serializedName: "properties.enableDnsForwarding",
                type: {
                    name: "Boolean"
                }
            }, inboundDnsForwardingEndpoint: {
                serializedName: "properties.inboundDnsForwardingEndpoint",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, vNetExtendedLocationResourceId: {
                serializedName: "properties.vNetExtendedLocationResourceId",
                type: {
                    name: "String"
                }
            }, natRules: {
                serializedName: "properties.natRules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualNetworkGatewayNatRule"
                        }
                    }
                }
            }, enableBgpRouteTranslationForNat: {
                serializedName: "properties.enableBgpRouteTranslationForNat",
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const VirtualNetworkGatewayConnectionListEntity = {
    type: {
        name: "Composite",
        className: "VirtualNetworkGatewayConnectionListEntity",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, authorizationKey: {
                serializedName: "properties.authorizationKey",
                type: {
                    name: "String"
                }
            }, virtualNetworkGateway1: {
                serializedName: "properties.virtualNetworkGateway1",
                type: {
                    name: "Composite",
                    className: "VirtualNetworkConnectionGatewayReference"
                }
            }, virtualNetworkGateway2: {
                serializedName: "properties.virtualNetworkGateway2",
                type: {
                    name: "Composite",
                    className: "VirtualNetworkConnectionGatewayReference"
                }
            }, localNetworkGateway2: {
                serializedName: "properties.localNetworkGateway2",
                type: {
                    name: "Composite",
                    className: "VirtualNetworkConnectionGatewayReference"
                }
            }, connectionType: {
                serializedName: "properties.connectionType",
                required: true,
                type: {
                    name: "String"
                }
            }, connectionProtocol: {
                serializedName: "properties.connectionProtocol",
                type: {
                    name: "String"
                }
            }, routingWeight: {
                serializedName: "properties.routingWeight",
                type: {
                    name: "Number"
                }
            }, connectionMode: {
                serializedName: "properties.connectionMode",
                type: {
                    name: "String"
                }
            }, sharedKey: {
                serializedName: "properties.sharedKey",
                type: {
                    name: "String"
                }
            }, connectionStatus: {
                serializedName: "properties.connectionStatus",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, tunnelConnectionStatus: {
                serializedName: "properties.tunnelConnectionStatus",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TunnelConnectionHealth"
                        }
                    }
                }
            }, egressBytesTransferred: {
                serializedName: "properties.egressBytesTransferred",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, ingressBytesTransferred: {
                serializedName: "properties.ingressBytesTransferred",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, peer: {
                serializedName: "properties.peer",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, enableBgp: {
                serializedName: "properties.enableBgp",
                type: {
                    name: "Boolean"
                }
            }, usePolicyBasedTrafficSelectors: {
                serializedName: "properties.usePolicyBasedTrafficSelectors",
                type: {
                    name: "Boolean"
                }
            }, ipsecPolicies: {
                serializedName: "properties.ipsecPolicies",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "IpsecPolicy"
                        }
                    }
                }
            }, trafficSelectorPolicies: {
                serializedName: "properties.trafficSelectorPolicies",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TrafficSelectorPolicy"
                        }
                    }
                }
            }, resourceGuid: {
                serializedName: "properties.resourceGuid",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, expressRouteGatewayBypass: {
                serializedName: "properties.expressRouteGatewayBypass",
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const LocalNetworkGateway = {
    type: {
        name: "Composite",
        className: "LocalNetworkGateway",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, localNetworkAddressSpace: {
                serializedName: "properties.localNetworkAddressSpace",
                type: {
                    name: "Composite",
                    className: "AddressSpace"
                }
            }, gatewayIpAddress: {
                serializedName: "properties.gatewayIpAddress",
                type: {
                    name: "String"
                }
            }, fqdn: {
                serializedName: "properties.fqdn",
                type: {
                    name: "String"
                }
            }, bgpSettings: {
                serializedName: "properties.bgpSettings",
                type: {
                    name: "Composite",
                    className: "BgpSettings"
                }
            }, resourceGuid: {
                serializedName: "properties.resourceGuid",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const VirtualNetworkGatewayConnection = {
    type: {
        name: "Composite",
        className: "VirtualNetworkGatewayConnection",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, authorizationKey: {
                serializedName: "properties.authorizationKey",
                type: {
                    name: "String"
                }
            }, virtualNetworkGateway1: {
                serializedName: "properties.virtualNetworkGateway1",
                type: {
                    name: "Composite",
                    className: "VirtualNetworkGateway"
                }
            }, virtualNetworkGateway2: {
                serializedName: "properties.virtualNetworkGateway2",
                type: {
                    name: "Composite",
                    className: "VirtualNetworkGateway"
                }
            }, localNetworkGateway2: {
                serializedName: "properties.localNetworkGateway2",
                type: {
                    name: "Composite",
                    className: "LocalNetworkGateway"
                }
            }, ingressNatRules: {
                serializedName: "properties.ingressNatRules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            }, egressNatRules: {
                serializedName: "properties.egressNatRules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            }, connectionType: {
                serializedName: "properties.connectionType",
                required: true,
                type: {
                    name: "String"
                }
            }, connectionProtocol: {
                serializedName: "properties.connectionProtocol",
                type: {
                    name: "String"
                }
            }, routingWeight: {
                serializedName: "properties.routingWeight",
                type: {
                    name: "Number"
                }
            }, dpdTimeoutSeconds: {
                serializedName: "properties.dpdTimeoutSeconds",
                type: {
                    name: "Number"
                }
            }, connectionMode: {
                serializedName: "properties.connectionMode",
                type: {
                    name: "String"
                }
            }, sharedKey: {
                serializedName: "properties.sharedKey",
                type: {
                    name: "String"
                }
            }, connectionStatus: {
                serializedName: "properties.connectionStatus",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, tunnelConnectionStatus: {
                serializedName: "properties.tunnelConnectionStatus",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TunnelConnectionHealth"
                        }
                    }
                }
            }, egressBytesTransferred: {
                serializedName: "properties.egressBytesTransferred",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, ingressBytesTransferred: {
                serializedName: "properties.ingressBytesTransferred",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, peer: {
                serializedName: "properties.peer",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, enableBgp: {
                serializedName: "properties.enableBgp",
                type: {
                    name: "Boolean"
                }
            }, useLocalAzureIpAddress: {
                serializedName: "properties.useLocalAzureIpAddress",
                type: {
                    name: "Boolean"
                }
            }, usePolicyBasedTrafficSelectors: {
                serializedName: "properties.usePolicyBasedTrafficSelectors",
                type: {
                    name: "Boolean"
                }
            }, ipsecPolicies: {
                serializedName: "properties.ipsecPolicies",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "IpsecPolicy"
                        }
                    }
                }
            }, trafficSelectorPolicies: {
                serializedName: "properties.trafficSelectorPolicies",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TrafficSelectorPolicy"
                        }
                    }
                }
            }, resourceGuid: {
                serializedName: "properties.resourceGuid",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, expressRouteGatewayBypass: {
                serializedName: "properties.expressRouteGatewayBypass",
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const VirtualRouter = {
    type: {
        name: "Composite",
        className: "VirtualRouter",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, virtualRouterAsn: {
                constraints: {
                    InclusiveMaximum: 4294967295,
                    InclusiveMinimum: 0
                },
                serializedName: "properties.virtualRouterAsn",
                type: {
                    name: "Number"
                }
            }, virtualRouterIps: {
                serializedName: "properties.virtualRouterIps",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, hostedSubnet: {
                serializedName: "properties.hostedSubnet",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, hostedGateway: {
                serializedName: "properties.hostedGateway",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, peerings: {
                serializedName: "properties.peerings",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const VirtualWAN = {
    type: {
        name: "Composite",
        className: "VirtualWAN",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, disableVpnEncryption: {
                serializedName: "properties.disableVpnEncryption",
                type: {
                    name: "Boolean"
                }
            }, virtualHubs: {
                serializedName: "properties.virtualHubs",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            }, vpnSites: {
                serializedName: "properties.vpnSites",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            }, allowBranchToBranchTraffic: {
                serializedName: "properties.allowBranchToBranchTraffic",
                type: {
                    name: "Boolean"
                }
            }, allowVnetToVnetTraffic: {
                serializedName: "properties.allowVnetToVnetTraffic",
                type: {
                    name: "Boolean"
                }
            }, office365LocalBreakoutCategory: {
                serializedName: "properties.office365LocalBreakoutCategory",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, typePropertiesType: {
                serializedName: "properties.type",
                type: {
                    name: "String"
                }
            } })
    }
};
const VpnSite = {
    type: {
        name: "Composite",
        className: "VpnSite",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, virtualWan: {
                serializedName: "properties.virtualWan",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, deviceProperties: {
                serializedName: "properties.deviceProperties",
                type: {
                    name: "Composite",
                    className: "DeviceProperties"
                }
            }, ipAddress: {
                serializedName: "properties.ipAddress",
                type: {
                    name: "String"
                }
            }, siteKey: {
                serializedName: "properties.siteKey",
                type: {
                    name: "String"
                }
            }, addressSpace: {
                serializedName: "properties.addressSpace",
                type: {
                    name: "Composite",
                    className: "AddressSpace"
                }
            }, bgpProperties: {
                serializedName: "properties.bgpProperties",
                type: {
                    name: "Composite",
                    className: "BgpSettings"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, isSecuritySite: {
                serializedName: "properties.isSecuritySite",
                type: {
                    name: "Boolean"
                }
            }, vpnSiteLinks: {
                serializedName: "properties.vpnSiteLinks",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VpnSiteLink"
                        }
                    }
                }
            }, o365Policy: {
                serializedName: "properties.o365Policy",
                type: {
                    name: "Composite",
                    className: "O365PolicyProperties"
                }
            } })
    }
};
const P2SVpnGateway = {
    type: {
        name: "Composite",
        className: "P2SVpnGateway",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, virtualHub: {
                serializedName: "properties.virtualHub",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, p2SConnectionConfigurations: {
                serializedName: "properties.p2SConnectionConfigurations",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "P2SConnectionConfiguration"
                        }
                    }
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, vpnGatewayScaleUnit: {
                serializedName: "properties.vpnGatewayScaleUnit",
                type: {
                    name: "Number"
                }
            }, vpnServerConfiguration: {
                serializedName: "properties.vpnServerConfiguration",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, vpnClientConnectionHealth: {
                serializedName: "properties.vpnClientConnectionHealth",
                type: {
                    name: "Composite",
                    className: "VpnClientConnectionHealth"
                }
            }, customDnsServers: {
                serializedName: "properties.customDnsServers",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, isRoutingPreferenceInternet: {
                serializedName: "properties.isRoutingPreferenceInternet",
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const VpnServerConfiguration = {
    type: {
        name: "Composite",
        className: "VpnServerConfiguration",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, namePropertiesName: {
                serializedName: "properties.name",
                type: {
                    name: "String"
                }
            }, vpnProtocols: {
                serializedName: "properties.vpnProtocols",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, vpnAuthenticationTypes: {
                serializedName: "properties.vpnAuthenticationTypes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, vpnClientRootCertificates: {
                serializedName: "properties.vpnClientRootCertificates",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VpnServerConfigVpnClientRootCertificate"
                        }
                    }
                }
            }, vpnClientRevokedCertificates: {
                serializedName: "properties.vpnClientRevokedCertificates",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VpnServerConfigVpnClientRevokedCertificate"
                        }
                    }
                }
            }, radiusServerRootCertificates: {
                serializedName: "properties.radiusServerRootCertificates",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VpnServerConfigRadiusServerRootCertificate"
                        }
                    }
                }
            }, radiusClientRootCertificates: {
                serializedName: "properties.radiusClientRootCertificates",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VpnServerConfigRadiusClientRootCertificate"
                        }
                    }
                }
            }, vpnClientIpsecPolicies: {
                serializedName: "properties.vpnClientIpsecPolicies",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "IpsecPolicy"
                        }
                    }
                }
            }, radiusServerAddress: {
                serializedName: "properties.radiusServerAddress",
                type: {
                    name: "String"
                }
            }, radiusServerSecret: {
                serializedName: "properties.radiusServerSecret",
                type: {
                    name: "String"
                }
            }, radiusServers: {
                serializedName: "properties.radiusServers",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RadiusServer"
                        }
                    }
                }
            }, aadAuthenticationParameters: {
                serializedName: "properties.aadAuthenticationParameters",
                type: {
                    name: "Composite",
                    className: "AadAuthenticationParameters"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, p2SVpnGateways: {
                serializedName: "properties.p2SVpnGateways",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "P2SVpnGateway"
                        }
                    }
                }
            }, etagPropertiesEtag: {
                serializedName: "properties.etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const VirtualHub = {
    type: {
        name: "Composite",
        className: "VirtualHub",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, kind: {
                serializedName: "kind",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, virtualWan: {
                serializedName: "properties.virtualWan",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, vpnGateway: {
                serializedName: "properties.vpnGateway",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, p2SVpnGateway: {
                serializedName: "properties.p2SVpnGateway",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, expressRouteGateway: {
                serializedName: "properties.expressRouteGateway",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, azureFirewall: {
                serializedName: "properties.azureFirewall",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, securityPartnerProvider: {
                serializedName: "properties.securityPartnerProvider",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, addressPrefix: {
                serializedName: "properties.addressPrefix",
                type: {
                    name: "String"
                }
            }, routeTable: {
                serializedName: "properties.routeTable",
                type: {
                    name: "Composite",
                    className: "VirtualHubRouteTable"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, securityProviderName: {
                serializedName: "properties.securityProviderName",
                type: {
                    name: "String"
                }
            }, virtualHubRouteTableV2S: {
                serializedName: "properties.virtualHubRouteTableV2s",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualHubRouteTableV2"
                        }
                    }
                }
            }, sku: {
                serializedName: "properties.sku",
                type: {
                    name: "String"
                }
            }, routingState: {
                serializedName: "properties.routingState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, bgpConnections: {
                serializedName: "properties.bgpConnections",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            }, ipConfigurations: {
                serializedName: "properties.ipConfigurations",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            }, virtualRouterAsn: {
                constraints: {
                    InclusiveMaximum: 4294967295,
                    InclusiveMinimum: 0
                },
                serializedName: "properties.virtualRouterAsn",
                type: {
                    name: "Number"
                }
            }, virtualRouterIps: {
                serializedName: "properties.virtualRouterIps",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, allowBranchToBranchTraffic: {
                serializedName: "properties.allowBranchToBranchTraffic",
                type: {
                    name: "Boolean"
                }
            }, preferredRoutingGateway: {
                serializedName: "properties.preferredRoutingGateway",
                type: {
                    name: "String"
                }
            } })
    }
};
const VpnGateway = {
    type: {
        name: "Composite",
        className: "VpnGateway",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, virtualHub: {
                serializedName: "properties.virtualHub",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, connections: {
                serializedName: "properties.connections",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VpnConnection"
                        }
                    }
                }
            }, bgpSettings: {
                serializedName: "properties.bgpSettings",
                type: {
                    name: "Composite",
                    className: "BgpSettings"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, vpnGatewayScaleUnit: {
                serializedName: "properties.vpnGatewayScaleUnit",
                type: {
                    name: "Number"
                }
            }, ipConfigurations: {
                serializedName: "properties.ipConfigurations",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VpnGatewayIpConfiguration"
                        }
                    }
                }
            }, enableBgpRouteTranslationForNat: {
                serializedName: "properties.enableBgpRouteTranslationForNat",
                type: {
                    name: "Boolean"
                }
            }, isRoutingPreferenceInternet: {
                serializedName: "properties.isRoutingPreferenceInternet",
                type: {
                    name: "Boolean"
                }
            }, natRules: {
                serializedName: "properties.natRules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VpnGatewayNatRule"
                        }
                    }
                }
            } })
    }
};
const ExpressRouteGateway = {
    type: {
        name: "Composite",
        className: "ExpressRouteGateway",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, autoScaleConfiguration: {
                serializedName: "properties.autoScaleConfiguration",
                type: {
                    name: "Composite",
                    className: "ExpressRouteGatewayPropertiesAutoScaleConfiguration"
                }
            }, expressRouteConnections: {
                serializedName: "properties.expressRouteConnections",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ExpressRouteConnection"
                        }
                    }
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, virtualHub: {
                serializedName: "properties.virtualHub",
                type: {
                    name: "Composite",
                    className: "VirtualHubId"
                }
            } })
    }
};
const WebApplicationFirewallPolicy = {
    type: {
        name: "Composite",
        className: "WebApplicationFirewallPolicy",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, policySettings: {
                serializedName: "properties.policySettings",
                type: {
                    name: "Composite",
                    className: "PolicySettings"
                }
            }, customRules: {
                serializedName: "properties.customRules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "WebApplicationFirewallCustomRule"
                        }
                    }
                }
            }, applicationGateways: {
                serializedName: "properties.applicationGateways",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationGateway"
                        }
                    }
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, resourceState: {
                serializedName: "properties.resourceState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, managedRules: {
                serializedName: "properties.managedRules",
                type: {
                    name: "Composite",
                    className: "ManagedRulesDefinition"
                }
            }, httpListeners: {
                serializedName: "properties.httpListeners",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            }, pathBasedRules: {
                serializedName: "properties.pathBasedRules",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            } })
    }
};
const PrivateLinkServicePropertiesVisibility = {
    type: {
        name: "Composite",
        className: "PrivateLinkServicePropertiesVisibility",
        modelProperties: Object.assign({}, ResourceSet.type.modelProperties)
    }
};
const PrivateLinkServicePropertiesAutoApproval = {
    type: {
        name: "Composite",
        className: "PrivateLinkServicePropertiesAutoApproval",
        modelProperties: Object.assign({}, ResourceSet.type.modelProperties)
    }
};
const FirewallPolicyNatRuleCollection = {
    serializedName: "FirewallPolicyNatRuleCollection",
    type: {
        name: "Composite",
        className: "FirewallPolicyNatRuleCollection",
        uberParent: "FirewallPolicyRuleCollection",
        polymorphicDiscriminator: FirewallPolicyRuleCollection.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, FirewallPolicyRuleCollection.type.modelProperties), { action: {
                serializedName: "action",
                type: {
                    name: "Composite",
                    className: "FirewallPolicyNatRuleCollectionAction"
                }
            }, rules: {
                serializedName: "rules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "FirewallPolicyRule"
                        }
                    }
                }
            } })
    }
};
const FirewallPolicyFilterRuleCollection = {
    serializedName: "FirewallPolicyFilterRuleCollection",
    type: {
        name: "Composite",
        className: "FirewallPolicyFilterRuleCollection",
        uberParent: "FirewallPolicyRuleCollection",
        polymorphicDiscriminator: FirewallPolicyRuleCollection.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, FirewallPolicyRuleCollection.type.modelProperties), { action: {
                serializedName: "action",
                type: {
                    name: "Composite",
                    className: "FirewallPolicyFilterRuleCollectionAction"
                }
            }, rules: {
                serializedName: "rules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "FirewallPolicyRule"
                        }
                    }
                }
            } })
    }
};
const PacketCaptureResultProperties = {
    type: {
        name: "Composite",
        className: "PacketCaptureResultProperties",
        modelProperties: Object.assign(Object.assign({}, PacketCaptureParameters.type.modelProperties), { provisioningState: {
                serializedName: "provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const ConnectionMonitorResultProperties = {
    type: {
        name: "Composite",
        className: "ConnectionMonitorResultProperties",
        modelProperties: Object.assign(Object.assign({}, ConnectionMonitorParameters.type.modelProperties), { provisioningState: {
                serializedName: "provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, startTime: {
                serializedName: "startTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, monitoringStatus: {
                serializedName: "monitoringStatus",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, connectionMonitorType: {
                serializedName: "connectionMonitorType",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const ApplicationRule = {
    serializedName: "ApplicationRule",
    type: {
        name: "Composite",
        className: "ApplicationRule",
        uberParent: "FirewallPolicyRule",
        polymorphicDiscriminator: FirewallPolicyRule.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, FirewallPolicyRule.type.modelProperties), { sourceAddresses: {
                serializedName: "sourceAddresses",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, destinationAddresses: {
                serializedName: "destinationAddresses",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, protocols: {
                serializedName: "protocols",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "FirewallPolicyRuleApplicationProtocol"
                        }
                    }
                }
            }, targetFqdns: {
                serializedName: "targetFqdns",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, targetUrls: {
                serializedName: "targetUrls",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, fqdnTags: {
                serializedName: "fqdnTags",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, sourceIpGroups: {
                serializedName: "sourceIpGroups",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, terminateTLS: {
                serializedName: "terminateTLS",
                type: {
                    name: "Boolean"
                }
            }, webCategories: {
                serializedName: "webCategories",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            } })
    }
};
const NatRule = {
    serializedName: "NatRule",
    type: {
        name: "Composite",
        className: "NatRule",
        uberParent: "FirewallPolicyRule",
        polymorphicDiscriminator: FirewallPolicyRule.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, FirewallPolicyRule.type.modelProperties), { ipProtocols: {
                serializedName: "ipProtocols",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, sourceAddresses: {
                serializedName: "sourceAddresses",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, destinationAddresses: {
                serializedName: "destinationAddresses",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, destinationPorts: {
                serializedName: "destinationPorts",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, translatedAddress: {
                serializedName: "translatedAddress",
                type: {
                    name: "String"
                }
            }, translatedPort: {
                serializedName: "translatedPort",
                type: {
                    name: "String"
                }
            }, sourceIpGroups: {
                serializedName: "sourceIpGroups",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, translatedFqdn: {
                serializedName: "translatedFqdn",
                type: {
                    name: "String"
                }
            } })
    }
};
const NetworkRule = {
    serializedName: "NetworkRule",
    type: {
        name: "Composite",
        className: "NetworkRule",
        uberParent: "FirewallPolicyRule",
        polymorphicDiscriminator: FirewallPolicyRule.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, FirewallPolicyRule.type.modelProperties), { ipProtocols: {
                serializedName: "ipProtocols",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, sourceAddresses: {
                serializedName: "sourceAddresses",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, destinationAddresses: {
                serializedName: "destinationAddresses",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, destinationPorts: {
                serializedName: "destinationPorts",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, sourceIpGroups: {
                serializedName: "sourceIpGroups",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, destinationIpGroups: {
                serializedName: "destinationIpGroups",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, destinationFqdns: {
                serializedName: "destinationFqdns",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            } })
    }
};
let discriminators = {
    FirewallPolicyRuleCollection: FirewallPolicyRuleCollection,
    FirewallPolicyRule: FirewallPolicyRule,
    "FirewallPolicyRuleCollection.FirewallPolicyNatRuleCollection": FirewallPolicyNatRuleCollection,
    "FirewallPolicyRuleCollection.FirewallPolicyFilterRuleCollection": FirewallPolicyFilterRuleCollection,
    "FirewallPolicyRule.ApplicationRule": ApplicationRule,
    "FirewallPolicyRule.NatRule": NatRule,
    "FirewallPolicyRule.NetworkRule": NetworkRule
};

var Mappers = /*#__PURE__*/Object.freeze({
    __proto__: null,
    CloudError: CloudError,
    CloudErrorBody: CloudErrorBody,
    ApplicationGatewaySku: ApplicationGatewaySku,
    ApplicationGatewaySslPolicy: ApplicationGatewaySslPolicy,
    SubResource: SubResource,
    ApplicationGatewayProbeHealthResponseMatch: ApplicationGatewayProbeHealthResponseMatch,
    Resource: Resource,
    ExtendedLocation: ExtendedLocation,
    PrivateLinkServiceConnectionState: PrivateLinkServiceConnectionState,
    CustomDnsConfigPropertiesFormat: CustomDnsConfigPropertiesFormat,
    PrivateEndpointIPConfiguration: PrivateEndpointIPConfiguration,
    NetworkInterfaceDnsSettings: NetworkInterfaceDnsSettings,
    ResourceSet: ResourceSet,
    RetentionPolicyParameters: RetentionPolicyParameters,
    FlowLogFormatParameters: FlowLogFormatParameters,
    TrafficAnalyticsProperties: TrafficAnalyticsProperties,
    TrafficAnalyticsConfigurationProperties: TrafficAnalyticsConfigurationProperties,
    ServiceEndpointPropertiesFormat: ServiceEndpointPropertiesFormat,
    PublicIPAddressSku: PublicIPAddressSku,
    PublicIPAddressDnsSettings: PublicIPAddressDnsSettings,
    DdosSettings: DdosSettings,
    IpTag: IpTag,
    NatGatewaySku: NatGatewaySku,
    GatewayLoadBalancerTunnelInterface: GatewayLoadBalancerTunnelInterface,
    LoadBalancerBackendAddress: LoadBalancerBackendAddress,
    NatRulePortMapping: NatRulePortMapping,
    NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties: NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties,
    ApplicationGatewayBackendAddress: ApplicationGatewayBackendAddress,
    ApplicationGatewayConnectionDraining: ApplicationGatewayConnectionDraining,
    ApplicationGatewayCustomError: ApplicationGatewayCustomError,
    ApplicationGatewayClientAuthConfiguration: ApplicationGatewayClientAuthConfiguration,
    ApplicationGatewayRewriteRule: ApplicationGatewayRewriteRule,
    ApplicationGatewayRewriteRuleCondition: ApplicationGatewayRewriteRuleCondition,
    ApplicationGatewayRewriteRuleActionSet: ApplicationGatewayRewriteRuleActionSet,
    ApplicationGatewayHeaderConfiguration: ApplicationGatewayHeaderConfiguration,
    ApplicationGatewayUrlConfiguration: ApplicationGatewayUrlConfiguration,
    ApplicationGatewayWebApplicationFirewallConfiguration: ApplicationGatewayWebApplicationFirewallConfiguration,
    ApplicationGatewayFirewallDisabledRuleGroup: ApplicationGatewayFirewallDisabledRuleGroup,
    ApplicationGatewayFirewallExclusion: ApplicationGatewayFirewallExclusion,
    ApplicationGatewayAutoscaleConfiguration: ApplicationGatewayAutoscaleConfiguration,
    ApplicationGatewayGlobalConfiguration: ApplicationGatewayGlobalConfiguration,
    ManagedServiceIdentity: ManagedServiceIdentity,
    Components1Jq1T4ISchemasManagedserviceidentityPropertiesUserassignedidentitiesAdditionalproperties: Components1Jq1T4ISchemasManagedserviceidentityPropertiesUserassignedidentitiesAdditionalproperties,
    TagsObject: TagsObject,
    ApplicationGatewayListResult: ApplicationGatewayListResult,
    ApplicationGatewayBackendHealth: ApplicationGatewayBackendHealth,
    ApplicationGatewayBackendHealthPool: ApplicationGatewayBackendHealthPool,
    ApplicationGatewayBackendHealthHttpSettings: ApplicationGatewayBackendHealthHttpSettings,
    ApplicationGatewayBackendHealthServer: ApplicationGatewayBackendHealthServer,
    ApplicationGatewayOnDemandProbe: ApplicationGatewayOnDemandProbe,
    ApplicationGatewayBackendHealthOnDemand: ApplicationGatewayBackendHealthOnDemand,
    ApplicationGatewayPrivateLinkResourceListResult: ApplicationGatewayPrivateLinkResourceListResult,
    ApplicationGatewayPrivateEndpointConnectionListResult: ApplicationGatewayPrivateEndpointConnectionListResult,
    ErrorModel: ErrorModel,
    ErrorDetails: ErrorDetails,
    ApplicationGatewayAvailableWafRuleSetsResult: ApplicationGatewayAvailableWafRuleSetsResult,
    ApplicationGatewayFirewallRuleGroup: ApplicationGatewayFirewallRuleGroup,
    ApplicationGatewayFirewallRule: ApplicationGatewayFirewallRule,
    ApplicationGatewayAvailableSslPredefinedPolicies: ApplicationGatewayAvailableSslPredefinedPolicies,
    ApplicationSecurityGroupListResult: ApplicationSecurityGroupListResult,
    AvailableDelegationsResult: AvailableDelegationsResult,
    AvailableDelegation: AvailableDelegation,
    AvailableServiceAliasesResult: AvailableServiceAliasesResult,
    AvailableServiceAlias: AvailableServiceAlias,
    AzureFirewallRCAction: AzureFirewallRCAction,
    AzureFirewallApplicationRule: AzureFirewallApplicationRule,
    AzureFirewallApplicationRuleProtocol: AzureFirewallApplicationRuleProtocol,
    AzureFirewallNatRCAction: AzureFirewallNatRCAction,
    AzureFirewallNatRule: AzureFirewallNatRule,
    AzureFirewallNetworkRule: AzureFirewallNetworkRule,
    HubIPAddresses: HubIPAddresses,
    HubPublicIPAddresses: HubPublicIPAddresses,
    AzureFirewallPublicIPAddress: AzureFirewallPublicIPAddress,
    AzureFirewallIpGroups: AzureFirewallIpGroups,
    AzureFirewallSku: AzureFirewallSku,
    AzureFirewallListResult: AzureFirewallListResult,
    AzureFirewallFqdnTagListResult: AzureFirewallFqdnTagListResult,
    AzureWebCategory: AzureWebCategory,
    AzureWebCategoryListResult: AzureWebCategoryListResult,
    Sku: Sku,
    BastionHostListResult: BastionHostListResult,
    BastionShareableLinkListRequest: BastionShareableLinkListRequest,
    BastionShareableLink: BastionShareableLink,
    BastionShareableLinkListResult: BastionShareableLinkListResult,
    BastionActiveSessionListResult: BastionActiveSessionListResult,
    BastionActiveSession: BastionActiveSession,
    SessionIds: SessionIds,
    BastionSessionDeleteResult: BastionSessionDeleteResult,
    BastionSessionState: BastionSessionState,
    DnsNameAvailabilityResult: DnsNameAvailabilityResult,
    NetworkInterfaceListResult: NetworkInterfaceListResult,
    PublicIPAddressListResult: PublicIPAddressListResult,
    CustomIpPrefixListResult: CustomIpPrefixListResult,
    ProtocolCustomSettingsFormat: ProtocolCustomSettingsFormat,
    DdosProtectionPlan: DdosProtectionPlan,
    DdosProtectionPlanListResult: DdosProtectionPlanListResult,
    QosIpRange: QosIpRange,
    QosPortRange: QosPortRange,
    QosDefinition: QosDefinition,
    DscpConfigurationListResult: DscpConfigurationListResult,
    EndpointServicesListResult: EndpointServicesListResult,
    AuthorizationListResult: AuthorizationListResult,
    ExpressRouteCircuitPeeringConfig: ExpressRouteCircuitPeeringConfig,
    ExpressRouteCircuitStats: ExpressRouteCircuitStats,
    Ipv6ExpressRouteCircuitPeeringConfig: Ipv6ExpressRouteCircuitPeeringConfig,
    ExpressRouteConnectionId: ExpressRouteConnectionId,
    Ipv6CircuitConnectionConfig: Ipv6CircuitConnectionConfig,
    ExpressRouteCircuitPeeringListResult: ExpressRouteCircuitPeeringListResult,
    ExpressRouteCircuitConnectionListResult: ExpressRouteCircuitConnectionListResult,
    PeerExpressRouteCircuitConnectionListResult: PeerExpressRouteCircuitConnectionListResult,
    ExpressRouteCircuitSku: ExpressRouteCircuitSku,
    ExpressRouteCircuitServiceProviderProperties: ExpressRouteCircuitServiceProviderProperties,
    ExpressRouteCircuitsArpTableListResult: ExpressRouteCircuitsArpTableListResult,
    ExpressRouteCircuitArpTable: ExpressRouteCircuitArpTable,
    ExpressRouteCircuitsRoutesTableListResult: ExpressRouteCircuitsRoutesTableListResult,
    ExpressRouteCircuitRoutesTable: ExpressRouteCircuitRoutesTable,
    ExpressRouteCircuitsRoutesTableSummaryListResult: ExpressRouteCircuitsRoutesTableSummaryListResult,
    ExpressRouteCircuitRoutesTableSummary: ExpressRouteCircuitRoutesTableSummary,
    ExpressRouteCircuitListResult: ExpressRouteCircuitListResult,
    ExpressRouteServiceProviderListResult: ExpressRouteServiceProviderListResult,
    ExpressRouteServiceProviderBandwidthsOffered: ExpressRouteServiceProviderBandwidthsOffered,
    ExpressRouteCrossConnectionListResult: ExpressRouteCrossConnectionListResult,
    ExpressRouteCircuitReference: ExpressRouteCircuitReference,
    ExpressRouteCrossConnectionPeeringList: ExpressRouteCrossConnectionPeeringList,
    ExpressRouteCrossConnectionsRoutesTableSummaryListResult: ExpressRouteCrossConnectionsRoutesTableSummaryListResult,
    ExpressRouteCrossConnectionRoutesTableSummary: ExpressRouteCrossConnectionRoutesTableSummary,
    ExpressRoutePortsLocationListResult: ExpressRoutePortsLocationListResult,
    ExpressRoutePortsLocationBandwidths: ExpressRoutePortsLocationBandwidths,
    ExpressRouteLinkMacSecConfig: ExpressRouteLinkMacSecConfig,
    ExpressRoutePortListResult: ExpressRoutePortListResult,
    ExpressRouteLinkListResult: ExpressRouteLinkListResult,
    GenerateExpressRoutePortsLOARequest: GenerateExpressRoutePortsLOARequest,
    GenerateExpressRoutePortsLOAResult: GenerateExpressRoutePortsLOAResult,
    FirewallPolicyThreatIntelWhitelist: FirewallPolicyThreatIntelWhitelist,
    FirewallPolicyInsights: FirewallPolicyInsights,
    FirewallPolicyLogAnalyticsResources: FirewallPolicyLogAnalyticsResources,
    FirewallPolicyLogAnalyticsWorkspace: FirewallPolicyLogAnalyticsWorkspace,
    FirewallPolicySnat: FirewallPolicySnat,
    FirewallPolicySQL: FirewallPolicySQL,
    DnsSettings: DnsSettings,
    ExplicitProxySettings: ExplicitProxySettings,
    FirewallPolicyIntrusionDetection: FirewallPolicyIntrusionDetection,
    FirewallPolicyIntrusionDetectionConfiguration: FirewallPolicyIntrusionDetectionConfiguration,
    FirewallPolicyIntrusionDetectionSignatureSpecification: FirewallPolicyIntrusionDetectionSignatureSpecification,
    FirewallPolicyIntrusionDetectionBypassTrafficSpecifications: FirewallPolicyIntrusionDetectionBypassTrafficSpecifications,
    FirewallPolicyTransportSecurity: FirewallPolicyTransportSecurity,
    FirewallPolicyCertificateAuthority: FirewallPolicyCertificateAuthority,
    FirewallPolicySku: FirewallPolicySku,
    FirewallPolicyListResult: FirewallPolicyListResult,
    FirewallPolicyRuleCollection: FirewallPolicyRuleCollection,
    FirewallPolicyRuleCollectionGroupListResult: FirewallPolicyRuleCollectionGroupListResult,
    IdpsQueryObject: IdpsQueryObject,
    FilterItems: FilterItems,
    OrderBy: OrderBy,
    QueryResults: QueryResults,
    SingleQueryResult: SingleQueryResult,
    SignaturesOverrides: SignaturesOverrides,
    SignaturesOverridesProperties: SignaturesOverridesProperties,
    SignatureOverridesFilterValuesQuery: SignatureOverridesFilterValuesQuery,
    SignatureOverridesFilterValuesResponse: SignatureOverridesFilterValuesResponse,
    SignaturesOverridesList: SignaturesOverridesList,
    IpAllocationListResult: IpAllocationListResult,
    IpGroupListResult: IpGroupListResult,
    LoadBalancerSku: LoadBalancerSku,
    LoadBalancerListResult: LoadBalancerListResult,
    LoadBalancerBackendAddressPoolListResult: LoadBalancerBackendAddressPoolListResult,
    LoadBalancerFrontendIPConfigurationListResult: LoadBalancerFrontendIPConfigurationListResult,
    InboundNatRuleListResult: InboundNatRuleListResult,
    LoadBalancerLoadBalancingRuleListResult: LoadBalancerLoadBalancingRuleListResult,
    LoadBalancerOutboundRuleListResult: LoadBalancerOutboundRuleListResult,
    LoadBalancerProbeListResult: LoadBalancerProbeListResult,
    LoadBalancerVipSwapRequest: LoadBalancerVipSwapRequest,
    LoadBalancerVipSwapRequestFrontendIPConfiguration: LoadBalancerVipSwapRequestFrontendIPConfiguration,
    QueryInboundNatRulePortMappingRequest: QueryInboundNatRulePortMappingRequest,
    BackendAddressInboundNatRulePortMappings: BackendAddressInboundNatRulePortMappings,
    InboundNatRulePortMapping: InboundNatRulePortMapping,
    NatGatewayListResult: NatGatewayListResult,
    EffectiveRouteListResult: EffectiveRouteListResult,
    EffectiveRoute: EffectiveRoute,
    EffectiveNetworkSecurityGroupListResult: EffectiveNetworkSecurityGroupListResult,
    EffectiveNetworkSecurityGroup: EffectiveNetworkSecurityGroup,
    EffectiveNetworkSecurityGroupAssociation: EffectiveNetworkSecurityGroupAssociation,
    EffectiveNetworkSecurityRule: EffectiveNetworkSecurityRule,
    NetworkInterfaceIPConfigurationListResult: NetworkInterfaceIPConfigurationListResult,
    NetworkInterfaceLoadBalancerListResult: NetworkInterfaceLoadBalancerListResult,
    NetworkInterfaceTapConfigurationListResult: NetworkInterfaceTapConfigurationListResult,
    ContainerNetworkInterfaceIpConfiguration: ContainerNetworkInterfaceIpConfiguration,
    NetworkProfileListResult: NetworkProfileListResult,
    NetworkSecurityGroupListResult: NetworkSecurityGroupListResult,
    SecurityRuleListResult: SecurityRuleListResult,
    VirtualApplianceSkuProperties: VirtualApplianceSkuProperties,
    VirtualApplianceNicProperties: VirtualApplianceNicProperties,
    NetworkVirtualApplianceListResult: NetworkVirtualApplianceListResult,
    Office365PolicyProperties: Office365PolicyProperties,
    BreakOutCategoryPolicies: BreakOutCategoryPolicies,
    NetworkVirtualApplianceSiteListResult: NetworkVirtualApplianceSiteListResult,
    NetworkVirtualApplianceSkuListResult: NetworkVirtualApplianceSkuListResult,
    NetworkVirtualApplianceSkuInstances: NetworkVirtualApplianceSkuInstances,
    InboundSecurityRules: InboundSecurityRules,
    ErrorResponse: ErrorResponse,
    NetworkWatcherListResult: NetworkWatcherListResult,
    TopologyParameters: TopologyParameters,
    Topology: Topology,
    TopologyResource: TopologyResource,
    TopologyAssociation: TopologyAssociation,
    VerificationIPFlowParameters: VerificationIPFlowParameters,
    VerificationIPFlowResult: VerificationIPFlowResult,
    NextHopParameters: NextHopParameters,
    NextHopResult: NextHopResult,
    SecurityGroupViewParameters: SecurityGroupViewParameters,
    SecurityGroupViewResult: SecurityGroupViewResult,
    SecurityGroupNetworkInterface: SecurityGroupNetworkInterface,
    SecurityRuleAssociations: SecurityRuleAssociations,
    NetworkInterfaceAssociation: NetworkInterfaceAssociation,
    SubnetAssociation: SubnetAssociation,
    PacketCapture: PacketCapture,
    PacketCaptureParameters: PacketCaptureParameters,
    PacketCaptureStorageLocation: PacketCaptureStorageLocation,
    PacketCaptureFilter: PacketCaptureFilter,
    PacketCaptureResult: PacketCaptureResult,
    PacketCaptureQueryStatusResult: PacketCaptureQueryStatusResult,
    PacketCaptureListResult: PacketCaptureListResult,
    TroubleshootingParameters: TroubleshootingParameters,
    TroubleshootingResult: TroubleshootingResult,
    TroubleshootingDetails: TroubleshootingDetails,
    TroubleshootingRecommendedActions: TroubleshootingRecommendedActions,
    QueryTroubleshootingParameters: QueryTroubleshootingParameters,
    FlowLogInformation: FlowLogInformation,
    FlowLogStatusParameters: FlowLogStatusParameters,
    ConnectivityParameters: ConnectivityParameters,
    ConnectivitySource: ConnectivitySource,
    ConnectivityDestination: ConnectivityDestination,
    ProtocolConfiguration: ProtocolConfiguration,
    HttpConfiguration: HttpConfiguration,
    HttpHeader: HttpHeader,
    ConnectivityInformation: ConnectivityInformation,
    ConnectivityHop: ConnectivityHop,
    HopLink: HopLink,
    ConnectivityIssue: ConnectivityIssue,
    AzureReachabilityReportParameters: AzureReachabilityReportParameters,
    AzureReachabilityReportLocation: AzureReachabilityReportLocation,
    AzureReachabilityReport: AzureReachabilityReport,
    AzureReachabilityReportItem: AzureReachabilityReportItem,
    AzureReachabilityReportLatencyInfo: AzureReachabilityReportLatencyInfo,
    AvailableProvidersListParameters: AvailableProvidersListParameters,
    AvailableProvidersList: AvailableProvidersList,
    AvailableProvidersListCountry: AvailableProvidersListCountry,
    AvailableProvidersListState: AvailableProvidersListState,
    AvailableProvidersListCity: AvailableProvidersListCity,
    NetworkConfigurationDiagnosticParameters: NetworkConfigurationDiagnosticParameters,
    NetworkConfigurationDiagnosticProfile: NetworkConfigurationDiagnosticProfile,
    NetworkConfigurationDiagnosticResponse: NetworkConfigurationDiagnosticResponse,
    NetworkConfigurationDiagnosticResult: NetworkConfigurationDiagnosticResult,
    NetworkSecurityGroupResult: NetworkSecurityGroupResult,
    EvaluatedNetworkSecurityGroup: EvaluatedNetworkSecurityGroup,
    MatchedRule: MatchedRule,
    NetworkSecurityRulesEvaluationResult: NetworkSecurityRulesEvaluationResult,
    ConnectionMonitor: ConnectionMonitor,
    ConnectionMonitorParameters: ConnectionMonitorParameters,
    ConnectionMonitorSource: ConnectionMonitorSource,
    ConnectionMonitorDestination: ConnectionMonitorDestination,
    ConnectionMonitorEndpoint: ConnectionMonitorEndpoint,
    ConnectionMonitorEndpointFilter: ConnectionMonitorEndpointFilter,
    ConnectionMonitorEndpointFilterItem: ConnectionMonitorEndpointFilterItem,
    ConnectionMonitorEndpointScope: ConnectionMonitorEndpointScope,
    ConnectionMonitorEndpointScopeItem: ConnectionMonitorEndpointScopeItem,
    ConnectionMonitorTestConfiguration: ConnectionMonitorTestConfiguration,
    ConnectionMonitorHttpConfiguration: ConnectionMonitorHttpConfiguration,
    ConnectionMonitorTcpConfiguration: ConnectionMonitorTcpConfiguration,
    ConnectionMonitorIcmpConfiguration: ConnectionMonitorIcmpConfiguration,
    ConnectionMonitorSuccessThreshold: ConnectionMonitorSuccessThreshold,
    ConnectionMonitorTestGroup: ConnectionMonitorTestGroup,
    ConnectionMonitorOutput: ConnectionMonitorOutput,
    ConnectionMonitorWorkspaceSettings: ConnectionMonitorWorkspaceSettings,
    ConnectionMonitorResult: ConnectionMonitorResult,
    ConnectionMonitorQueryResult: ConnectionMonitorQueryResult,
    ConnectionStateSnapshot: ConnectionStateSnapshot,
    ConnectionMonitorListResult: ConnectionMonitorListResult,
    FlowLogListResult: FlowLogListResult,
    OperationListResult: OperationListResult,
    Operation: Operation,
    OperationDisplay: OperationDisplay,
    OperationPropertiesFormatServiceSpecification: OperationPropertiesFormatServiceSpecification,
    MetricSpecification: MetricSpecification,
    Availability: Availability,
    Dimension: Dimension,
    LogSpecification: LogSpecification,
    PrivateEndpointListResult: PrivateEndpointListResult,
    AvailablePrivateEndpointTypesResult: AvailablePrivateEndpointTypesResult,
    AvailablePrivateEndpointType: AvailablePrivateEndpointType,
    PrivateDnsZoneConfig: PrivateDnsZoneConfig,
    RecordSet: RecordSet,
    PrivateDnsZoneGroupListResult: PrivateDnsZoneGroupListResult,
    PrivateLinkServiceListResult: PrivateLinkServiceListResult,
    PrivateEndpointConnectionListResult: PrivateEndpointConnectionListResult,
    CheckPrivateLinkServiceVisibilityRequest: CheckPrivateLinkServiceVisibilityRequest,
    PrivateLinkServiceVisibility: PrivateLinkServiceVisibility,
    AutoApprovedPrivateLinkServicesResult: AutoApprovedPrivateLinkServicesResult,
    AutoApprovedPrivateLinkService: AutoApprovedPrivateLinkService,
    PublicIPPrefixSku: PublicIPPrefixSku,
    ReferencedPublicIpAddress: ReferencedPublicIpAddress,
    PublicIPPrefixListResult: PublicIPPrefixListResult,
    RouteFilterListResult: RouteFilterListResult,
    RouteFilterRuleListResult: RouteFilterRuleListResult,
    RouteTableListResult: RouteTableListResult,
    RouteListResult: RouteListResult,
    SecurityPartnerProviderListResult: SecurityPartnerProviderListResult,
    BgpServiceCommunityListResult: BgpServiceCommunityListResult,
    BGPCommunity: BGPCommunity,
    ServiceEndpointPolicyListResult: ServiceEndpointPolicyListResult,
    ServiceEndpointPolicyDefinitionListResult: ServiceEndpointPolicyDefinitionListResult,
    ServiceTagsListResult: ServiceTagsListResult,
    ServiceTagInformation: ServiceTagInformation,
    ServiceTagInformationPropertiesFormat: ServiceTagInformationPropertiesFormat,
    ServiceTagInformationListResult: ServiceTagInformationListResult,
    UsagesListResult: UsagesListResult,
    Usage: Usage,
    UsageName: UsageName,
    AddressSpace: AddressSpace,
    DhcpOptions: DhcpOptions,
    VirtualNetworkBgpCommunities: VirtualNetworkBgpCommunities,
    VirtualNetworkEncryption: VirtualNetworkEncryption,
    VirtualNetworkListResult: VirtualNetworkListResult,
    PrepareNetworkPoliciesRequest: PrepareNetworkPoliciesRequest,
    NetworkIntentPolicyConfiguration: NetworkIntentPolicyConfiguration,
    UnprepareNetworkPoliciesRequest: UnprepareNetworkPoliciesRequest,
    ResourceNavigationLinksListResult: ResourceNavigationLinksListResult,
    ServiceAssociationLinksListResult: ServiceAssociationLinksListResult,
    SubnetListResult: SubnetListResult,
    VirtualNetworkPeeringListResult: VirtualNetworkPeeringListResult,
    IPAddressAvailabilityResult: IPAddressAvailabilityResult,
    VirtualNetworkListUsageResult: VirtualNetworkListUsageResult,
    VirtualNetworkUsage: VirtualNetworkUsage,
    VirtualNetworkUsageName: VirtualNetworkUsageName,
    VirtualNetworkGatewaySku: VirtualNetworkGatewaySku,
    VpnClientConfiguration: VpnClientConfiguration,
    IpsecPolicy: IpsecPolicy,
    RadiusServer: RadiusServer,
    BgpSettings: BgpSettings,
    IPConfigurationBgpPeeringAddress: IPConfigurationBgpPeeringAddress,
    VpnNatRuleMapping: VpnNatRuleMapping,
    VirtualNetworkGatewayListResult: VirtualNetworkGatewayListResult,
    VirtualNetworkGatewayListConnectionsResult: VirtualNetworkGatewayListConnectionsResult,
    VirtualNetworkConnectionGatewayReference: VirtualNetworkConnectionGatewayReference,
    TunnelConnectionHealth: TunnelConnectionHealth,
    TrafficSelectorPolicy: TrafficSelectorPolicy,
    VpnClientParameters: VpnClientParameters,
    BgpPeerStatusListResult: BgpPeerStatusListResult,
    BgpPeerStatus: BgpPeerStatus,
    GatewayRouteListResult: GatewayRouteListResult,
    GatewayRoute: GatewayRoute,
    VpnClientIPsecParameters: VpnClientIPsecParameters,
    VpnDeviceScriptParameters: VpnDeviceScriptParameters,
    VpnPacketCaptureStartParameters: VpnPacketCaptureStartParameters,
    VpnPacketCaptureStopParameters: VpnPacketCaptureStopParameters,
    VirtualNetworkGatewayConnectionListResult: VirtualNetworkGatewayConnectionListResult,
    ConnectionResetSharedKey: ConnectionResetSharedKey,
    LocalNetworkGatewayListResult: LocalNetworkGatewayListResult,
    VpnClientConnectionHealthDetailListResult: VpnClientConnectionHealthDetailListResult,
    VpnClientConnectionHealthDetail: VpnClientConnectionHealthDetail,
    P2SVpnConnectionRequest: P2SVpnConnectionRequest,
    ListVirtualNetworkGatewayNatRulesResult: ListVirtualNetworkGatewayNatRulesResult,
    VirtualNetworkTapListResult: VirtualNetworkTapListResult,
    VirtualRouterListResult: VirtualRouterListResult,
    VirtualRouterPeeringListResult: VirtualRouterPeeringListResult,
    ListVirtualWANsResult: ListVirtualWANsResult,
    DeviceProperties: DeviceProperties,
    VpnLinkProviderProperties: VpnLinkProviderProperties,
    VpnLinkBgpSettings: VpnLinkBgpSettings,
    O365PolicyProperties: O365PolicyProperties,
    O365BreakOutCategoryPolicies: O365BreakOutCategoryPolicies,
    ListVpnSitesResult: ListVpnSitesResult,
    ListVpnSiteLinksResult: ListVpnSiteLinksResult,
    GetVpnSitesConfigurationRequest: GetVpnSitesConfigurationRequest,
    VirtualWanSecurityProviders: VirtualWanSecurityProviders,
    VirtualWanSecurityProvider: VirtualWanSecurityProvider,
    VpnServerConfigVpnClientRootCertificate: VpnServerConfigVpnClientRootCertificate,
    VpnServerConfigVpnClientRevokedCertificate: VpnServerConfigVpnClientRevokedCertificate,
    VpnServerConfigRadiusServerRootCertificate: VpnServerConfigRadiusServerRootCertificate,
    VpnServerConfigRadiusClientRootCertificate: VpnServerConfigRadiusClientRootCertificate,
    AadAuthenticationParameters: AadAuthenticationParameters,
    RoutingConfiguration: RoutingConfiguration,
    PropagatedRouteTable: PropagatedRouteTable,
    VnetRoute: VnetRoute,
    StaticRoute: StaticRoute,
    VpnClientConnectionHealth: VpnClientConnectionHealth,
    ListVpnServerConfigurationsResult: ListVpnServerConfigurationsResult,
    VirtualHubRouteTable: VirtualHubRouteTable,
    VirtualHubRoute: VirtualHubRoute,
    VirtualHubRouteV2: VirtualHubRouteV2,
    ListVirtualHubsResult: ListVirtualHubsResult,
    ListHubVirtualNetworkConnectionsResult: ListHubVirtualNetworkConnectionsResult,
    VpnGatewayIpConfiguration: VpnGatewayIpConfiguration,
    VpnGatewayPacketCaptureStartParameters: VpnGatewayPacketCaptureStartParameters,
    VpnGatewayPacketCaptureStopParameters: VpnGatewayPacketCaptureStopParameters,
    ListVpnGatewaysResult: ListVpnGatewaysResult,
    VpnConnectionPacketCaptureStartParameters: VpnConnectionPacketCaptureStartParameters,
    VpnConnectionPacketCaptureStopParameters: VpnConnectionPacketCaptureStopParameters,
    ListVpnConnectionsResult: ListVpnConnectionsResult,
    ListVpnSiteLinkConnectionsResult: ListVpnSiteLinkConnectionsResult,
    ListVpnGatewayNatRulesResult: ListVpnGatewayNatRulesResult,
    ListP2SVpnGatewaysResult: ListP2SVpnGatewaysResult,
    P2SVpnProfileParameters: P2SVpnProfileParameters,
    VpnProfileResponse: VpnProfileResponse,
    P2SVpnConnectionHealthRequest: P2SVpnConnectionHealthRequest,
    P2SVpnConnectionHealth: P2SVpnConnectionHealth,
    VpnServerConfigurationsResponse: VpnServerConfigurationsResponse,
    VirtualWanVpnProfileParameters: VirtualWanVpnProfileParameters,
    ListVirtualHubRouteTableV2SResult: ListVirtualHubRouteTableV2SResult,
    ExpressRouteGatewayList: ExpressRouteGatewayList,
    ExpressRouteGatewayPropertiesAutoScaleConfiguration: ExpressRouteGatewayPropertiesAutoScaleConfiguration,
    ExpressRouteGatewayPropertiesAutoScaleConfigurationBounds: ExpressRouteGatewayPropertiesAutoScaleConfigurationBounds,
    ExpressRouteCircuitPeeringId: ExpressRouteCircuitPeeringId,
    VirtualHubId: VirtualHubId,
    ExpressRouteConnectionList: ExpressRouteConnectionList,
    ListVirtualHubBgpConnectionResults: ListVirtualHubBgpConnectionResults,
    PeerRouteList: PeerRouteList,
    PeerRoute: PeerRoute,
    ListVirtualHubIpConfigurationResults: ListVirtualHubIpConfigurationResults,
    HubRoute: HubRoute,
    ListHubRouteTablesResult: ListHubRouteTablesResult,
    EffectiveRoutesParameters: EffectiveRoutesParameters,
    RoutingPolicy: RoutingPolicy,
    ListRoutingIntentResult: ListRoutingIntentResult,
    WebApplicationFirewallPolicyListResult: WebApplicationFirewallPolicyListResult,
    PolicySettings: PolicySettings,
    WebApplicationFirewallCustomRule: WebApplicationFirewallCustomRule,
    MatchCondition: MatchCondition,
    MatchVariable: MatchVariable,
    ManagedRulesDefinition: ManagedRulesDefinition,
    OwaspCrsExclusionEntry: OwaspCrsExclusionEntry,
    ExclusionManagedRuleSet: ExclusionManagedRuleSet,
    ExclusionManagedRuleGroup: ExclusionManagedRuleGroup,
    ExclusionManagedRule: ExclusionManagedRule,
    ManagedRuleSet: ManagedRuleSet,
    ManagedRuleGroupOverride: ManagedRuleGroupOverride,
    ManagedRuleOverride: ManagedRuleOverride,
    FirewallPolicyNatRuleCollectionAction: FirewallPolicyNatRuleCollectionAction,
    FirewallPolicyRule: FirewallPolicyRule,
    FirewallPolicyFilterRuleCollectionAction: FirewallPolicyFilterRuleCollectionAction,
    FirewallPolicyRuleApplicationProtocol: FirewallPolicyRuleApplicationProtocol,
    AzureAsyncOperationResult: AzureAsyncOperationResult,
    VpnSiteId: VpnSiteId,
    VirtualHubEffectiveRouteList: VirtualHubEffectiveRouteList,
    VirtualHubEffectiveRoute: VirtualHubEffectiveRoute,
    ApplicationGatewayIPConfiguration: ApplicationGatewayIPConfiguration,
    ApplicationGatewayAuthenticationCertificate: ApplicationGatewayAuthenticationCertificate,
    ApplicationGatewayTrustedRootCertificate: ApplicationGatewayTrustedRootCertificate,
    ApplicationGatewayTrustedClientCertificate: ApplicationGatewayTrustedClientCertificate,
    ApplicationGatewaySslCertificate: ApplicationGatewaySslCertificate,
    ApplicationGatewayFrontendIPConfiguration: ApplicationGatewayFrontendIPConfiguration,
    ApplicationGatewayFrontendPort: ApplicationGatewayFrontendPort,
    ApplicationGatewayProbe: ApplicationGatewayProbe,
    NetworkInterfaceTapConfiguration: NetworkInterfaceTapConfiguration,
    SecurityRule: SecurityRule,
    PrivateLinkServiceConnection: PrivateLinkServiceConnection,
    PrivateLinkServiceIpConfiguration: PrivateLinkServiceIpConfiguration,
    PrivateEndpointConnection: PrivateEndpointConnection,
    Route: Route,
    ServiceEndpointPolicyDefinition: ServiceEndpointPolicyDefinition,
    IPConfiguration: IPConfiguration,
    IPConfigurationProfile: IPConfigurationProfile,
    ResourceNavigationLink: ResourceNavigationLink,
    ServiceAssociationLink: ServiceAssociationLink,
    Delegation: Delegation,
    Subnet: Subnet,
    FrontendIPConfiguration: FrontendIPConfiguration,
    BackendAddressPool: BackendAddressPool,
    InboundNatRule: InboundNatRule,
    NetworkInterfaceIPConfiguration: NetworkInterfaceIPConfiguration,
    ApplicationGatewayBackendAddressPool: ApplicationGatewayBackendAddressPool,
    ApplicationGatewayBackendHttpSettings: ApplicationGatewayBackendHttpSettings,
    ApplicationGatewayHttpListener: ApplicationGatewayHttpListener,
    ApplicationGatewaySslProfile: ApplicationGatewaySslProfile,
    ApplicationGatewayPathRule: ApplicationGatewayPathRule,
    ApplicationGatewayUrlPathMap: ApplicationGatewayUrlPathMap,
    ApplicationGatewayRequestRoutingRule: ApplicationGatewayRequestRoutingRule,
    ApplicationGatewayRewriteRuleSet: ApplicationGatewayRewriteRuleSet,
    ApplicationGatewayRedirectConfiguration: ApplicationGatewayRedirectConfiguration,
    ApplicationGatewayPrivateLinkIpConfiguration: ApplicationGatewayPrivateLinkIpConfiguration,
    ApplicationGatewayPrivateLinkConfiguration: ApplicationGatewayPrivateLinkConfiguration,
    ApplicationGatewayPrivateEndpointConnection: ApplicationGatewayPrivateEndpointConnection,
    ApplicationGatewayLoadDistributionTarget: ApplicationGatewayLoadDistributionTarget,
    ApplicationGatewayLoadDistributionPolicy: ApplicationGatewayLoadDistributionPolicy,
    ApplicationGatewayPrivateLinkResource: ApplicationGatewayPrivateLinkResource,
    ApplicationGatewaySslPredefinedPolicy: ApplicationGatewaySslPredefinedPolicy,
    AzureFirewallApplicationRuleCollection: AzureFirewallApplicationRuleCollection,
    AzureFirewallNatRuleCollection: AzureFirewallNatRuleCollection,
    AzureFirewallNetworkRuleCollection: AzureFirewallNetworkRuleCollection,
    AzureFirewallIPConfiguration: AzureFirewallIPConfiguration,
    BastionHostIPConfiguration: BastionHostIPConfiguration,
    EndpointServiceResult: EndpointServiceResult,
    ExpressRouteCircuitAuthorization: ExpressRouteCircuitAuthorization,
    ExpressRouteCircuitConnection: ExpressRouteCircuitConnection,
    PeerExpressRouteCircuitConnection: PeerExpressRouteCircuitConnection,
    ExpressRouteCircuitPeering: ExpressRouteCircuitPeering,
    ExpressRouteCrossConnectionPeering: ExpressRouteCrossConnectionPeering,
    ExpressRouteLink: ExpressRouteLink,
    FirewallPolicyRuleCollectionGroup: FirewallPolicyRuleCollectionGroup,
    LoadBalancingRule: LoadBalancingRule,
    Probe: Probe,
    InboundNatPool: InboundNatPool,
    OutboundRule: OutboundRule,
    ContainerNetworkInterfaceConfiguration: ContainerNetworkInterfaceConfiguration,
    Container: Container,
    ContainerNetworkInterface: ContainerNetworkInterface,
    VirtualApplianceSite: VirtualApplianceSite,
    InboundSecurityRule: InboundSecurityRule,
    PrivateDnsZoneGroup: PrivateDnsZoneGroup,
    RouteFilterRule: RouteFilterRule,
    VirtualNetworkPeering: VirtualNetworkPeering,
    VirtualNetworkGatewayIPConfiguration: VirtualNetworkGatewayIPConfiguration,
    VpnClientRootCertificate: VpnClientRootCertificate,
    VpnClientRevokedCertificate: VpnClientRevokedCertificate,
    VirtualNetworkGatewayNatRule: VirtualNetworkGatewayNatRule,
    ConnectionSharedKey: ConnectionSharedKey,
    VirtualRouterPeering: VirtualRouterPeering,
    VpnSiteLink: VpnSiteLink,
    P2SConnectionConfiguration: P2SConnectionConfiguration,
    VirtualHubRouteTableV2: VirtualHubRouteTableV2,
    HubVirtualNetworkConnection: HubVirtualNetworkConnection,
    VpnSiteLinkConnection: VpnSiteLinkConnection,
    VpnConnection: VpnConnection,
    VpnGatewayNatRule: VpnGatewayNatRule,
    ExpressRouteConnection: ExpressRouteConnection,
    BgpConnection: BgpConnection,
    HubIpConfiguration: HubIpConfiguration,
    HubRouteTable: HubRouteTable,
    RoutingIntent: RoutingIntent,
    PatchRouteFilterRule: PatchRouteFilterRule,
    PatchRouteFilter: PatchRouteFilter,
    ApplicationSecurityGroup: ApplicationSecurityGroup,
    PrivateEndpoint: PrivateEndpoint,
    PrivateLinkService: PrivateLinkService,
    NetworkInterface: NetworkInterface,
    FlowLog: FlowLog,
    NetworkSecurityGroup: NetworkSecurityGroup,
    RouteTable: RouteTable,
    ServiceEndpointPolicy: ServiceEndpointPolicy,
    NatGateway: NatGateway,
    PublicIPAddress: PublicIPAddress,
    VirtualNetworkTap: VirtualNetworkTap,
    ApplicationGateway: ApplicationGateway,
    ApplicationGatewayFirewallRuleSet: ApplicationGatewayFirewallRuleSet,
    ApplicationGatewayAvailableSslOptions: ApplicationGatewayAvailableSslOptions,
    AzureFirewall: AzureFirewall,
    AzureFirewallFqdnTag: AzureFirewallFqdnTag,
    BastionHost: BastionHost,
    Vm: Vm,
    CustomIpPrefix: CustomIpPrefix,
    DdosCustomPolicy: DdosCustomPolicy,
    DscpConfiguration: DscpConfiguration,
    ExpressRouteCircuit: ExpressRouteCircuit,
    ExpressRouteServiceProvider: ExpressRouteServiceProvider,
    ExpressRouteCrossConnection: ExpressRouteCrossConnection,
    ExpressRoutePortsLocation: ExpressRoutePortsLocation,
    ExpressRoutePort: ExpressRoutePort,
    FirewallPolicy: FirewallPolicy,
    IpAllocation: IpAllocation,
    IpGroup: IpGroup,
    LoadBalancer: LoadBalancer,
    NetworkProfile: NetworkProfile,
    NetworkVirtualAppliance: NetworkVirtualAppliance,
    NetworkVirtualApplianceSku: NetworkVirtualApplianceSku,
    NetworkWatcher: NetworkWatcher,
    PublicIPPrefix: PublicIPPrefix,
    RouteFilter: RouteFilter,
    SecurityPartnerProvider: SecurityPartnerProvider,
    BgpServiceCommunity: BgpServiceCommunity,
    VirtualNetwork: VirtualNetwork,
    NetworkIntentPolicy: NetworkIntentPolicy,
    VirtualNetworkGateway: VirtualNetworkGateway,
    VirtualNetworkGatewayConnectionListEntity: VirtualNetworkGatewayConnectionListEntity,
    LocalNetworkGateway: LocalNetworkGateway,
    VirtualNetworkGatewayConnection: VirtualNetworkGatewayConnection,
    VirtualRouter: VirtualRouter,
    VirtualWAN: VirtualWAN,
    VpnSite: VpnSite,
    P2SVpnGateway: P2SVpnGateway,
    VpnServerConfiguration: VpnServerConfiguration,
    VirtualHub: VirtualHub,
    VpnGateway: VpnGateway,
    ExpressRouteGateway: ExpressRouteGateway,
    WebApplicationFirewallPolicy: WebApplicationFirewallPolicy,
    PrivateLinkServicePropertiesVisibility: PrivateLinkServicePropertiesVisibility,
    PrivateLinkServicePropertiesAutoApproval: PrivateLinkServicePropertiesAutoApproval,
    FirewallPolicyNatRuleCollection: FirewallPolicyNatRuleCollection,
    FirewallPolicyFilterRuleCollection: FirewallPolicyFilterRuleCollection,
    PacketCaptureResultProperties: PacketCaptureResultProperties,
    ConnectionMonitorResultProperties: ConnectionMonitorResultProperties,
    ApplicationRule: ApplicationRule,
    NatRule: NatRule,
    NetworkRule: NetworkRule,
    discriminators: discriminators
});

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const accept = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String"
        }
    }
};
const $host = {
    parameterPath: "$host",
    mapper: {
        serializedName: "$host",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const resourceGroupName = {
    parameterPath: "resourceGroupName",
    mapper: {
        serializedName: "resourceGroupName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const applicationGatewayName = {
    parameterPath: "applicationGatewayName",
    mapper: {
        serializedName: "applicationGatewayName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const apiVersion = {
    parameterPath: "apiVersion",
    mapper: {
        defaultValue: "2021-05-01",
        isConstant: true,
        serializedName: "api-version",
        type: {
            name: "String"
        }
    }
};
const subscriptionId = {
    parameterPath: "subscriptionId",
    mapper: {
        serializedName: "subscriptionId",
        required: true,
        type: {
            name: "String"
        }
    }
};
const contentType = {
    parameterPath: ["options", "contentType"],
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Content-Type",
        type: {
            name: "String"
        }
    }
};
const parameters = {
    parameterPath: "parameters",
    mapper: ApplicationGateway
};
const parameters1 = {
    parameterPath: "parameters",
    mapper: TagsObject
};
const expand = {
    parameterPath: ["options", "expand"],
    mapper: {
        serializedName: "$expand",
        type: {
            name: "String"
        }
    }
};
const probeRequest = {
    parameterPath: "probeRequest",
    mapper: ApplicationGatewayOnDemandProbe
};
const predefinedPolicyName = {
    parameterPath: "predefinedPolicyName",
    mapper: {
        serializedName: "predefinedPolicyName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const nextLink = {
    parameterPath: "nextLink",
    mapper: {
        serializedName: "nextLink",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const connectionName = {
    parameterPath: "connectionName",
    mapper: {
        serializedName: "connectionName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters2 = {
    parameterPath: "parameters",
    mapper: ApplicationGatewayPrivateEndpointConnection
};
const applicationSecurityGroupName = {
    parameterPath: "applicationSecurityGroupName",
    mapper: {
        serializedName: "applicationSecurityGroupName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters3 = {
    parameterPath: "parameters",
    mapper: ApplicationSecurityGroup
};
const location = {
    parameterPath: "location",
    mapper: {
        serializedName: "location",
        required: true,
        type: {
            name: "String"
        }
    }
};
const azureFirewallName = {
    parameterPath: "azureFirewallName",
    mapper: {
        serializedName: "azureFirewallName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters4 = {
    parameterPath: "parameters",
    mapper: AzureFirewall
};
const azureFirewallName1 = {
    parameterPath: "azureFirewallName",
    mapper: {
        constraints: {
            MaxLength: 56,
            MinLength: 1
        },
        serializedName: "azureFirewallName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const name = {
    parameterPath: "name",
    mapper: {
        serializedName: "name",
        required: true,
        type: {
            name: "String"
        }
    }
};
const bastionHostName = {
    parameterPath: "bastionHostName",
    mapper: {
        serializedName: "bastionHostName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters5 = {
    parameterPath: "parameters",
    mapper: BastionHost
};
const bslRequest = {
    parameterPath: "bslRequest",
    mapper: BastionShareableLinkListRequest
};
const sessionIds = {
    parameterPath: "sessionIds",
    mapper: SessionIds
};
const domainNameLabel = {
    parameterPath: "domainNameLabel",
    mapper: {
        serializedName: "domainNameLabel",
        required: true,
        type: {
            name: "String"
        }
    }
};
const virtualWANName = {
    parameterPath: "virtualWANName",
    mapper: {
        serializedName: "virtualWANName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const vpnClientParams = {
    parameterPath: "vpnClientParams",
    mapper: VirtualWanVpnProfileParameters
};
const cloudServiceName = {
    parameterPath: "cloudServiceName",
    mapper: {
        serializedName: "cloudServiceName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const roleInstanceName = {
    parameterPath: "roleInstanceName",
    mapper: {
        serializedName: "roleInstanceName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const networkInterfaceName = {
    parameterPath: "networkInterfaceName",
    mapper: {
        serializedName: "networkInterfaceName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters6 = {
    parameterPath: "parameters",
    mapper: NetworkInterface
};
const virtualMachineScaleSetName = {
    parameterPath: "virtualMachineScaleSetName",
    mapper: {
        serializedName: "virtualMachineScaleSetName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const virtualmachineIndex = {
    parameterPath: "virtualmachineIndex",
    mapper: {
        serializedName: "virtualmachineIndex",
        required: true,
        type: {
            name: "String"
        }
    }
};
const apiVersion1 = {
    parameterPath: "apiVersion",
    mapper: {
        defaultValue: "2018-10-01",
        isConstant: true,
        serializedName: "api-version",
        type: {
            name: "String"
        }
    }
};
const ipConfigurationName = {
    parameterPath: "ipConfigurationName",
    mapper: {
        serializedName: "ipConfigurationName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const publicIpAddressName = {
    parameterPath: "publicIpAddressName",
    mapper: {
        serializedName: "publicIpAddressName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters7 = {
    parameterPath: "parameters",
    mapper: PublicIPAddress
};
const customIpPrefixName = {
    parameterPath: "customIpPrefixName",
    mapper: {
        serializedName: "customIpPrefixName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters8 = {
    parameterPath: "parameters",
    mapper: CustomIpPrefix
};
const ddosCustomPolicyName = {
    parameterPath: "ddosCustomPolicyName",
    mapper: {
        serializedName: "ddosCustomPolicyName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters9 = {
    parameterPath: "parameters",
    mapper: DdosCustomPolicy
};
const ddosProtectionPlanName = {
    parameterPath: "ddosProtectionPlanName",
    mapper: {
        serializedName: "ddosProtectionPlanName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters10 = {
    parameterPath: "parameters",
    mapper: DdosProtectionPlan
};
const parameters11 = {
    parameterPath: "parameters",
    mapper: DscpConfiguration
};
const dscpConfigurationName = {
    parameterPath: "dscpConfigurationName",
    mapper: {
        serializedName: "dscpConfigurationName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const circuitName = {
    parameterPath: "circuitName",
    mapper: {
        serializedName: "circuitName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const authorizationName = {
    parameterPath: "authorizationName",
    mapper: {
        serializedName: "authorizationName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const authorizationParameters = {
    parameterPath: "authorizationParameters",
    mapper: ExpressRouteCircuitAuthorization
};
const peeringName = {
    parameterPath: "peeringName",
    mapper: {
        serializedName: "peeringName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const peeringParameters = {
    parameterPath: "peeringParameters",
    mapper: ExpressRouteCircuitPeering
};
const expressRouteCircuitConnectionParameters = {
    parameterPath: "expressRouteCircuitConnectionParameters",
    mapper: ExpressRouteCircuitConnection
};
const parameters12 = {
    parameterPath: "parameters",
    mapper: ExpressRouteCircuit
};
const devicePath = {
    parameterPath: "devicePath",
    mapper: {
        serializedName: "devicePath",
        required: true,
        type: {
            name: "String"
        }
    }
};
const crossConnectionName = {
    parameterPath: "crossConnectionName",
    mapper: {
        serializedName: "crossConnectionName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters13 = {
    parameterPath: "parameters",
    mapper: ExpressRouteCrossConnection
};
const crossConnectionParameters = {
    parameterPath: "crossConnectionParameters",
    mapper: TagsObject
};
const peeringParameters1 = {
    parameterPath: "peeringParameters",
    mapper: ExpressRouteCrossConnectionPeering
};
const locationName = {
    parameterPath: "locationName",
    mapper: {
        serializedName: "locationName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const expressRoutePortName = {
    parameterPath: "expressRoutePortName",
    mapper: {
        serializedName: "expressRoutePortName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters14 = {
    parameterPath: "parameters",
    mapper: ExpressRoutePort
};
const request = {
    parameterPath: "request",
    mapper: GenerateExpressRoutePortsLOARequest
};
const linkName = {
    parameterPath: "linkName",
    mapper: {
        serializedName: "linkName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const firewallPolicyName = {
    parameterPath: "firewallPolicyName",
    mapper: {
        serializedName: "firewallPolicyName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters15 = {
    parameterPath: "parameters",
    mapper: FirewallPolicy
};
const ruleCollectionGroupName = {
    parameterPath: "ruleCollectionGroupName",
    mapper: {
        serializedName: "ruleCollectionGroupName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters16 = {
    parameterPath: "parameters",
    mapper: FirewallPolicyRuleCollectionGroup
};
const parameters17 = {
    parameterPath: "parameters",
    mapper: IdpsQueryObject
};
const parameters18 = {
    parameterPath: "parameters",
    mapper: SignaturesOverrides
};
const parameters19 = {
    parameterPath: "parameters",
    mapper: SignatureOverridesFilterValuesQuery
};
const ipAllocationName = {
    parameterPath: "ipAllocationName",
    mapper: {
        serializedName: "ipAllocationName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters20 = {
    parameterPath: "parameters",
    mapper: IpAllocation
};
const ipGroupsName = {
    parameterPath: "ipGroupsName",
    mapper: {
        serializedName: "ipGroupsName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters21 = {
    parameterPath: "parameters",
    mapper: IpGroup
};
const loadBalancerName = {
    parameterPath: "loadBalancerName",
    mapper: {
        serializedName: "loadBalancerName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters22 = {
    parameterPath: "parameters",
    mapper: LoadBalancer
};
const parameters23 = {
    parameterPath: "parameters",
    mapper: LoadBalancerVipSwapRequest
};
const parameters24 = {
    parameterPath: "parameters",
    mapper: QueryInboundNatRulePortMappingRequest
};
const groupName = {
    parameterPath: "groupName",
    mapper: {
        serializedName: "groupName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const backendPoolName = {
    parameterPath: "backendPoolName",
    mapper: {
        serializedName: "backendPoolName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const backendAddressPoolName = {
    parameterPath: "backendAddressPoolName",
    mapper: {
        serializedName: "backendAddressPoolName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters25 = {
    parameterPath: "parameters",
    mapper: BackendAddressPool
};
const frontendIPConfigurationName = {
    parameterPath: "frontendIPConfigurationName",
    mapper: {
        serializedName: "frontendIPConfigurationName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const inboundNatRuleName = {
    parameterPath: "inboundNatRuleName",
    mapper: {
        serializedName: "inboundNatRuleName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const inboundNatRuleParameters = {
    parameterPath: "inboundNatRuleParameters",
    mapper: InboundNatRule
};
const loadBalancingRuleName = {
    parameterPath: "loadBalancingRuleName",
    mapper: {
        serializedName: "loadBalancingRuleName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const outboundRuleName = {
    parameterPath: "outboundRuleName",
    mapper: {
        serializedName: "outboundRuleName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const probeName = {
    parameterPath: "probeName",
    mapper: {
        serializedName: "probeName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const natGatewayName = {
    parameterPath: "natGatewayName",
    mapper: {
        serializedName: "natGatewayName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters26 = {
    parameterPath: "parameters",
    mapper: NatGateway
};
const tapConfigurationName = {
    parameterPath: "tapConfigurationName",
    mapper: {
        serializedName: "tapConfigurationName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const tapConfigurationParameters = {
    parameterPath: "tapConfigurationParameters",
    mapper: NetworkInterfaceTapConfiguration
};
const networkProfileName = {
    parameterPath: "networkProfileName",
    mapper: {
        serializedName: "networkProfileName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters27 = {
    parameterPath: "parameters",
    mapper: NetworkProfile
};
const networkSecurityGroupName = {
    parameterPath: "networkSecurityGroupName",
    mapper: {
        serializedName: "networkSecurityGroupName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters28 = {
    parameterPath: "parameters",
    mapper: NetworkSecurityGroup
};
const securityRuleName = {
    parameterPath: "securityRuleName",
    mapper: {
        serializedName: "securityRuleName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const securityRuleParameters = {
    parameterPath: "securityRuleParameters",
    mapper: SecurityRule
};
const defaultSecurityRuleName = {
    parameterPath: "defaultSecurityRuleName",
    mapper: {
        serializedName: "defaultSecurityRuleName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const networkVirtualApplianceName = {
    parameterPath: "networkVirtualApplianceName",
    mapper: {
        serializedName: "networkVirtualApplianceName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters29 = {
    parameterPath: "parameters",
    mapper: NetworkVirtualAppliance
};
const siteName = {
    parameterPath: "siteName",
    mapper: {
        serializedName: "siteName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters30 = {
    parameterPath: "parameters",
    mapper: VirtualApplianceSite
};
const skuName = {
    parameterPath: "skuName",
    mapper: {
        serializedName: "skuName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters31 = {
    parameterPath: "parameters",
    mapper: InboundSecurityRule
};
const ruleCollectionName = {
    parameterPath: "ruleCollectionName",
    mapper: {
        serializedName: "ruleCollectionName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters32 = {
    parameterPath: "parameters",
    mapper: NetworkWatcher
};
const networkWatcherName = {
    parameterPath: "networkWatcherName",
    mapper: {
        serializedName: "networkWatcherName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters33 = {
    parameterPath: "parameters",
    mapper: TopologyParameters
};
const parameters34 = {
    parameterPath: "parameters",
    mapper: VerificationIPFlowParameters
};
const parameters35 = {
    parameterPath: "parameters",
    mapper: NextHopParameters
};
const parameters36 = {
    parameterPath: "parameters",
    mapper: SecurityGroupViewParameters
};
const parameters37 = {
    parameterPath: "parameters",
    mapper: TroubleshootingParameters
};
const parameters38 = {
    parameterPath: "parameters",
    mapper: QueryTroubleshootingParameters
};
const parameters39 = {
    parameterPath: "parameters",
    mapper: FlowLogInformation
};
const parameters40 = {
    parameterPath: "parameters",
    mapper: FlowLogStatusParameters
};
const parameters41 = {
    parameterPath: "parameters",
    mapper: ConnectivityParameters
};
const parameters42 = {
    parameterPath: "parameters",
    mapper: AzureReachabilityReportParameters
};
const parameters43 = {
    parameterPath: "parameters",
    mapper: AvailableProvidersListParameters
};
const parameters44 = {
    parameterPath: "parameters",
    mapper: NetworkConfigurationDiagnosticParameters
};
const parameters45 = {
    parameterPath: "parameters",
    mapper: PacketCapture
};
const packetCaptureName = {
    parameterPath: "packetCaptureName",
    mapper: {
        serializedName: "packetCaptureName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters46 = {
    parameterPath: "parameters",
    mapper: ConnectionMonitor
};
const connectionMonitorName = {
    parameterPath: "connectionMonitorName",
    mapper: {
        serializedName: "connectionMonitorName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const migrate = {
    parameterPath: ["options", "migrate"],
    mapper: {
        serializedName: "migrate",
        type: {
            name: "String"
        }
    }
};
const parameters47 = {
    parameterPath: "parameters",
    mapper: FlowLog
};
const flowLogName = {
    parameterPath: "flowLogName",
    mapper: {
        serializedName: "flowLogName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const privateEndpointName = {
    parameterPath: "privateEndpointName",
    mapper: {
        serializedName: "privateEndpointName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters48 = {
    parameterPath: "parameters",
    mapper: PrivateEndpoint
};
const privateDnsZoneGroupName = {
    parameterPath: "privateDnsZoneGroupName",
    mapper: {
        serializedName: "privateDnsZoneGroupName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters49 = {
    parameterPath: "parameters",
    mapper: PrivateDnsZoneGroup
};
const serviceName = {
    parameterPath: "serviceName",
    mapper: {
        serializedName: "serviceName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters50 = {
    parameterPath: "parameters",
    mapper: PrivateLinkService
};
const peConnectionName = {
    parameterPath: "peConnectionName",
    mapper: {
        serializedName: "peConnectionName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters51 = {
    parameterPath: "parameters",
    mapper: PrivateEndpointConnection
};
const parameters52 = {
    parameterPath: "parameters",
    mapper: CheckPrivateLinkServiceVisibilityRequest
};
const publicIpPrefixName = {
    parameterPath: "publicIpPrefixName",
    mapper: {
        serializedName: "publicIpPrefixName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters53 = {
    parameterPath: "parameters",
    mapper: PublicIPPrefix
};
const routeFilterName = {
    parameterPath: "routeFilterName",
    mapper: {
        serializedName: "routeFilterName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const routeFilterParameters = {
    parameterPath: "routeFilterParameters",
    mapper: RouteFilter
};
const ruleName = {
    parameterPath: "ruleName",
    mapper: {
        serializedName: "ruleName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const routeFilterRuleParameters = {
    parameterPath: "routeFilterRuleParameters",
    mapper: RouteFilterRule
};
const routeTableName = {
    parameterPath: "routeTableName",
    mapper: {
        serializedName: "routeTableName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters54 = {
    parameterPath: "parameters",
    mapper: RouteTable
};
const routeName = {
    parameterPath: "routeName",
    mapper: {
        serializedName: "routeName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const routeParameters = {
    parameterPath: "routeParameters",
    mapper: Route
};
const securityPartnerProviderName = {
    parameterPath: "securityPartnerProviderName",
    mapper: {
        serializedName: "securityPartnerProviderName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters55 = {
    parameterPath: "parameters",
    mapper: SecurityPartnerProvider
};
const serviceEndpointPolicyName = {
    parameterPath: "serviceEndpointPolicyName",
    mapper: {
        serializedName: "serviceEndpointPolicyName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters56 = {
    parameterPath: "parameters",
    mapper: ServiceEndpointPolicy
};
const serviceEndpointPolicyDefinitionName = {
    parameterPath: "serviceEndpointPolicyDefinitionName",
    mapper: {
        serializedName: "serviceEndpointPolicyDefinitionName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const serviceEndpointPolicyDefinitions = {
    parameterPath: "serviceEndpointPolicyDefinitions",
    mapper: ServiceEndpointPolicyDefinition
};
const noAddressPrefixes = {
    parameterPath: ["options", "noAddressPrefixes"],
    mapper: {
        serializedName: "noAddressPrefixes",
        type: {
            name: "Boolean"
        }
    }
};
const tagName = {
    parameterPath: ["options", "tagName"],
    mapper: {
        serializedName: "tagName",
        type: {
            name: "String"
        }
    }
};
const location1 = {
    parameterPath: "location",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[-\\w\\._ ]+$")
        },
        serializedName: "location",
        required: true,
        type: {
            name: "String"
        }
    }
};
const virtualNetworkName = {
    parameterPath: "virtualNetworkName",
    mapper: {
        serializedName: "virtualNetworkName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters57 = {
    parameterPath: "parameters",
    mapper: VirtualNetwork
};
const ipAddress = {
    parameterPath: "ipAddress",
    mapper: {
        serializedName: "ipAddress",
        required: true,
        type: {
            name: "String"
        }
    }
};
const subnetName = {
    parameterPath: "subnetName",
    mapper: {
        serializedName: "subnetName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const subnetParameters = {
    parameterPath: "subnetParameters",
    mapper: Subnet
};
const prepareNetworkPoliciesRequestParameters = {
    parameterPath: "prepareNetworkPoliciesRequestParameters",
    mapper: PrepareNetworkPoliciesRequest
};
const unprepareNetworkPoliciesRequestParameters = {
    parameterPath: "unprepareNetworkPoliciesRequestParameters",
    mapper: UnprepareNetworkPoliciesRequest
};
const virtualNetworkPeeringName = {
    parameterPath: "virtualNetworkPeeringName",
    mapper: {
        serializedName: "virtualNetworkPeeringName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const virtualNetworkPeeringParameters = {
    parameterPath: "virtualNetworkPeeringParameters",
    mapper: VirtualNetworkPeering
};
const syncRemoteAddressSpace = {
    parameterPath: ["options", "syncRemoteAddressSpace"],
    mapper: {
        serializedName: "syncRemoteAddressSpace",
        type: {
            name: "String"
        }
    }
};
const parameters58 = {
    parameterPath: "parameters",
    mapper: VirtualNetworkGateway
};
const virtualNetworkGatewayName = {
    parameterPath: "virtualNetworkGatewayName",
    mapper: {
        serializedName: "virtualNetworkGatewayName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const gatewayVip = {
    parameterPath: ["options", "gatewayVip"],
    mapper: {
        serializedName: "gatewayVip",
        type: {
            name: "String"
        }
    }
};
const parameters59 = {
    parameterPath: "parameters",
    mapper: VpnClientParameters
};
const peer = {
    parameterPath: ["options", "peer"],
    mapper: {
        serializedName: "peer",
        type: {
            name: "String"
        }
    }
};
const peer1 = {
    parameterPath: "peer",
    mapper: {
        serializedName: "peer",
        required: true,
        type: {
            name: "String"
        }
    }
};
const vpnclientIpsecParams = {
    parameterPath: "vpnclientIpsecParams",
    mapper: VpnClientIPsecParameters
};
const parameters60 = {
    parameterPath: "parameters",
    mapper: VpnDeviceScriptParameters
};
const virtualNetworkGatewayConnectionName = {
    parameterPath: "virtualNetworkGatewayConnectionName",
    mapper: {
        serializedName: "virtualNetworkGatewayConnectionName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters61 = {
    parameterPath: ["options", "parameters"],
    mapper: VpnPacketCaptureStartParameters
};
const parameters62 = {
    parameterPath: "parameters",
    mapper: VpnPacketCaptureStopParameters
};
const request1 = {
    parameterPath: "request",
    mapper: P2SVpnConnectionRequest
};
const parameters63 = {
    parameterPath: "parameters",
    mapper: VirtualNetworkGatewayConnection
};
const parameters64 = {
    parameterPath: "parameters",
    mapper: ConnectionSharedKey
};
const parameters65 = {
    parameterPath: "parameters",
    mapper: ConnectionResetSharedKey
};
const parameters66 = {
    parameterPath: "parameters",
    mapper: LocalNetworkGateway
};
const localNetworkGatewayName = {
    parameterPath: "localNetworkGatewayName",
    mapper: {
        constraints: {
            MinLength: 1
        },
        serializedName: "localNetworkGatewayName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const natRuleName = {
    parameterPath: "natRuleName",
    mapper: {
        serializedName: "natRuleName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const natRuleParameters = {
    parameterPath: "natRuleParameters",
    mapper: VirtualNetworkGatewayNatRule
};
const tapName = {
    parameterPath: "tapName",
    mapper: {
        serializedName: "tapName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters67 = {
    parameterPath: "parameters",
    mapper: VirtualNetworkTap
};
const tapParameters = {
    parameterPath: "tapParameters",
    mapper: TagsObject
};
const virtualRouterName = {
    parameterPath: "virtualRouterName",
    mapper: {
        serializedName: "virtualRouterName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters68 = {
    parameterPath: "parameters",
    mapper: VirtualRouter
};
const parameters69 = {
    parameterPath: "parameters",
    mapper: VirtualRouterPeering
};
const virtualWANName1 = {
    parameterPath: "virtualWANName",
    mapper: {
        serializedName: "VirtualWANName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const wANParameters = {
    parameterPath: "wANParameters",
    mapper: VirtualWAN
};
const wANParameters1 = {
    parameterPath: "wANParameters",
    mapper: TagsObject
};
const vpnSiteName = {
    parameterPath: "vpnSiteName",
    mapper: {
        serializedName: "vpnSiteName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const vpnSiteParameters = {
    parameterPath: "vpnSiteParameters",
    mapper: VpnSite
};
const vpnSiteParameters1 = {
    parameterPath: "vpnSiteParameters",
    mapper: TagsObject
};
const vpnSiteLinkName = {
    parameterPath: "vpnSiteLinkName",
    mapper: {
        serializedName: "vpnSiteLinkName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const request2 = {
    parameterPath: "request",
    mapper: GetVpnSitesConfigurationRequest
};
const vpnServerConfigurationName = {
    parameterPath: "vpnServerConfigurationName",
    mapper: {
        serializedName: "vpnServerConfigurationName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const vpnServerConfigurationParameters = {
    parameterPath: "vpnServerConfigurationParameters",
    mapper: VpnServerConfiguration
};
const vpnServerConfigurationParameters1 = {
    parameterPath: "vpnServerConfigurationParameters",
    mapper: TagsObject
};
const virtualHubName = {
    parameterPath: "virtualHubName",
    mapper: {
        serializedName: "virtualHubName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const virtualHubParameters = {
    parameterPath: "virtualHubParameters",
    mapper: VirtualHub
};
const virtualHubParameters1 = {
    parameterPath: "virtualHubParameters",
    mapper: TagsObject
};
const effectiveRoutesParameters = {
    parameterPath: ["options", "effectiveRoutesParameters"],
    mapper: EffectiveRoutesParameters
};
const hubVirtualNetworkConnectionParameters = {
    parameterPath: "hubVirtualNetworkConnectionParameters",
    mapper: HubVirtualNetworkConnection
};
const gatewayName = {
    parameterPath: "gatewayName",
    mapper: {
        serializedName: "gatewayName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const vpnGatewayParameters = {
    parameterPath: "vpnGatewayParameters",
    mapper: VpnGateway
};
const vpnGatewayParameters1 = {
    parameterPath: "vpnGatewayParameters",
    mapper: TagsObject
};
const parameters70 = {
    parameterPath: ["options", "parameters"],
    mapper: VpnGatewayPacketCaptureStartParameters
};
const parameters71 = {
    parameterPath: ["options", "parameters"],
    mapper: VpnGatewayPacketCaptureStopParameters
};
const linkConnectionName = {
    parameterPath: "linkConnectionName",
    mapper: {
        serializedName: "linkConnectionName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const vpnConnectionParameters = {
    parameterPath: "vpnConnectionParameters",
    mapper: VpnConnection
};
const parameters72 = {
    parameterPath: ["options", "parameters"],
    mapper: VpnConnectionPacketCaptureStartParameters
};
const vpnConnectionName = {
    parameterPath: "vpnConnectionName",
    mapper: {
        serializedName: "vpnConnectionName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters73 = {
    parameterPath: ["options", "parameters"],
    mapper: VpnConnectionPacketCaptureStopParameters
};
const natRuleParameters1 = {
    parameterPath: "natRuleParameters",
    mapper: VpnGatewayNatRule
};
const p2SVpnGatewayParameters = {
    parameterPath: "p2SVpnGatewayParameters",
    mapper: P2SVpnGateway
};
const p2SVpnGatewayParameters1 = {
    parameterPath: "p2SVpnGatewayParameters",
    mapper: TagsObject
};
const parameters74 = {
    parameterPath: "parameters",
    mapper: P2SVpnProfileParameters
};
const request3 = {
    parameterPath: "request",
    mapper: P2SVpnConnectionHealthRequest
};
const p2SVpnGatewayName = {
    parameterPath: "p2SVpnGatewayName",
    mapper: {
        serializedName: "p2sVpnGatewayName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const virtualHubRouteTableV2Parameters = {
    parameterPath: "virtualHubRouteTableV2Parameters",
    mapper: VirtualHubRouteTableV2
};
const putExpressRouteGatewayParameters = {
    parameterPath: "putExpressRouteGatewayParameters",
    mapper: ExpressRouteGateway
};
const expressRouteGatewayName = {
    parameterPath: "expressRouteGatewayName",
    mapper: {
        serializedName: "expressRouteGatewayName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const expressRouteGatewayParameters = {
    parameterPath: "expressRouteGatewayParameters",
    mapper: TagsObject
};
const putExpressRouteConnectionParameters = {
    parameterPath: "putExpressRouteConnectionParameters",
    mapper: ExpressRouteConnection
};
const parameters75 = {
    parameterPath: "parameters",
    mapper: BgpConnection
};
const hubName = {
    parameterPath: "hubName",
    mapper: {
        serializedName: "hubName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const ipConfigName = {
    parameterPath: "ipConfigName",
    mapper: {
        serializedName: "ipConfigName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters76 = {
    parameterPath: "parameters",
    mapper: HubIpConfiguration
};
const routeTableParameters = {
    parameterPath: "routeTableParameters",
    mapper: HubRouteTable
};
const routingIntentParameters = {
    parameterPath: "routingIntentParameters",
    mapper: RoutingIntent
};
const routingIntentName = {
    parameterPath: "routingIntentName",
    mapper: {
        serializedName: "routingIntentName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const policyName = {
    parameterPath: "policyName",
    mapper: {
        constraints: {
            MaxLength: 128
        },
        serializedName: "policyName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters77 = {
    parameterPath: "parameters",
    mapper: WebApplicationFirewallPolicy
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ApplicationGateways operations. */
class ApplicationGatewaysImpl {
    /**
     * Initialize a new instance of the class ApplicationGateways class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all application gateways in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    list(resourceGroupName, options) {
        const iter = this.listPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, options);
            }
        };
    }
    listPagingPage(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets all the application gateways in a subscription.
     * @param options The options parameters.
     */
    listAll(options) {
        const iter = this.listAllPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listAllPagingPage(options);
            }
        };
    }
    listAllPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listAllPagingPage_1() {
            let result = yield tslib.__await(this._listAll(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listAllNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listAllPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listAllPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listAllPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Lists all SSL predefined policies for configuring Ssl policy.
     * @param options The options parameters.
     */
    listAvailableSslPredefinedPolicies(options) {
        const iter = this.listAvailableSslPredefinedPoliciesPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listAvailableSslPredefinedPoliciesPagingPage(options);
            }
        };
    }
    listAvailableSslPredefinedPoliciesPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listAvailableSslPredefinedPoliciesPagingPage_1() {
            let result = yield tslib.__await(this._listAvailableSslPredefinedPolicies(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listAvailableSslPredefinedPoliciesNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listAvailableSslPredefinedPoliciesPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listAvailableSslPredefinedPoliciesPagingAll_1() {
            var e_3, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listAvailableSslPredefinedPoliciesPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_3) throw e_3.error; }
            }
        });
    }
    /**
     * Deletes the specified application gateway.
     * @param resourceGroupName The name of the resource group.
     * @param applicationGatewayName The name of the application gateway.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, applicationGatewayName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, applicationGatewayName, options }, deleteOperationSpec);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Deletes the specified application gateway.
     * @param resourceGroupName The name of the resource group.
     * @param applicationGatewayName The name of the application gateway.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, applicationGatewayName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, applicationGatewayName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the specified application gateway.
     * @param resourceGroupName The name of the resource group.
     * @param applicationGatewayName The name of the application gateway.
     * @param options The options parameters.
     */
    get(resourceGroupName, applicationGatewayName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, applicationGatewayName, options }, getOperationSpec);
    }
    /**
     * Creates or updates the specified application gateway.
     * @param resourceGroupName The name of the resource group.
     * @param applicationGatewayName The name of the application gateway.
     * @param parameters Parameters supplied to the create or update application gateway operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, applicationGatewayName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, applicationGatewayName, parameters, options }, createOrUpdateOperationSpec);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
        });
    }
    /**
     * Creates or updates the specified application gateway.
     * @param resourceGroupName The name of the resource group.
     * @param applicationGatewayName The name of the application gateway.
     * @param parameters Parameters supplied to the create or update application gateway operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, applicationGatewayName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, applicationGatewayName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates the specified application gateway tags.
     * @param resourceGroupName The name of the resource group.
     * @param applicationGatewayName The name of the application gateway.
     * @param parameters Parameters supplied to update application gateway tags.
     * @param options The options parameters.
     */
    updateTags(resourceGroupName, applicationGatewayName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, applicationGatewayName, parameters, options }, updateTagsOperationSpec);
    }
    /**
     * Lists all application gateways in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    _list(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listOperationSpec);
    }
    /**
     * Gets all the application gateways in a subscription.
     * @param options The options parameters.
     */
    _listAll(options) {
        return this.client.sendOperationRequest({ options }, listAllOperationSpec);
    }
    /**
     * Starts the specified application gateway.
     * @param resourceGroupName The name of the resource group.
     * @param applicationGatewayName The name of the application gateway.
     * @param options The options parameters.
     */
    beginStart(resourceGroupName, applicationGatewayName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, applicationGatewayName, options }, startOperationSpec);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Starts the specified application gateway.
     * @param resourceGroupName The name of the resource group.
     * @param applicationGatewayName The name of the application gateway.
     * @param options The options parameters.
     */
    beginStartAndWait(resourceGroupName, applicationGatewayName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginStart(resourceGroupName, applicationGatewayName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Stops the specified application gateway in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param applicationGatewayName The name of the application gateway.
     * @param options The options parameters.
     */
    beginStop(resourceGroupName, applicationGatewayName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, applicationGatewayName, options }, stopOperationSpec);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Stops the specified application gateway in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param applicationGatewayName The name of the application gateway.
     * @param options The options parameters.
     */
    beginStopAndWait(resourceGroupName, applicationGatewayName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginStop(resourceGroupName, applicationGatewayName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the backend health of the specified application gateway in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param applicationGatewayName The name of the application gateway.
     * @param options The options parameters.
     */
    beginBackendHealth(resourceGroupName, applicationGatewayName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, applicationGatewayName, options }, backendHealthOperationSpec);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Gets the backend health of the specified application gateway in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param applicationGatewayName The name of the application gateway.
     * @param options The options parameters.
     */
    beginBackendHealthAndWait(resourceGroupName, applicationGatewayName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginBackendHealth(resourceGroupName, applicationGatewayName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the backend health for given combination of backend pool and http setting of the specified
     * application gateway in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param applicationGatewayName The name of the application gateway.
     * @param probeRequest Request body for on-demand test probe operation.
     * @param options The options parameters.
     */
    beginBackendHealthOnDemand(resourceGroupName, applicationGatewayName, probeRequest, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, applicationGatewayName, probeRequest, options }, backendHealthOnDemandOperationSpec);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Gets the backend health for given combination of backend pool and http setting of the specified
     * application gateway in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param applicationGatewayName The name of the application gateway.
     * @param probeRequest Request body for on-demand test probe operation.
     * @param options The options parameters.
     */
    beginBackendHealthOnDemandAndWait(resourceGroupName, applicationGatewayName, probeRequest, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginBackendHealthOnDemand(resourceGroupName, applicationGatewayName, probeRequest, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Lists all available server variables.
     * @param options The options parameters.
     */
    listAvailableServerVariables(options) {
        return this.client.sendOperationRequest({ options }, listAvailableServerVariablesOperationSpec);
    }
    /**
     * Lists all available request headers.
     * @param options The options parameters.
     */
    listAvailableRequestHeaders(options) {
        return this.client.sendOperationRequest({ options }, listAvailableRequestHeadersOperationSpec);
    }
    /**
     * Lists all available response headers.
     * @param options The options parameters.
     */
    listAvailableResponseHeaders(options) {
        return this.client.sendOperationRequest({ options }, listAvailableResponseHeadersOperationSpec);
    }
    /**
     * Lists all available web application firewall rule sets.
     * @param options The options parameters.
     */
    listAvailableWafRuleSets(options) {
        return this.client.sendOperationRequest({ options }, listAvailableWafRuleSetsOperationSpec);
    }
    /**
     * Lists available Ssl options for configuring Ssl policy.
     * @param options The options parameters.
     */
    listAvailableSslOptions(options) {
        return this.client.sendOperationRequest({ options }, listAvailableSslOptionsOperationSpec);
    }
    /**
     * Lists all SSL predefined policies for configuring Ssl policy.
     * @param options The options parameters.
     */
    _listAvailableSslPredefinedPolicies(options) {
        return this.client.sendOperationRequest({ options }, listAvailableSslPredefinedPoliciesOperationSpec);
    }
    /**
     * Gets Ssl predefined policy with the specified policy name.
     * @param predefinedPolicyName Name of Ssl predefined policy.
     * @param options The options parameters.
     */
    getSslPredefinedPolicy(predefinedPolicyName, options) {
        return this.client.sendOperationRequest({ predefinedPolicyName, options }, getSslPredefinedPolicyOperationSpec);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listNextOperationSpec);
    }
    /**
     * ListAllNext
     * @param nextLink The nextLink from the previous successful call to the ListAll method.
     * @param options The options parameters.
     */
    _listAllNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listAllNextOperationSpec);
    }
    /**
     * ListAvailableSslPredefinedPoliciesNext
     * @param nextLink The nextLink from the previous successful call to the
     *                 ListAvailableSslPredefinedPolicies method.
     * @param options The options parameters.
     */
    _listAvailableSslPredefinedPoliciesNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listAvailableSslPredefinedPoliciesNextOperationSpec);
    }
}
// Operation Specifications
const serializer = coreClient.createSerializer(Mappers, /* isXml */ false);
const deleteOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/applicationGateways/{applicationGatewayName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        applicationGatewayName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer
};
const getOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/applicationGateways/{applicationGatewayName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ApplicationGateway
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        applicationGatewayName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer
};
const createOrUpdateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/applicationGateways/{applicationGatewayName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ApplicationGateway
        },
        201: {
            bodyMapper: ApplicationGateway
        },
        202: {
            bodyMapper: ApplicationGateway
        },
        204: {
            bodyMapper: ApplicationGateway
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        applicationGatewayName,
        subscriptionId
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer
};
const updateTagsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/applicationGateways/{applicationGatewayName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: ApplicationGateway
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        applicationGatewayName,
        subscriptionId
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer
};
const listOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/applicationGateways",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ApplicationGatewayListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer
};
const listAllOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/applicationGateways",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ApplicationGatewayListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer
};
const startOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/applicationGateways/{applicationGatewayName}/start",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        applicationGatewayName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer
};
const stopOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/applicationGateways/{applicationGatewayName}/stop",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        applicationGatewayName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer
};
const backendHealthOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/applicationGateways/{applicationGatewayName}/backendhealth",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: ApplicationGatewayBackendHealth
        },
        201: {
            bodyMapper: ApplicationGatewayBackendHealth
        },
        202: {
            bodyMapper: ApplicationGatewayBackendHealth
        },
        204: {
            bodyMapper: ApplicationGatewayBackendHealth
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, expand],
    urlParameters: [
        $host,
        resourceGroupName,
        applicationGatewayName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer
};
const backendHealthOnDemandOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/applicationGateways/{applicationGatewayName}/getBackendHealthOnDemand",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: ApplicationGatewayBackendHealthOnDemand
        },
        201: {
            bodyMapper: ApplicationGatewayBackendHealthOnDemand
        },
        202: {
            bodyMapper: ApplicationGatewayBackendHealthOnDemand
        },
        204: {
            bodyMapper: ApplicationGatewayBackendHealthOnDemand
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: probeRequest,
    queryParameters: [apiVersion, expand],
    urlParameters: [
        $host,
        resourceGroupName,
        applicationGatewayName,
        subscriptionId
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer
};
const listAvailableServerVariablesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/applicationGatewayAvailableServerVariables",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: {
                type: { name: "Sequence", element: { type: { name: "String" } } }
            }
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer
};
const listAvailableRequestHeadersOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/applicationGatewayAvailableRequestHeaders",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: {
                type: { name: "Sequence", element: { type: { name: "String" } } }
            }
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer
};
const listAvailableResponseHeadersOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/applicationGatewayAvailableResponseHeaders",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: {
                type: { name: "Sequence", element: { type: { name: "String" } } }
            }
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer
};
const listAvailableWafRuleSetsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/applicationGatewayAvailableWafRuleSets",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ApplicationGatewayAvailableWafRuleSetsResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer
};
const listAvailableSslOptionsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/applicationGatewayAvailableSslOptions/default",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ApplicationGatewayAvailableSslOptions
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer
};
const listAvailableSslPredefinedPoliciesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/applicationGatewayAvailableSslOptions/default/predefinedPolicies",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ApplicationGatewayAvailableSslPredefinedPolicies
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer
};
const getSslPredefinedPolicyOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/applicationGatewayAvailableSslOptions/default/predefinedPolicies/{predefinedPolicyName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ApplicationGatewaySslPredefinedPolicy
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        predefinedPolicyName
    ],
    headerParameters: [accept],
    serializer
};
const listNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ApplicationGatewayListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer
};
const listAllNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ApplicationGatewayListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer
};
const listAvailableSslPredefinedPoliciesNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ApplicationGatewayAvailableSslPredefinedPolicies
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ApplicationGatewayPrivateLinkResources operations. */
class ApplicationGatewayPrivateLinkResourcesImpl {
    /**
     * Initialize a new instance of the class ApplicationGatewayPrivateLinkResources class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all private link resources on an application gateway.
     * @param resourceGroupName The name of the resource group.
     * @param applicationGatewayName The name of the application gateway.
     * @param options The options parameters.
     */
    list(resourceGroupName, applicationGatewayName, options) {
        const iter = this.listPagingAll(resourceGroupName, applicationGatewayName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, applicationGatewayName, options);
            }
        };
    }
    listPagingPage(resourceGroupName, applicationGatewayName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, applicationGatewayName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, applicationGatewayName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceGroupName, applicationGatewayName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, applicationGatewayName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all private link resources on an application gateway.
     * @param resourceGroupName The name of the resource group.
     * @param applicationGatewayName The name of the application gateway.
     * @param options The options parameters.
     */
    _list(resourceGroupName, applicationGatewayName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, applicationGatewayName, options }, listOperationSpec$1);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param applicationGatewayName The name of the application gateway.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, applicationGatewayName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, applicationGatewayName, nextLink, options }, listNextOperationSpec$1);
    }
}
// Operation Specifications
const serializer$1 = coreClient.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/applicationGateways/{applicationGatewayName}/privateLinkResources",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ApplicationGatewayPrivateLinkResourceListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        applicationGatewayName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const listNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ApplicationGatewayPrivateLinkResourceListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        applicationGatewayName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$1
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ApplicationGatewayPrivateEndpointConnections operations. */
class ApplicationGatewayPrivateEndpointConnectionsImpl {
    /**
     * Initialize a new instance of the class ApplicationGatewayPrivateEndpointConnections class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all private endpoint connections on an application gateway.
     * @param resourceGroupName The name of the resource group.
     * @param applicationGatewayName The name of the application gateway.
     * @param options The options parameters.
     */
    list(resourceGroupName, applicationGatewayName, options) {
        const iter = this.listPagingAll(resourceGroupName, applicationGatewayName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, applicationGatewayName, options);
            }
        };
    }
    listPagingPage(resourceGroupName, applicationGatewayName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, applicationGatewayName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, applicationGatewayName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceGroupName, applicationGatewayName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, applicationGatewayName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Deletes the specified private endpoint connection on application gateway.
     * @param resourceGroupName The name of the resource group.
     * @param applicationGatewayName The name of the application gateway.
     * @param connectionName The name of the application gateway private endpoint connection.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, applicationGatewayName, connectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, applicationGatewayName, connectionName, options }, deleteOperationSpec$1);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Deletes the specified private endpoint connection on application gateway.
     * @param resourceGroupName The name of the resource group.
     * @param applicationGatewayName The name of the application gateway.
     * @param connectionName The name of the application gateway private endpoint connection.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, applicationGatewayName, connectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, applicationGatewayName, connectionName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates the specified private endpoint connection on application gateway.
     * @param resourceGroupName The name of the resource group.
     * @param applicationGatewayName The name of the application gateway.
     * @param connectionName The name of the application gateway private endpoint connection.
     * @param parameters Parameters supplied to update application gateway private endpoint connection
     *                   operation.
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, applicationGatewayName, connectionName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                applicationGatewayName,
                connectionName,
                parameters,
                options
            }, updateOperationSpec);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
        });
    }
    /**
     * Updates the specified private endpoint connection on application gateway.
     * @param resourceGroupName The name of the resource group.
     * @param applicationGatewayName The name of the application gateway.
     * @param connectionName The name of the application gateway private endpoint connection.
     * @param parameters Parameters supplied to update application gateway private endpoint connection
     *                   operation.
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, applicationGatewayName, connectionName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, applicationGatewayName, connectionName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the specified private endpoint connection on application gateway.
     * @param resourceGroupName The name of the resource group.
     * @param applicationGatewayName The name of the application gateway.
     * @param connectionName The name of the application gateway private endpoint connection.
     * @param options The options parameters.
     */
    get(resourceGroupName, applicationGatewayName, connectionName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, applicationGatewayName, connectionName, options }, getOperationSpec$1);
    }
    /**
     * Lists all private endpoint connections on an application gateway.
     * @param resourceGroupName The name of the resource group.
     * @param applicationGatewayName The name of the application gateway.
     * @param options The options parameters.
     */
    _list(resourceGroupName, applicationGatewayName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, applicationGatewayName, options }, listOperationSpec$2);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param applicationGatewayName The name of the application gateway.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, applicationGatewayName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, applicationGatewayName, nextLink, options }, listNextOperationSpec$2);
    }
}
// Operation Specifications
const serializer$2 = coreClient.createSerializer(Mappers, /* isXml */ false);
const deleteOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/applicationGateways/{applicationGatewayName}/privateEndpointConnections/{connectionName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        applicationGatewayName,
        subscriptionId,
        connectionName
    ],
    headerParameters: [accept],
    serializer: serializer$2
};
const updateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/applicationGateways/{applicationGatewayName}/privateEndpointConnections/{connectionName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ApplicationGatewayPrivateEndpointConnection
        },
        201: {
            bodyMapper: ApplicationGatewayPrivateEndpointConnection
        },
        202: {
            bodyMapper: ApplicationGatewayPrivateEndpointConnection
        },
        204: {
            bodyMapper: ApplicationGatewayPrivateEndpointConnection
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters2,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        applicationGatewayName,
        subscriptionId,
        connectionName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$2
};
const getOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/applicationGateways/{applicationGatewayName}/privateEndpointConnections/{connectionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ApplicationGatewayPrivateEndpointConnection
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        applicationGatewayName,
        subscriptionId,
        connectionName
    ],
    headerParameters: [accept],
    serializer: serializer$2
};
const listOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/applicationGateways/{applicationGatewayName}/privateEndpointConnections",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ApplicationGatewayPrivateEndpointConnectionListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        applicationGatewayName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$2
};
const listNextOperationSpec$2 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ApplicationGatewayPrivateEndpointConnectionListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        applicationGatewayName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$2
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ApplicationSecurityGroups operations. */
class ApplicationSecurityGroupsImpl {
    /**
     * Initialize a new instance of the class ApplicationSecurityGroups class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all application security groups in a subscription.
     * @param options The options parameters.
     */
    listAll(options) {
        const iter = this.listAllPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listAllPagingPage(options);
            }
        };
    }
    listAllPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listAllPagingPage_1() {
            let result = yield tslib.__await(this._listAll(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listAllNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listAllPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listAllPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listAllPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets all the application security groups in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    list(resourceGroupName, options) {
        const iter = this.listPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, options);
            }
        };
    }
    listPagingPage(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Deletes the specified application security group.
     * @param resourceGroupName The name of the resource group.
     * @param applicationSecurityGroupName The name of the application security group.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, applicationSecurityGroupName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, applicationSecurityGroupName, options }, deleteOperationSpec$2);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Deletes the specified application security group.
     * @param resourceGroupName The name of the resource group.
     * @param applicationSecurityGroupName The name of the application security group.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, applicationSecurityGroupName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, applicationSecurityGroupName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets information about the specified application security group.
     * @param resourceGroupName The name of the resource group.
     * @param applicationSecurityGroupName The name of the application security group.
     * @param options The options parameters.
     */
    get(resourceGroupName, applicationSecurityGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, applicationSecurityGroupName, options }, getOperationSpec$2);
    }
    /**
     * Creates or updates an application security group.
     * @param resourceGroupName The name of the resource group.
     * @param applicationSecurityGroupName The name of the application security group.
     * @param parameters Parameters supplied to the create or update ApplicationSecurityGroup operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, applicationSecurityGroupName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, applicationSecurityGroupName, parameters, options }, createOrUpdateOperationSpec$1);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
        });
    }
    /**
     * Creates or updates an application security group.
     * @param resourceGroupName The name of the resource group.
     * @param applicationSecurityGroupName The name of the application security group.
     * @param parameters Parameters supplied to the create or update ApplicationSecurityGroup operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, applicationSecurityGroupName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, applicationSecurityGroupName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates an application security group's tags.
     * @param resourceGroupName The name of the resource group.
     * @param applicationSecurityGroupName The name of the application security group.
     * @param parameters Parameters supplied to update application security group tags.
     * @param options The options parameters.
     */
    updateTags(resourceGroupName, applicationSecurityGroupName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, applicationSecurityGroupName, parameters, options }, updateTagsOperationSpec$1);
    }
    /**
     * Gets all application security groups in a subscription.
     * @param options The options parameters.
     */
    _listAll(options) {
        return this.client.sendOperationRequest({ options }, listAllOperationSpec$1);
    }
    /**
     * Gets all the application security groups in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    _list(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listOperationSpec$3);
    }
    /**
     * ListAllNext
     * @param nextLink The nextLink from the previous successful call to the ListAll method.
     * @param options The options parameters.
     */
    _listAllNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listAllNextOperationSpec$1);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listNextOperationSpec$3);
    }
}
// Operation Specifications
const serializer$3 = coreClient.createSerializer(Mappers, /* isXml */ false);
const deleteOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/applicationSecurityGroups/{applicationSecurityGroupName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        applicationSecurityGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$3
};
const getOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/applicationSecurityGroups/{applicationSecurityGroupName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ApplicationSecurityGroup
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        applicationSecurityGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$3
};
const createOrUpdateOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/applicationSecurityGroups/{applicationSecurityGroupName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ApplicationSecurityGroup
        },
        201: {
            bodyMapper: ApplicationSecurityGroup
        },
        202: {
            bodyMapper: ApplicationSecurityGroup
        },
        204: {
            bodyMapper: ApplicationSecurityGroup
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters3,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        applicationSecurityGroupName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$3
};
const updateTagsOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/applicationSecurityGroups/{applicationSecurityGroupName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: ApplicationSecurityGroup
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        applicationSecurityGroupName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$3
};
const listAllOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/applicationSecurityGroups",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ApplicationSecurityGroupListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$3
};
const listOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/applicationSecurityGroups",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ApplicationSecurityGroupListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$3
};
const listAllNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ApplicationSecurityGroupListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$3
};
const listNextOperationSpec$3 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ApplicationSecurityGroupListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$3
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing AvailableDelegations operations. */
class AvailableDelegationsImpl {
    /**
     * Initialize a new instance of the class AvailableDelegations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all of the available subnet delegations for this subscription in this region.
     * @param location The location of the subnet.
     * @param options The options parameters.
     */
    list(location, options) {
        const iter = this.listPagingAll(location, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(location, options);
            }
        };
    }
    listPagingPage(location, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(location, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(location, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(location, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(location, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets all of the available subnet delegations for this subscription in this region.
     * @param location The location of the subnet.
     * @param options The options parameters.
     */
    _list(location, options) {
        return this.client.sendOperationRequest({ location, options }, listOperationSpec$4);
    }
    /**
     * ListNext
     * @param location The location of the subnet.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(location, nextLink, options) {
        return this.client.sendOperationRequest({ location, nextLink, options }, listNextOperationSpec$4);
    }
}
// Operation Specifications
const serializer$4 = coreClient.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/locations/{location}/availableDelegations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AvailableDelegationsResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        location
    ],
    headerParameters: [accept],
    serializer: serializer$4
};
const listNextOperationSpec$4 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AvailableDelegationsResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
        location
    ],
    headerParameters: [accept],
    serializer: serializer$4
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing AvailableResourceGroupDelegations operations. */
class AvailableResourceGroupDelegationsImpl {
    /**
     * Initialize a new instance of the class AvailableResourceGroupDelegations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all of the available subnet delegations for this resource group in this region.
     * @param location The location of the domain name.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    list(location, resourceGroupName, options) {
        const iter = this.listPagingAll(location, resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(location, resourceGroupName, options);
            }
        };
    }
    listPagingPage(location, resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(location, resourceGroupName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(location, resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(location, resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(location, resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets all of the available subnet delegations for this resource group in this region.
     * @param location The location of the domain name.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    _list(location, resourceGroupName, options) {
        return this.client.sendOperationRequest({ location, resourceGroupName, options }, listOperationSpec$5);
    }
    /**
     * ListNext
     * @param location The location of the domain name.
     * @param resourceGroupName The name of the resource group.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(location, resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ location, resourceGroupName, nextLink, options }, listNextOperationSpec$5);
    }
}
// Operation Specifications
const serializer$5 = coreClient.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/locations/{location}/availableDelegations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AvailableDelegationsResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        location
    ],
    headerParameters: [accept],
    serializer: serializer$5
};
const listNextOperationSpec$5 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AvailableDelegationsResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        location
    ],
    headerParameters: [accept],
    serializer: serializer$5
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing AvailableServiceAliases operations. */
class AvailableServiceAliasesImpl {
    /**
     * Initialize a new instance of the class AvailableServiceAliases class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all available service aliases for this subscription in this region.
     * @param location The location.
     * @param options The options parameters.
     */
    list(location, options) {
        const iter = this.listPagingAll(location, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(location, options);
            }
        };
    }
    listPagingPage(location, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(location, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(location, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(location, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(location, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets all available service aliases for this resource group in this region.
     * @param resourceGroupName The name of the resource group.
     * @param location The location.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, location, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, location, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByResourceGroupPagingPage(resourceGroupName, location, options);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, location, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, location, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, location, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, location, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, location, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Gets all available service aliases for this subscription in this region.
     * @param location The location.
     * @param options The options parameters.
     */
    _list(location, options) {
        return this.client.sendOperationRequest({ location, options }, listOperationSpec$6);
    }
    /**
     * Gets all available service aliases for this resource group in this region.
     * @param resourceGroupName The name of the resource group.
     * @param location The location.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, location, options) {
        return this.client.sendOperationRequest({ resourceGroupName, location, options }, listByResourceGroupOperationSpec);
    }
    /**
     * ListNext
     * @param location The location.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(location, nextLink, options) {
        return this.client.sendOperationRequest({ location, nextLink, options }, listNextOperationSpec$6);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The name of the resource group.
     * @param location The location.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, location, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, location, nextLink, options }, listByResourceGroupNextOperationSpec);
    }
}
// Operation Specifications
const serializer$6 = coreClient.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/locations/{location}/availableServiceAliases",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AvailableServiceAliasesResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        location
    ],
    headerParameters: [accept],
    serializer: serializer$6
};
const listByResourceGroupOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/locations/{location}/availableServiceAliases",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AvailableServiceAliasesResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        location
    ],
    headerParameters: [accept],
    serializer: serializer$6
};
const listNextOperationSpec$6 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AvailableServiceAliasesResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
        location
    ],
    headerParameters: [accept],
    serializer: serializer$6
};
const listByResourceGroupNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AvailableServiceAliasesResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        location
    ],
    headerParameters: [accept],
    serializer: serializer$6
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing AzureFirewalls operations. */
class AzureFirewallsImpl {
    /**
     * Initialize a new instance of the class AzureFirewalls class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all Azure Firewalls in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    list(resourceGroupName, options) {
        const iter = this.listPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, options);
            }
        };
    }
    listPagingPage(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets all the Azure Firewalls in a subscription.
     * @param options The options parameters.
     */
    listAll(options) {
        const iter = this.listAllPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listAllPagingPage(options);
            }
        };
    }
    listAllPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listAllPagingPage_1() {
            let result = yield tslib.__await(this._listAll(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listAllNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listAllPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listAllPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listAllPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Deletes the specified Azure Firewall.
     * @param resourceGroupName The name of the resource group.
     * @param azureFirewallName The name of the Azure Firewall.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, azureFirewallName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, azureFirewallName, options }, deleteOperationSpec$3);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Deletes the specified Azure Firewall.
     * @param resourceGroupName The name of the resource group.
     * @param azureFirewallName The name of the Azure Firewall.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, azureFirewallName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, azureFirewallName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the specified Azure Firewall.
     * @param resourceGroupName The name of the resource group.
     * @param azureFirewallName The name of the Azure Firewall.
     * @param options The options parameters.
     */
    get(resourceGroupName, azureFirewallName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, azureFirewallName, options }, getOperationSpec$3);
    }
    /**
     * Creates or updates the specified Azure Firewall.
     * @param resourceGroupName The name of the resource group.
     * @param azureFirewallName The name of the Azure Firewall.
     * @param parameters Parameters supplied to the create or update Azure Firewall operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, azureFirewallName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, azureFirewallName, parameters, options }, createOrUpdateOperationSpec$2);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
        });
    }
    /**
     * Creates or updates the specified Azure Firewall.
     * @param resourceGroupName The name of the resource group.
     * @param azureFirewallName The name of the Azure Firewall.
     * @param parameters Parameters supplied to the create or update Azure Firewall operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, azureFirewallName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, azureFirewallName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates tags of an Azure Firewall resource.
     * @param resourceGroupName The name of the resource group.
     * @param azureFirewallName The name of the Azure Firewall.
     * @param parameters Parameters supplied to update azure firewall tags.
     * @param options The options parameters.
     */
    beginUpdateTags(resourceGroupName, azureFirewallName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, azureFirewallName, parameters, options }, updateTagsOperationSpec$2);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
        });
    }
    /**
     * Updates tags of an Azure Firewall resource.
     * @param resourceGroupName The name of the resource group.
     * @param azureFirewallName The name of the Azure Firewall.
     * @param parameters Parameters supplied to update azure firewall tags.
     * @param options The options parameters.
     */
    beginUpdateTagsAndWait(resourceGroupName, azureFirewallName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdateTags(resourceGroupName, azureFirewallName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Lists all Azure Firewalls in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    _list(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listOperationSpec$7);
    }
    /**
     * Gets all the Azure Firewalls in a subscription.
     * @param options The options parameters.
     */
    _listAll(options) {
        return this.client.sendOperationRequest({ options }, listAllOperationSpec$2);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listNextOperationSpec$7);
    }
    /**
     * ListAllNext
     * @param nextLink The nextLink from the previous successful call to the ListAll method.
     * @param options The options parameters.
     */
    _listAllNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listAllNextOperationSpec$2);
    }
}
// Operation Specifications
const serializer$7 = coreClient.createSerializer(Mappers, /* isXml */ false);
const deleteOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/azureFirewalls/{azureFirewallName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        azureFirewallName
    ],
    headerParameters: [accept],
    serializer: serializer$7
};
const getOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/azureFirewalls/{azureFirewallName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AzureFirewall
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        azureFirewallName
    ],
    headerParameters: [accept],
    serializer: serializer$7
};
const createOrUpdateOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/azureFirewalls/{azureFirewallName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: AzureFirewall
        },
        201: {
            bodyMapper: AzureFirewall
        },
        202: {
            bodyMapper: AzureFirewall
        },
        204: {
            bodyMapper: AzureFirewall
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters4,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        azureFirewallName1
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$7
};
const updateTagsOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/azureFirewalls/{azureFirewallName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: AzureFirewall
        },
        201: {
            bodyMapper: AzureFirewall
        },
        202: {
            bodyMapper: AzureFirewall
        },
        204: {
            bodyMapper: AzureFirewall
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        azureFirewallName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$7
};
const listOperationSpec$7 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/azureFirewalls",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AzureFirewallListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$7
};
const listAllOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/azureFirewalls",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AzureFirewallListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$7
};
const listNextOperationSpec$7 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AzureFirewallListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$7
};
const listAllNextOperationSpec$2 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AzureFirewallListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$7
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing AzureFirewallFqdnTags operations. */
class AzureFirewallFqdnTagsImpl {
    /**
     * Initialize a new instance of the class AzureFirewallFqdnTags class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all the Azure Firewall FQDN Tags in a subscription.
     * @param options The options parameters.
     */
    listAll(options) {
        const iter = this.listAllPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listAllPagingPage(options);
            }
        };
    }
    listAllPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listAllPagingPage_1() {
            let result = yield tslib.__await(this._listAll(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listAllNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listAllPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listAllPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listAllPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets all the Azure Firewall FQDN Tags in a subscription.
     * @param options The options parameters.
     */
    _listAll(options) {
        return this.client.sendOperationRequest({ options }, listAllOperationSpec$3);
    }
    /**
     * ListAllNext
     * @param nextLink The nextLink from the previous successful call to the ListAll method.
     * @param options The options parameters.
     */
    _listAllNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listAllNextOperationSpec$3);
    }
}
// Operation Specifications
const serializer$8 = coreClient.createSerializer(Mappers, /* isXml */ false);
const listAllOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/azureFirewallFqdnTags",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AzureFirewallFqdnTagListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$8
};
const listAllNextOperationSpec$3 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AzureFirewallFqdnTagListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$8
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing WebCategories operations. */
class WebCategoriesImpl {
    /**
     * Initialize a new instance of the class WebCategories class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all the Azure Web Categories in a subscription.
     * @param options The options parameters.
     */
    listBySubscription(options) {
        const iter = this.listBySubscriptionPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listBySubscriptionPagingPage(options);
            }
        };
    }
    listBySubscriptionPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingPage_1() {
            let result = yield tslib.__await(this._listBySubscription(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listBySubscriptionNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listBySubscriptionPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listBySubscriptionPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets the specified Azure Web Category.
     * @param name The name of the azureWebCategory.
     * @param options The options parameters.
     */
    get(name, options) {
        return this.client.sendOperationRequest({ name, options }, getOperationSpec$4);
    }
    /**
     * Gets all the Azure Web Categories in a subscription.
     * @param options The options parameters.
     */
    _listBySubscription(options) {
        return this.client.sendOperationRequest({ options }, listBySubscriptionOperationSpec);
    }
    /**
     * ListBySubscriptionNext
     * @param nextLink The nextLink from the previous successful call to the ListBySubscription method.
     * @param options The options parameters.
     */
    _listBySubscriptionNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listBySubscriptionNextOperationSpec);
    }
}
// Operation Specifications
const serializer$9 = coreClient.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/azureWebCategories/{name}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AzureWebCategory
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, expand],
    urlParameters: [$host, subscriptionId, name],
    headerParameters: [accept],
    serializer: serializer$9
};
const listBySubscriptionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/azureWebCategories",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AzureWebCategoryListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$9
};
const listBySubscriptionNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AzureWebCategoryListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$9
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing BastionHosts operations. */
class BastionHostsImpl {
    /**
     * Initialize a new instance of the class BastionHosts class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all Bastion Hosts in a subscription.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(options);
            }
        };
    }
    listPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all Bastion Hosts in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByResourceGroupPagingPage(resourceGroupName, options);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Deletes the specified Bastion Host.
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostName The name of the Bastion Host.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, bastionHostName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, bastionHostName, options }, deleteOperationSpec$4);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Deletes the specified Bastion Host.
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostName The name of the Bastion Host.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, bastionHostName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, bastionHostName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the specified Bastion Host.
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostName The name of the Bastion Host.
     * @param options The options parameters.
     */
    get(resourceGroupName, bastionHostName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, bastionHostName, options }, getOperationSpec$5);
    }
    /**
     * Creates or updates the specified Bastion Host.
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostName The name of the Bastion Host.
     * @param parameters Parameters supplied to the create or update Bastion Host operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, bastionHostName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, bastionHostName, parameters, options }, createOrUpdateOperationSpec$3);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
        });
    }
    /**
     * Creates or updates the specified Bastion Host.
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostName The name of the Bastion Host.
     * @param parameters Parameters supplied to the create or update Bastion Host operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, bastionHostName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, bastionHostName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates Tags for BastionHost resource
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostName The name of the Bastion Host.
     * @param parameters Parameters supplied to update BastionHost tags.
     * @param options The options parameters.
     */
    beginUpdateTags(resourceGroupName, bastionHostName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, bastionHostName, parameters, options }, updateTagsOperationSpec$3);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
        });
    }
    /**
     * Updates Tags for BastionHost resource
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostName The name of the Bastion Host.
     * @param parameters Parameters supplied to update BastionHost tags.
     * @param options The options parameters.
     */
    beginUpdateTagsAndWait(resourceGroupName, bastionHostName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdateTags(resourceGroupName, bastionHostName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Lists all Bastion Hosts in a subscription.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$8);
    }
    /**
     * Lists all Bastion Hosts in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec$1);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$8);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The name of the resource group.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec$1);
    }
}
// Operation Specifications
const serializer$a = coreClient.createSerializer(Mappers, /* isXml */ false);
const deleteOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/bastionHosts/{bastionHostName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        bastionHostName
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const getOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/bastionHosts/{bastionHostName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: BastionHost
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        bastionHostName
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const createOrUpdateOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/bastionHosts/{bastionHostName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: BastionHost
        },
        201: {
            bodyMapper: BastionHost
        },
        202: {
            bodyMapper: BastionHost
        },
        204: {
            bodyMapper: BastionHost
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters5,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        bastionHostName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const updateTagsOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/bastionHosts/{bastionHostName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: BastionHost
        },
        201: {
            bodyMapper: BastionHost
        },
        202: {
            bodyMapper: BastionHost
        },
        204: {
            bodyMapper: BastionHost
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        bastionHostName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const listOperationSpec$8 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/bastionHosts",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: BastionHostListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$a
};
const listByResourceGroupOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/bastionHosts",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: BastionHostListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listNextOperationSpec$8 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: BastionHostListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listByResourceGroupNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: BastionHostListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$a
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing NetworkInterfaces operations. */
class NetworkInterfacesImpl {
    /**
     * Initialize a new instance of the class NetworkInterfaces class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets information about all network interfaces in a role instance in a cloud service.
     * @param resourceGroupName The name of the resource group.
     * @param cloudServiceName The name of the cloud service.
     * @param roleInstanceName The name of role instance.
     * @param options The options parameters.
     */
    listCloudServiceRoleInstanceNetworkInterfaces(resourceGroupName, cloudServiceName, roleInstanceName, options) {
        const iter = this.listCloudServiceRoleInstanceNetworkInterfacesPagingAll(resourceGroupName, cloudServiceName, roleInstanceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listCloudServiceRoleInstanceNetworkInterfacesPagingPage(resourceGroupName, cloudServiceName, roleInstanceName, options);
            }
        };
    }
    listCloudServiceRoleInstanceNetworkInterfacesPagingPage(resourceGroupName, cloudServiceName, roleInstanceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listCloudServiceRoleInstanceNetworkInterfacesPagingPage_1() {
            let result = yield tslib.__await(this._listCloudServiceRoleInstanceNetworkInterfaces(resourceGroupName, cloudServiceName, roleInstanceName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listCloudServiceRoleInstanceNetworkInterfacesNext(resourceGroupName, cloudServiceName, roleInstanceName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listCloudServiceRoleInstanceNetworkInterfacesPagingAll(resourceGroupName, cloudServiceName, roleInstanceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listCloudServiceRoleInstanceNetworkInterfacesPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listCloudServiceRoleInstanceNetworkInterfacesPagingPage(resourceGroupName, cloudServiceName, roleInstanceName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets all network interfaces in a cloud service.
     * @param resourceGroupName The name of the resource group.
     * @param cloudServiceName The name of the cloud service.
     * @param options The options parameters.
     */
    listCloudServiceNetworkInterfaces(resourceGroupName, cloudServiceName, options) {
        const iter = this.listCloudServiceNetworkInterfacesPagingAll(resourceGroupName, cloudServiceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listCloudServiceNetworkInterfacesPagingPage(resourceGroupName, cloudServiceName, options);
            }
        };
    }
    listCloudServiceNetworkInterfacesPagingPage(resourceGroupName, cloudServiceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listCloudServiceNetworkInterfacesPagingPage_1() {
            let result = yield tslib.__await(this._listCloudServiceNetworkInterfaces(resourceGroupName, cloudServiceName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listCloudServiceNetworkInterfacesNext(resourceGroupName, cloudServiceName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listCloudServiceNetworkInterfacesPagingAll(resourceGroupName, cloudServiceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listCloudServiceNetworkInterfacesPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listCloudServiceNetworkInterfacesPagingPage(resourceGroupName, cloudServiceName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Gets all network interfaces in a subscription.
     * @param options The options parameters.
     */
    listAll(options) {
        const iter = this.listAllPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listAllPagingPage(options);
            }
        };
    }
    listAllPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listAllPagingPage_1() {
            let result = yield tslib.__await(this._listAll(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listAllNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listAllPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listAllPagingAll_1() {
            var e_3, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listAllPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_3) throw e_3.error; }
            }
        });
    }
    /**
     * Gets all network interfaces in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    list(resourceGroupName, options) {
        const iter = this.listPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, options);
            }
        };
    }
    listPagingPage(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_4, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_4) throw e_4.error; }
            }
        });
    }
    /**
     * Gets information about all network interfaces in a virtual machine in a virtual machine scale set.
     * @param resourceGroupName The name of the resource group.
     * @param virtualMachineScaleSetName The name of the virtual machine scale set.
     * @param virtualmachineIndex The virtual machine index.
     * @param options The options parameters.
     */
    listVirtualMachineScaleSetVMNetworkInterfaces(resourceGroupName, virtualMachineScaleSetName, virtualmachineIndex, options) {
        const iter = this.listVirtualMachineScaleSetVMNetworkInterfacesPagingAll(resourceGroupName, virtualMachineScaleSetName, virtualmachineIndex, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listVirtualMachineScaleSetVMNetworkInterfacesPagingPage(resourceGroupName, virtualMachineScaleSetName, virtualmachineIndex, options);
            }
        };
    }
    listVirtualMachineScaleSetVMNetworkInterfacesPagingPage(resourceGroupName, virtualMachineScaleSetName, virtualmachineIndex, options) {
        return tslib.__asyncGenerator(this, arguments, function* listVirtualMachineScaleSetVMNetworkInterfacesPagingPage_1() {
            let result = yield tslib.__await(this._listVirtualMachineScaleSetVMNetworkInterfaces(resourceGroupName, virtualMachineScaleSetName, virtualmachineIndex, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listVirtualMachineScaleSetVMNetworkInterfacesNext(resourceGroupName, virtualMachineScaleSetName, virtualmachineIndex, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listVirtualMachineScaleSetVMNetworkInterfacesPagingAll(resourceGroupName, virtualMachineScaleSetName, virtualmachineIndex, options) {
        return tslib.__asyncGenerator(this, arguments, function* listVirtualMachineScaleSetVMNetworkInterfacesPagingAll_1() {
            var e_5, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listVirtualMachineScaleSetVMNetworkInterfacesPagingPage(resourceGroupName, virtualMachineScaleSetName, virtualmachineIndex, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_5_1) { e_5 = { error: e_5_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_5) throw e_5.error; }
            }
        });
    }
    /**
     * Gets all network interfaces in a virtual machine scale set.
     * @param resourceGroupName The name of the resource group.
     * @param virtualMachineScaleSetName The name of the virtual machine scale set.
     * @param options The options parameters.
     */
    listVirtualMachineScaleSetNetworkInterfaces(resourceGroupName, virtualMachineScaleSetName, options) {
        const iter = this.listVirtualMachineScaleSetNetworkInterfacesPagingAll(resourceGroupName, virtualMachineScaleSetName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listVirtualMachineScaleSetNetworkInterfacesPagingPage(resourceGroupName, virtualMachineScaleSetName, options);
            }
        };
    }
    listVirtualMachineScaleSetNetworkInterfacesPagingPage(resourceGroupName, virtualMachineScaleSetName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listVirtualMachineScaleSetNetworkInterfacesPagingPage_1() {
            let result = yield tslib.__await(this._listVirtualMachineScaleSetNetworkInterfaces(resourceGroupName, virtualMachineScaleSetName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listVirtualMachineScaleSetNetworkInterfacesNext(resourceGroupName, virtualMachineScaleSetName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listVirtualMachineScaleSetNetworkInterfacesPagingAll(resourceGroupName, virtualMachineScaleSetName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listVirtualMachineScaleSetNetworkInterfacesPagingAll_1() {
            var e_6, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listVirtualMachineScaleSetNetworkInterfacesPagingPage(resourceGroupName, virtualMachineScaleSetName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_6_1) { e_6 = { error: e_6_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_6) throw e_6.error; }
            }
        });
    }
    /**
     * Get the specified network interface ip configuration in a virtual machine scale set.
     * @param resourceGroupName The name of the resource group.
     * @param virtualMachineScaleSetName The name of the virtual machine scale set.
     * @param virtualmachineIndex The virtual machine index.
     * @param networkInterfaceName The name of the network interface.
     * @param options The options parameters.
     */
    listVirtualMachineScaleSetIpConfigurations(resourceGroupName, virtualMachineScaleSetName, virtualmachineIndex, networkInterfaceName, options) {
        const iter = this.listVirtualMachineScaleSetIpConfigurationsPagingAll(resourceGroupName, virtualMachineScaleSetName, virtualmachineIndex, networkInterfaceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listVirtualMachineScaleSetIpConfigurationsPagingPage(resourceGroupName, virtualMachineScaleSetName, virtualmachineIndex, networkInterfaceName, options);
            }
        };
    }
    listVirtualMachineScaleSetIpConfigurationsPagingPage(resourceGroupName, virtualMachineScaleSetName, virtualmachineIndex, networkInterfaceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listVirtualMachineScaleSetIpConfigurationsPagingPage_1() {
            let result = yield tslib.__await(this._listVirtualMachineScaleSetIpConfigurations(resourceGroupName, virtualMachineScaleSetName, virtualmachineIndex, networkInterfaceName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listVirtualMachineScaleSetIpConfigurationsNext(resourceGroupName, virtualMachineScaleSetName, virtualmachineIndex, networkInterfaceName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listVirtualMachineScaleSetIpConfigurationsPagingAll(resourceGroupName, virtualMachineScaleSetName, virtualmachineIndex, networkInterfaceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listVirtualMachineScaleSetIpConfigurationsPagingAll_1() {
            var e_7, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listVirtualMachineScaleSetIpConfigurationsPagingPage(resourceGroupName, virtualMachineScaleSetName, virtualmachineIndex, networkInterfaceName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_7_1) { e_7 = { error: e_7_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_7) throw e_7.error; }
            }
        });
    }
    /**
     * Gets information about all network interfaces in a role instance in a cloud service.
     * @param resourceGroupName The name of the resource group.
     * @param cloudServiceName The name of the cloud service.
     * @param roleInstanceName The name of role instance.
     * @param options The options parameters.
     */
    _listCloudServiceRoleInstanceNetworkInterfaces(resourceGroupName, cloudServiceName, roleInstanceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, cloudServiceName, roleInstanceName, options }, listCloudServiceRoleInstanceNetworkInterfacesOperationSpec);
    }
    /**
     * Gets all network interfaces in a cloud service.
     * @param resourceGroupName The name of the resource group.
     * @param cloudServiceName The name of the cloud service.
     * @param options The options parameters.
     */
    _listCloudServiceNetworkInterfaces(resourceGroupName, cloudServiceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, cloudServiceName, options }, listCloudServiceNetworkInterfacesOperationSpec);
    }
    /**
     * Get the specified network interface in a cloud service.
     * @param resourceGroupName The name of the resource group.
     * @param cloudServiceName The name of the cloud service.
     * @param roleInstanceName The name of role instance.
     * @param networkInterfaceName The name of the network interface.
     * @param options The options parameters.
     */
    getCloudServiceNetworkInterface(resourceGroupName, cloudServiceName, roleInstanceName, networkInterfaceName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            cloudServiceName,
            roleInstanceName,
            networkInterfaceName,
            options
        }, getCloudServiceNetworkInterfaceOperationSpec);
    }
    /**
     * Deletes the specified network interface.
     * @param resourceGroupName The name of the resource group.
     * @param networkInterfaceName The name of the network interface.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, networkInterfaceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, networkInterfaceName, options }, deleteOperationSpec$5);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Deletes the specified network interface.
     * @param resourceGroupName The name of the resource group.
     * @param networkInterfaceName The name of the network interface.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, networkInterfaceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, networkInterfaceName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets information about the specified network interface.
     * @param resourceGroupName The name of the resource group.
     * @param networkInterfaceName The name of the network interface.
     * @param options The options parameters.
     */
    get(resourceGroupName, networkInterfaceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, networkInterfaceName, options }, getOperationSpec$6);
    }
    /**
     * Creates or updates a network interface.
     * @param resourceGroupName The name of the resource group.
     * @param networkInterfaceName The name of the network interface.
     * @param parameters Parameters supplied to the create or update network interface operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, networkInterfaceName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, networkInterfaceName, parameters, options }, createOrUpdateOperationSpec$4);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
        });
    }
    /**
     * Creates or updates a network interface.
     * @param resourceGroupName The name of the resource group.
     * @param networkInterfaceName The name of the network interface.
     * @param parameters Parameters supplied to the create or update network interface operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, networkInterfaceName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, networkInterfaceName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates a network interface tags.
     * @param resourceGroupName The name of the resource group.
     * @param networkInterfaceName The name of the network interface.
     * @param parameters Parameters supplied to update network interface tags.
     * @param options The options parameters.
     */
    updateTags(resourceGroupName, networkInterfaceName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, networkInterfaceName, parameters, options }, updateTagsOperationSpec$4);
    }
    /**
     * Gets all network interfaces in a subscription.
     * @param options The options parameters.
     */
    _listAll(options) {
        return this.client.sendOperationRequest({ options }, listAllOperationSpec$4);
    }
    /**
     * Gets all network interfaces in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    _list(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listOperationSpec$9);
    }
    /**
     * Gets all route tables applied to a network interface.
     * @param resourceGroupName The name of the resource group.
     * @param networkInterfaceName The name of the network interface.
     * @param options The options parameters.
     */
    beginGetEffectiveRouteTable(resourceGroupName, networkInterfaceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, networkInterfaceName, options }, getEffectiveRouteTableOperationSpec);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Gets all route tables applied to a network interface.
     * @param resourceGroupName The name of the resource group.
     * @param networkInterfaceName The name of the network interface.
     * @param options The options parameters.
     */
    beginGetEffectiveRouteTableAndWait(resourceGroupName, networkInterfaceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginGetEffectiveRouteTable(resourceGroupName, networkInterfaceName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets all network security groups applied to a network interface.
     * @param resourceGroupName The name of the resource group.
     * @param networkInterfaceName The name of the network interface.
     * @param options The options parameters.
     */
    beginListEffectiveNetworkSecurityGroups(resourceGroupName, networkInterfaceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, networkInterfaceName, options }, listEffectiveNetworkSecurityGroupsOperationSpec);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Gets all network security groups applied to a network interface.
     * @param resourceGroupName The name of the resource group.
     * @param networkInterfaceName The name of the network interface.
     * @param options The options parameters.
     */
    beginListEffectiveNetworkSecurityGroupsAndWait(resourceGroupName, networkInterfaceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginListEffectiveNetworkSecurityGroups(resourceGroupName, networkInterfaceName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets information about all network interfaces in a virtual machine in a virtual machine scale set.
     * @param resourceGroupName The name of the resource group.
     * @param virtualMachineScaleSetName The name of the virtual machine scale set.
     * @param virtualmachineIndex The virtual machine index.
     * @param options The options parameters.
     */
    _listVirtualMachineScaleSetVMNetworkInterfaces(resourceGroupName, virtualMachineScaleSetName, virtualmachineIndex, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            virtualMachineScaleSetName,
            virtualmachineIndex,
            options
        }, listVirtualMachineScaleSetVMNetworkInterfacesOperationSpec);
    }
    /**
     * Gets all network interfaces in a virtual machine scale set.
     * @param resourceGroupName The name of the resource group.
     * @param virtualMachineScaleSetName The name of the virtual machine scale set.
     * @param options The options parameters.
     */
    _listVirtualMachineScaleSetNetworkInterfaces(resourceGroupName, virtualMachineScaleSetName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, virtualMachineScaleSetName, options }, listVirtualMachineScaleSetNetworkInterfacesOperationSpec);
    }
    /**
     * Get the specified network interface in a virtual machine scale set.
     * @param resourceGroupName The name of the resource group.
     * @param virtualMachineScaleSetName The name of the virtual machine scale set.
     * @param virtualmachineIndex The virtual machine index.
     * @param networkInterfaceName The name of the network interface.
     * @param options The options parameters.
     */
    getVirtualMachineScaleSetNetworkInterface(resourceGroupName, virtualMachineScaleSetName, virtualmachineIndex, networkInterfaceName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            virtualMachineScaleSetName,
            virtualmachineIndex,
            networkInterfaceName,
            options
        }, getVirtualMachineScaleSetNetworkInterfaceOperationSpec);
    }
    /**
     * Get the specified network interface ip configuration in a virtual machine scale set.
     * @param resourceGroupName The name of the resource group.
     * @param virtualMachineScaleSetName The name of the virtual machine scale set.
     * @param virtualmachineIndex The virtual machine index.
     * @param networkInterfaceName The name of the network interface.
     * @param options The options parameters.
     */
    _listVirtualMachineScaleSetIpConfigurations(resourceGroupName, virtualMachineScaleSetName, virtualmachineIndex, networkInterfaceName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            virtualMachineScaleSetName,
            virtualmachineIndex,
            networkInterfaceName,
            options
        }, listVirtualMachineScaleSetIpConfigurationsOperationSpec);
    }
    /**
     * Get the specified network interface ip configuration in a virtual machine scale set.
     * @param resourceGroupName The name of the resource group.
     * @param virtualMachineScaleSetName The name of the virtual machine scale set.
     * @param virtualmachineIndex The virtual machine index.
     * @param networkInterfaceName The name of the network interface.
     * @param ipConfigurationName The name of the ip configuration.
     * @param options The options parameters.
     */
    getVirtualMachineScaleSetIpConfiguration(resourceGroupName, virtualMachineScaleSetName, virtualmachineIndex, networkInterfaceName, ipConfigurationName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            virtualMachineScaleSetName,
            virtualmachineIndex,
            networkInterfaceName,
            ipConfigurationName,
            options
        }, getVirtualMachineScaleSetIpConfigurationOperationSpec);
    }
    /**
     * ListCloudServiceRoleInstanceNetworkInterfacesNext
     * @param resourceGroupName The name of the resource group.
     * @param cloudServiceName The name of the cloud service.
     * @param roleInstanceName The name of role instance.
     * @param nextLink The nextLink from the previous successful call to the
     *                 ListCloudServiceRoleInstanceNetworkInterfaces method.
     * @param options The options parameters.
     */
    _listCloudServiceRoleInstanceNetworkInterfacesNext(resourceGroupName, cloudServiceName, roleInstanceName, nextLink, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            cloudServiceName,
            roleInstanceName,
            nextLink,
            options
        }, listCloudServiceRoleInstanceNetworkInterfacesNextOperationSpec);
    }
    /**
     * ListCloudServiceNetworkInterfacesNext
     * @param resourceGroupName The name of the resource group.
     * @param cloudServiceName The name of the cloud service.
     * @param nextLink The nextLink from the previous successful call to the
     *                 ListCloudServiceNetworkInterfaces method.
     * @param options The options parameters.
     */
    _listCloudServiceNetworkInterfacesNext(resourceGroupName, cloudServiceName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, cloudServiceName, nextLink, options }, listCloudServiceNetworkInterfacesNextOperationSpec);
    }
    /**
     * ListAllNext
     * @param nextLink The nextLink from the previous successful call to the ListAll method.
     * @param options The options parameters.
     */
    _listAllNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listAllNextOperationSpec$4);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listNextOperationSpec$9);
    }
    /**
     * ListVirtualMachineScaleSetVMNetworkInterfacesNext
     * @param resourceGroupName The name of the resource group.
     * @param virtualMachineScaleSetName The name of the virtual machine scale set.
     * @param virtualmachineIndex The virtual machine index.
     * @param nextLink The nextLink from the previous successful call to the
     *                 ListVirtualMachineScaleSetVMNetworkInterfaces method.
     * @param options The options parameters.
     */
    _listVirtualMachineScaleSetVMNetworkInterfacesNext(resourceGroupName, virtualMachineScaleSetName, virtualmachineIndex, nextLink, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            virtualMachineScaleSetName,
            virtualmachineIndex,
            nextLink,
            options
        }, listVirtualMachineScaleSetVMNetworkInterfacesNextOperationSpec);
    }
    /**
     * ListVirtualMachineScaleSetNetworkInterfacesNext
     * @param resourceGroupName The name of the resource group.
     * @param virtualMachineScaleSetName The name of the virtual machine scale set.
     * @param nextLink The nextLink from the previous successful call to the
     *                 ListVirtualMachineScaleSetNetworkInterfaces method.
     * @param options The options parameters.
     */
    _listVirtualMachineScaleSetNetworkInterfacesNext(resourceGroupName, virtualMachineScaleSetName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, virtualMachineScaleSetName, nextLink, options }, listVirtualMachineScaleSetNetworkInterfacesNextOperationSpec);
    }
    /**
     * ListVirtualMachineScaleSetIpConfigurationsNext
     * @param resourceGroupName The name of the resource group.
     * @param virtualMachineScaleSetName The name of the virtual machine scale set.
     * @param virtualmachineIndex The virtual machine index.
     * @param networkInterfaceName The name of the network interface.
     * @param nextLink The nextLink from the previous successful call to the
     *                 ListVirtualMachineScaleSetIpConfigurations method.
     * @param options The options parameters.
     */
    _listVirtualMachineScaleSetIpConfigurationsNext(resourceGroupName, virtualMachineScaleSetName, virtualmachineIndex, networkInterfaceName, nextLink, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            virtualMachineScaleSetName,
            virtualmachineIndex,
            networkInterfaceName,
            nextLink,
            options
        }, listVirtualMachineScaleSetIpConfigurationsNextOperationSpec);
    }
}
// Operation Specifications
const serializer$b = coreClient.createSerializer(Mappers, /* isXml */ false);
const listCloudServiceRoleInstanceNetworkInterfacesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/cloudServices/{cloudServiceName}/roleInstances/{roleInstanceName}/networkInterfaces",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkInterfaceListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        cloudServiceName,
        roleInstanceName
    ],
    headerParameters: [accept],
    serializer: serializer$b
};
const listCloudServiceNetworkInterfacesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/cloudServices/{cloudServiceName}/networkInterfaces",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkInterfaceListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        cloudServiceName
    ],
    headerParameters: [accept],
    serializer: serializer$b
};
const getCloudServiceNetworkInterfaceOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/cloudServices/{cloudServiceName}/roleInstances/{roleInstanceName}/networkInterfaces/{networkInterfaceName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkInterface
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, expand],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        cloudServiceName,
        roleInstanceName,
        networkInterfaceName
    ],
    headerParameters: [accept],
    serializer: serializer$b
};
const deleteOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkInterfaces/{networkInterfaceName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkInterfaceName
    ],
    headerParameters: [accept],
    serializer: serializer$b
};
const getOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkInterfaces/{networkInterfaceName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkInterface
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, expand],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkInterfaceName
    ],
    headerParameters: [accept],
    serializer: serializer$b
};
const createOrUpdateOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkInterfaces/{networkInterfaceName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: NetworkInterface
        },
        201: {
            bodyMapper: NetworkInterface
        },
        202: {
            bodyMapper: NetworkInterface
        },
        204: {
            bodyMapper: NetworkInterface
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters6,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkInterfaceName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$b
};
const updateTagsOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkInterfaces/{networkInterfaceName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: NetworkInterface
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkInterfaceName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$b
};
const listAllOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/networkInterfaces",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkInterfaceListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$b
};
const listOperationSpec$9 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkInterfaces",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkInterfaceListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$b
};
const getEffectiveRouteTableOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkInterfaces/{networkInterfaceName}/effectiveRouteTable",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: EffectiveRouteListResult
        },
        201: {
            bodyMapper: EffectiveRouteListResult
        },
        202: {
            bodyMapper: EffectiveRouteListResult
        },
        204: {
            bodyMapper: EffectiveRouteListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkInterfaceName
    ],
    headerParameters: [accept],
    serializer: serializer$b
};
const listEffectiveNetworkSecurityGroupsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkInterfaces/{networkInterfaceName}/effectiveNetworkSecurityGroups",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: EffectiveNetworkSecurityGroupListResult
        },
        201: {
            bodyMapper: EffectiveNetworkSecurityGroupListResult
        },
        202: {
            bodyMapper: EffectiveNetworkSecurityGroupListResult
        },
        204: {
            bodyMapper: EffectiveNetworkSecurityGroupListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkInterfaceName
    ],
    headerParameters: [accept],
    serializer: serializer$b
};
const listVirtualMachineScaleSetVMNetworkInterfacesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/microsoft.Compute/virtualMachineScaleSets/{virtualMachineScaleSetName}/virtualMachines/{virtualmachineIndex}/networkInterfaces",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkInterfaceListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualMachineScaleSetName,
        virtualmachineIndex
    ],
    headerParameters: [accept],
    serializer: serializer$b
};
const listVirtualMachineScaleSetNetworkInterfacesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/microsoft.Compute/virtualMachineScaleSets/{virtualMachineScaleSetName}/networkInterfaces",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkInterfaceListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualMachineScaleSetName
    ],
    headerParameters: [accept],
    serializer: serializer$b
};
const getVirtualMachineScaleSetNetworkInterfaceOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/microsoft.Compute/virtualMachineScaleSets/{virtualMachineScaleSetName}/virtualMachines/{virtualmachineIndex}/networkInterfaces/{networkInterfaceName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkInterface
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [expand, apiVersion1],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkInterfaceName,
        virtualMachineScaleSetName,
        virtualmachineIndex
    ],
    headerParameters: [accept],
    serializer: serializer$b
};
const listVirtualMachineScaleSetIpConfigurationsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/microsoft.Compute/virtualMachineScaleSets/{virtualMachineScaleSetName}/virtualMachines/{virtualmachineIndex}/networkInterfaces/{networkInterfaceName}/ipConfigurations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkInterfaceIPConfigurationListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [expand, apiVersion1],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkInterfaceName,
        virtualMachineScaleSetName,
        virtualmachineIndex
    ],
    headerParameters: [accept],
    serializer: serializer$b
};
const getVirtualMachineScaleSetIpConfigurationOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/microsoft.Compute/virtualMachineScaleSets/{virtualMachineScaleSetName}/virtualMachines/{virtualmachineIndex}/networkInterfaces/{networkInterfaceName}/ipConfigurations/{ipConfigurationName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkInterfaceIPConfiguration
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [expand, apiVersion1],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkInterfaceName,
        virtualMachineScaleSetName,
        virtualmachineIndex,
        ipConfigurationName
    ],
    headerParameters: [accept],
    serializer: serializer$b
};
const listCloudServiceRoleInstanceNetworkInterfacesNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkInterfaceListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        cloudServiceName,
        roleInstanceName
    ],
    headerParameters: [accept],
    serializer: serializer$b
};
const listCloudServiceNetworkInterfacesNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkInterfaceListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        cloudServiceName
    ],
    headerParameters: [accept],
    serializer: serializer$b
};
const listAllNextOperationSpec$4 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkInterfaceListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$b
};
const listNextOperationSpec$9 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkInterfaceListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$b
};
const listVirtualMachineScaleSetVMNetworkInterfacesNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkInterfaceListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        virtualMachineScaleSetName,
        virtualmachineIndex
    ],
    headerParameters: [accept],
    serializer: serializer$b
};
const listVirtualMachineScaleSetNetworkInterfacesNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkInterfaceListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        virtualMachineScaleSetName
    ],
    headerParameters: [accept],
    serializer: serializer$b
};
const listVirtualMachineScaleSetIpConfigurationsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkInterfaceIPConfigurationListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [expand, apiVersion1],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        networkInterfaceName,
        virtualMachineScaleSetName,
        virtualmachineIndex
    ],
    headerParameters: [accept],
    serializer: serializer$b
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing PublicIPAddresses operations. */
class PublicIPAddressesImpl {
    /**
     * Initialize a new instance of the class PublicIPAddresses class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets information about all public IP addresses on a cloud service level.
     * @param resourceGroupName The name of the resource group.
     * @param cloudServiceName The name of the cloud service.
     * @param options The options parameters.
     */
    listCloudServicePublicIPAddresses(resourceGroupName, cloudServiceName, options) {
        const iter = this.listCloudServicePublicIPAddressesPagingAll(resourceGroupName, cloudServiceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listCloudServicePublicIPAddressesPagingPage(resourceGroupName, cloudServiceName, options);
            }
        };
    }
    listCloudServicePublicIPAddressesPagingPage(resourceGroupName, cloudServiceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listCloudServicePublicIPAddressesPagingPage_1() {
            let result = yield tslib.__await(this._listCloudServicePublicIPAddresses(resourceGroupName, cloudServiceName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listCloudServicePublicIPAddressesNext(resourceGroupName, cloudServiceName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listCloudServicePublicIPAddressesPagingAll(resourceGroupName, cloudServiceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listCloudServicePublicIPAddressesPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listCloudServicePublicIPAddressesPagingPage(resourceGroupName, cloudServiceName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets information about all public IP addresses in a role instance IP configuration in a cloud
     * service.
     * @param resourceGroupName The name of the resource group.
     * @param cloudServiceName The name of the cloud service.
     * @param roleInstanceName The name of role instance.
     * @param networkInterfaceName The network interface name.
     * @param ipConfigurationName The IP configuration name.
     * @param options The options parameters.
     */
    listCloudServiceRoleInstancePublicIPAddresses(resourceGroupName, cloudServiceName, roleInstanceName, networkInterfaceName, ipConfigurationName, options) {
        const iter = this.listCloudServiceRoleInstancePublicIPAddressesPagingAll(resourceGroupName, cloudServiceName, roleInstanceName, networkInterfaceName, ipConfigurationName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listCloudServiceRoleInstancePublicIPAddressesPagingPage(resourceGroupName, cloudServiceName, roleInstanceName, networkInterfaceName, ipConfigurationName, options);
            }
        };
    }
    listCloudServiceRoleInstancePublicIPAddressesPagingPage(resourceGroupName, cloudServiceName, roleInstanceName, networkInterfaceName, ipConfigurationName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listCloudServiceRoleInstancePublicIPAddressesPagingPage_1() {
            let result = yield tslib.__await(this._listCloudServiceRoleInstancePublicIPAddresses(resourceGroupName, cloudServiceName, roleInstanceName, networkInterfaceName, ipConfigurationName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listCloudServiceRoleInstancePublicIPAddressesNext(resourceGroupName, cloudServiceName, roleInstanceName, networkInterfaceName, ipConfigurationName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listCloudServiceRoleInstancePublicIPAddressesPagingAll(resourceGroupName, cloudServiceName, roleInstanceName, networkInterfaceName, ipConfigurationName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listCloudServiceRoleInstancePublicIPAddressesPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listCloudServiceRoleInstancePublicIPAddressesPagingPage(resourceGroupName, cloudServiceName, roleInstanceName, networkInterfaceName, ipConfigurationName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Gets all the public IP addresses in a subscription.
     * @param options The options parameters.
     */
    listAll(options) {
        const iter = this.listAllPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listAllPagingPage(options);
            }
        };
    }
    listAllPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listAllPagingPage_1() {
            let result = yield tslib.__await(this._listAll(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listAllNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listAllPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listAllPagingAll_1() {
            var e_3, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listAllPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_3) throw e_3.error; }
            }
        });
    }
    /**
     * Gets all public IP addresses in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    list(resourceGroupName, options) {
        const iter = this.listPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, options);
            }
        };
    }
    listPagingPage(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_4, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_4) throw e_4.error; }
            }
        });
    }
    /**
     * Gets information about all public IP addresses on a virtual machine scale set level.
     * @param resourceGroupName The name of the resource group.
     * @param virtualMachineScaleSetName The name of the virtual machine scale set.
     * @param options The options parameters.
     */
    listVirtualMachineScaleSetPublicIPAddresses(resourceGroupName, virtualMachineScaleSetName, options) {
        const iter = this.listVirtualMachineScaleSetPublicIPAddressesPagingAll(resourceGroupName, virtualMachineScaleSetName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listVirtualMachineScaleSetPublicIPAddressesPagingPage(resourceGroupName, virtualMachineScaleSetName, options);
            }
        };
    }
    listVirtualMachineScaleSetPublicIPAddressesPagingPage(resourceGroupName, virtualMachineScaleSetName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listVirtualMachineScaleSetPublicIPAddressesPagingPage_1() {
            let result = yield tslib.__await(this._listVirtualMachineScaleSetPublicIPAddresses(resourceGroupName, virtualMachineScaleSetName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listVirtualMachineScaleSetPublicIPAddressesNext(resourceGroupName, virtualMachineScaleSetName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listVirtualMachineScaleSetPublicIPAddressesPagingAll(resourceGroupName, virtualMachineScaleSetName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listVirtualMachineScaleSetPublicIPAddressesPagingAll_1() {
            var e_5, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listVirtualMachineScaleSetPublicIPAddressesPagingPage(resourceGroupName, virtualMachineScaleSetName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_5_1) { e_5 = { error: e_5_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_5) throw e_5.error; }
            }
        });
    }
    /**
     * Gets information about all public IP addresses in a virtual machine IP configuration in a virtual
     * machine scale set.
     * @param resourceGroupName The name of the resource group.
     * @param virtualMachineScaleSetName The name of the virtual machine scale set.
     * @param virtualmachineIndex The virtual machine index.
     * @param networkInterfaceName The network interface name.
     * @param ipConfigurationName The IP configuration name.
     * @param options The options parameters.
     */
    listVirtualMachineScaleSetVMPublicIPAddresses(resourceGroupName, virtualMachineScaleSetName, virtualmachineIndex, networkInterfaceName, ipConfigurationName, options) {
        const iter = this.listVirtualMachineScaleSetVMPublicIPAddressesPagingAll(resourceGroupName, virtualMachineScaleSetName, virtualmachineIndex, networkInterfaceName, ipConfigurationName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listVirtualMachineScaleSetVMPublicIPAddressesPagingPage(resourceGroupName, virtualMachineScaleSetName, virtualmachineIndex, networkInterfaceName, ipConfigurationName, options);
            }
        };
    }
    listVirtualMachineScaleSetVMPublicIPAddressesPagingPage(resourceGroupName, virtualMachineScaleSetName, virtualmachineIndex, networkInterfaceName, ipConfigurationName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listVirtualMachineScaleSetVMPublicIPAddressesPagingPage_1() {
            let result = yield tslib.__await(this._listVirtualMachineScaleSetVMPublicIPAddresses(resourceGroupName, virtualMachineScaleSetName, virtualmachineIndex, networkInterfaceName, ipConfigurationName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listVirtualMachineScaleSetVMPublicIPAddressesNext(resourceGroupName, virtualMachineScaleSetName, virtualmachineIndex, networkInterfaceName, ipConfigurationName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listVirtualMachineScaleSetVMPublicIPAddressesPagingAll(resourceGroupName, virtualMachineScaleSetName, virtualmachineIndex, networkInterfaceName, ipConfigurationName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listVirtualMachineScaleSetVMPublicIPAddressesPagingAll_1() {
            var e_6, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listVirtualMachineScaleSetVMPublicIPAddressesPagingPage(resourceGroupName, virtualMachineScaleSetName, virtualmachineIndex, networkInterfaceName, ipConfigurationName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_6_1) { e_6 = { error: e_6_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_6) throw e_6.error; }
            }
        });
    }
    /**
     * Gets information about all public IP addresses on a cloud service level.
     * @param resourceGroupName The name of the resource group.
     * @param cloudServiceName The name of the cloud service.
     * @param options The options parameters.
     */
    _listCloudServicePublicIPAddresses(resourceGroupName, cloudServiceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, cloudServiceName, options }, listCloudServicePublicIPAddressesOperationSpec);
    }
    /**
     * Gets information about all public IP addresses in a role instance IP configuration in a cloud
     * service.
     * @param resourceGroupName The name of the resource group.
     * @param cloudServiceName The name of the cloud service.
     * @param roleInstanceName The name of role instance.
     * @param networkInterfaceName The network interface name.
     * @param ipConfigurationName The IP configuration name.
     * @param options The options parameters.
     */
    _listCloudServiceRoleInstancePublicIPAddresses(resourceGroupName, cloudServiceName, roleInstanceName, networkInterfaceName, ipConfigurationName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            cloudServiceName,
            roleInstanceName,
            networkInterfaceName,
            ipConfigurationName,
            options
        }, listCloudServiceRoleInstancePublicIPAddressesOperationSpec);
    }
    /**
     * Get the specified public IP address in a cloud service.
     * @param resourceGroupName The name of the resource group.
     * @param cloudServiceName The name of the cloud service.
     * @param roleInstanceName The role instance name.
     * @param networkInterfaceName The name of the network interface.
     * @param ipConfigurationName The name of the IP configuration.
     * @param publicIpAddressName The name of the public IP Address.
     * @param options The options parameters.
     */
    getCloudServicePublicIPAddress(resourceGroupName, cloudServiceName, roleInstanceName, networkInterfaceName, ipConfigurationName, publicIpAddressName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            cloudServiceName,
            roleInstanceName,
            networkInterfaceName,
            ipConfigurationName,
            publicIpAddressName,
            options
        }, getCloudServicePublicIPAddressOperationSpec);
    }
    /**
     * Deletes the specified public IP address.
     * @param resourceGroupName The name of the resource group.
     * @param publicIpAddressName The name of the public IP address.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, publicIpAddressName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, publicIpAddressName, options }, deleteOperationSpec$6);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Deletes the specified public IP address.
     * @param resourceGroupName The name of the resource group.
     * @param publicIpAddressName The name of the public IP address.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, publicIpAddressName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, publicIpAddressName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the specified public IP address in a specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param publicIpAddressName The name of the public IP address.
     * @param options The options parameters.
     */
    get(resourceGroupName, publicIpAddressName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, publicIpAddressName, options }, getOperationSpec$7);
    }
    /**
     * Creates or updates a static or dynamic public IP address.
     * @param resourceGroupName The name of the resource group.
     * @param publicIpAddressName The name of the public IP address.
     * @param parameters Parameters supplied to the create or update public IP address operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, publicIpAddressName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, publicIpAddressName, parameters, options }, createOrUpdateOperationSpec$5);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
        });
    }
    /**
     * Creates or updates a static or dynamic public IP address.
     * @param resourceGroupName The name of the resource group.
     * @param publicIpAddressName The name of the public IP address.
     * @param parameters Parameters supplied to the create or update public IP address operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, publicIpAddressName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, publicIpAddressName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates public IP address tags.
     * @param resourceGroupName The name of the resource group.
     * @param publicIpAddressName The name of the public IP address.
     * @param parameters Parameters supplied to update public IP address tags.
     * @param options The options parameters.
     */
    updateTags(resourceGroupName, publicIpAddressName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, publicIpAddressName, parameters, options }, updateTagsOperationSpec$5);
    }
    /**
     * Gets all the public IP addresses in a subscription.
     * @param options The options parameters.
     */
    _listAll(options) {
        return this.client.sendOperationRequest({ options }, listAllOperationSpec$5);
    }
    /**
     * Gets all public IP addresses in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    _list(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listOperationSpec$a);
    }
    /**
     * Gets information about all public IP addresses on a virtual machine scale set level.
     * @param resourceGroupName The name of the resource group.
     * @param virtualMachineScaleSetName The name of the virtual machine scale set.
     * @param options The options parameters.
     */
    _listVirtualMachineScaleSetPublicIPAddresses(resourceGroupName, virtualMachineScaleSetName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, virtualMachineScaleSetName, options }, listVirtualMachineScaleSetPublicIPAddressesOperationSpec);
    }
    /**
     * Gets information about all public IP addresses in a virtual machine IP configuration in a virtual
     * machine scale set.
     * @param resourceGroupName The name of the resource group.
     * @param virtualMachineScaleSetName The name of the virtual machine scale set.
     * @param virtualmachineIndex The virtual machine index.
     * @param networkInterfaceName The network interface name.
     * @param ipConfigurationName The IP configuration name.
     * @param options The options parameters.
     */
    _listVirtualMachineScaleSetVMPublicIPAddresses(resourceGroupName, virtualMachineScaleSetName, virtualmachineIndex, networkInterfaceName, ipConfigurationName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            virtualMachineScaleSetName,
            virtualmachineIndex,
            networkInterfaceName,
            ipConfigurationName,
            options
        }, listVirtualMachineScaleSetVMPublicIPAddressesOperationSpec);
    }
    /**
     * Get the specified public IP address in a virtual machine scale set.
     * @param resourceGroupName The name of the resource group.
     * @param virtualMachineScaleSetName The name of the virtual machine scale set.
     * @param virtualmachineIndex The virtual machine index.
     * @param networkInterfaceName The name of the network interface.
     * @param ipConfigurationName The name of the IP configuration.
     * @param publicIpAddressName The name of the public IP Address.
     * @param options The options parameters.
     */
    getVirtualMachineScaleSetPublicIPAddress(resourceGroupName, virtualMachineScaleSetName, virtualmachineIndex, networkInterfaceName, ipConfigurationName, publicIpAddressName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            virtualMachineScaleSetName,
            virtualmachineIndex,
            networkInterfaceName,
            ipConfigurationName,
            publicIpAddressName,
            options
        }, getVirtualMachineScaleSetPublicIPAddressOperationSpec);
    }
    /**
     * ListCloudServicePublicIPAddressesNext
     * @param resourceGroupName The name of the resource group.
     * @param cloudServiceName The name of the cloud service.
     * @param nextLink The nextLink from the previous successful call to the
     *                 ListCloudServicePublicIPAddresses method.
     * @param options The options parameters.
     */
    _listCloudServicePublicIPAddressesNext(resourceGroupName, cloudServiceName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, cloudServiceName, nextLink, options }, listCloudServicePublicIPAddressesNextOperationSpec);
    }
    /**
     * ListCloudServiceRoleInstancePublicIPAddressesNext
     * @param resourceGroupName The name of the resource group.
     * @param cloudServiceName The name of the cloud service.
     * @param roleInstanceName The name of role instance.
     * @param networkInterfaceName The network interface name.
     * @param ipConfigurationName The IP configuration name.
     * @param nextLink The nextLink from the previous successful call to the
     *                 ListCloudServiceRoleInstancePublicIPAddresses method.
     * @param options The options parameters.
     */
    _listCloudServiceRoleInstancePublicIPAddressesNext(resourceGroupName, cloudServiceName, roleInstanceName, networkInterfaceName, ipConfigurationName, nextLink, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            cloudServiceName,
            roleInstanceName,
            networkInterfaceName,
            ipConfigurationName,
            nextLink,
            options
        }, listCloudServiceRoleInstancePublicIPAddressesNextOperationSpec);
    }
    /**
     * ListAllNext
     * @param nextLink The nextLink from the previous successful call to the ListAll method.
     * @param options The options parameters.
     */
    _listAllNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listAllNextOperationSpec$5);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listNextOperationSpec$a);
    }
    /**
     * ListVirtualMachineScaleSetPublicIPAddressesNext
     * @param resourceGroupName The name of the resource group.
     * @param virtualMachineScaleSetName The name of the virtual machine scale set.
     * @param nextLink The nextLink from the previous successful call to the
     *                 ListVirtualMachineScaleSetPublicIPAddresses method.
     * @param options The options parameters.
     */
    _listVirtualMachineScaleSetPublicIPAddressesNext(resourceGroupName, virtualMachineScaleSetName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, virtualMachineScaleSetName, nextLink, options }, listVirtualMachineScaleSetPublicIPAddressesNextOperationSpec);
    }
    /**
     * ListVirtualMachineScaleSetVMPublicIPAddressesNext
     * @param resourceGroupName The name of the resource group.
     * @param virtualMachineScaleSetName The name of the virtual machine scale set.
     * @param virtualmachineIndex The virtual machine index.
     * @param networkInterfaceName The network interface name.
     * @param ipConfigurationName The IP configuration name.
     * @param nextLink The nextLink from the previous successful call to the
     *                 ListVirtualMachineScaleSetVMPublicIPAddresses method.
     * @param options The options parameters.
     */
    _listVirtualMachineScaleSetVMPublicIPAddressesNext(resourceGroupName, virtualMachineScaleSetName, virtualmachineIndex, networkInterfaceName, ipConfigurationName, nextLink, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            virtualMachineScaleSetName,
            virtualmachineIndex,
            networkInterfaceName,
            ipConfigurationName,
            nextLink,
            options
        }, listVirtualMachineScaleSetVMPublicIPAddressesNextOperationSpec);
    }
}
// Operation Specifications
const serializer$c = coreClient.createSerializer(Mappers, /* isXml */ false);
const listCloudServicePublicIPAddressesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/cloudServices/{cloudServiceName}/publicipaddresses",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PublicIPAddressListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        cloudServiceName
    ],
    headerParameters: [accept],
    serializer: serializer$c
};
const listCloudServiceRoleInstancePublicIPAddressesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/cloudServices/{cloudServiceName}/roleInstances/{roleInstanceName}/networkInterfaces/{networkInterfaceName}/ipconfigurations/{ipConfigurationName}/publicipaddresses",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PublicIPAddressListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        cloudServiceName,
        roleInstanceName,
        networkInterfaceName,
        ipConfigurationName
    ],
    headerParameters: [accept],
    serializer: serializer$c
};
const getCloudServicePublicIPAddressOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/cloudServices/{cloudServiceName}/roleInstances/{roleInstanceName}/networkInterfaces/{networkInterfaceName}/ipconfigurations/{ipConfigurationName}/publicipaddresses/{publicIpAddressName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PublicIPAddress
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, expand],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        cloudServiceName,
        roleInstanceName,
        networkInterfaceName,
        ipConfigurationName,
        publicIpAddressName
    ],
    headerParameters: [accept],
    serializer: serializer$c
};
const deleteOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/publicIPAddresses/{publicIpAddressName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        publicIpAddressName
    ],
    headerParameters: [accept],
    serializer: serializer$c
};
const getOperationSpec$7 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/publicIPAddresses/{publicIpAddressName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PublicIPAddress
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, expand],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        publicIpAddressName
    ],
    headerParameters: [accept],
    serializer: serializer$c
};
const createOrUpdateOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/publicIPAddresses/{publicIpAddressName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: PublicIPAddress
        },
        201: {
            bodyMapper: PublicIPAddress
        },
        202: {
            bodyMapper: PublicIPAddress
        },
        204: {
            bodyMapper: PublicIPAddress
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters7,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        publicIpAddressName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$c
};
const updateTagsOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/publicIPAddresses/{publicIpAddressName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: PublicIPAddress
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        publicIpAddressName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$c
};
const listAllOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/publicIPAddresses",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PublicIPAddressListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$c
};
const listOperationSpec$a = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/publicIPAddresses",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PublicIPAddressListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$c
};
const listVirtualMachineScaleSetPublicIPAddressesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{virtualMachineScaleSetName}/publicipaddresses",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PublicIPAddressListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualMachineScaleSetName
    ],
    headerParameters: [accept],
    serializer: serializer$c
};
const listVirtualMachineScaleSetVMPublicIPAddressesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{virtualMachineScaleSetName}/virtualMachines/{virtualmachineIndex}/networkInterfaces/{networkInterfaceName}/ipconfigurations/{ipConfigurationName}/publicipaddresses",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PublicIPAddressListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkInterfaceName,
        virtualMachineScaleSetName,
        virtualmachineIndex,
        ipConfigurationName
    ],
    headerParameters: [accept],
    serializer: serializer$c
};
const getVirtualMachineScaleSetPublicIPAddressOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{virtualMachineScaleSetName}/virtualMachines/{virtualmachineIndex}/networkInterfaces/{networkInterfaceName}/ipconfigurations/{ipConfigurationName}/publicipaddresses/{publicIpAddressName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PublicIPAddress
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [expand, apiVersion1],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkInterfaceName,
        virtualMachineScaleSetName,
        virtualmachineIndex,
        ipConfigurationName,
        publicIpAddressName
    ],
    headerParameters: [accept],
    serializer: serializer$c
};
const listCloudServicePublicIPAddressesNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PublicIPAddressListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        cloudServiceName
    ],
    headerParameters: [accept],
    serializer: serializer$c
};
const listCloudServiceRoleInstancePublicIPAddressesNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PublicIPAddressListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        cloudServiceName,
        roleInstanceName,
        networkInterfaceName,
        ipConfigurationName
    ],
    headerParameters: [accept],
    serializer: serializer$c
};
const listAllNextOperationSpec$5 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PublicIPAddressListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$c
};
const listNextOperationSpec$a = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PublicIPAddressListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$c
};
const listVirtualMachineScaleSetPublicIPAddressesNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PublicIPAddressListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        virtualMachineScaleSetName
    ],
    headerParameters: [accept],
    serializer: serializer$c
};
const listVirtualMachineScaleSetVMPublicIPAddressesNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PublicIPAddressListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        networkInterfaceName,
        virtualMachineScaleSetName,
        virtualmachineIndex,
        ipConfigurationName
    ],
    headerParameters: [accept],
    serializer: serializer$c
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing CustomIPPrefixes operations. */
class CustomIPPrefixesImpl {
    /**
     * Initialize a new instance of the class CustomIPPrefixes class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all the custom IP prefixes in a subscription.
     * @param options The options parameters.
     */
    listAll(options) {
        const iter = this.listAllPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listAllPagingPage(options);
            }
        };
    }
    listAllPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listAllPagingPage_1() {
            let result = yield tslib.__await(this._listAll(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listAllNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listAllPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listAllPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listAllPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets all custom IP prefixes in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    list(resourceGroupName, options) {
        const iter = this.listPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, options);
            }
        };
    }
    listPagingPage(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Deletes the specified custom IP prefix.
     * @param resourceGroupName The name of the resource group.
     * @param customIpPrefixName The name of the CustomIpPrefix.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, customIpPrefixName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, customIpPrefixName, options }, deleteOperationSpec$7);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Deletes the specified custom IP prefix.
     * @param resourceGroupName The name of the resource group.
     * @param customIpPrefixName The name of the CustomIpPrefix.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, customIpPrefixName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, customIpPrefixName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the specified custom IP prefix in a specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param customIpPrefixName The name of the custom IP prefix.
     * @param options The options parameters.
     */
    get(resourceGroupName, customIpPrefixName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, customIpPrefixName, options }, getOperationSpec$8);
    }
    /**
     * Creates or updates a custom IP prefix.
     * @param resourceGroupName The name of the resource group.
     * @param customIpPrefixName The name of the custom IP prefix.
     * @param parameters Parameters supplied to the create or update custom IP prefix operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, customIpPrefixName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, customIpPrefixName, parameters, options }, createOrUpdateOperationSpec$6);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Creates or updates a custom IP prefix.
     * @param resourceGroupName The name of the resource group.
     * @param customIpPrefixName The name of the custom IP prefix.
     * @param parameters Parameters supplied to the create or update custom IP prefix operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, customIpPrefixName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, customIpPrefixName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates custom IP prefix tags.
     * @param resourceGroupName The name of the resource group.
     * @param customIpPrefixName The name of the custom IP prefix.
     * @param parameters Parameters supplied to update custom IP prefix tags.
     * @param options The options parameters.
     */
    updateTags(resourceGroupName, customIpPrefixName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, customIpPrefixName, parameters, options }, updateTagsOperationSpec$6);
    }
    /**
     * Gets all the custom IP prefixes in a subscription.
     * @param options The options parameters.
     */
    _listAll(options) {
        return this.client.sendOperationRequest({ options }, listAllOperationSpec$6);
    }
    /**
     * Gets all custom IP prefixes in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    _list(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listOperationSpec$b);
    }
    /**
     * ListAllNext
     * @param nextLink The nextLink from the previous successful call to the ListAll method.
     * @param options The options parameters.
     */
    _listAllNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listAllNextOperationSpec$6);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listNextOperationSpec$b);
    }
}
// Operation Specifications
const serializer$d = coreClient.createSerializer(Mappers, /* isXml */ false);
const deleteOperationSpec$7 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/customIpPrefixes/{customIpPrefixName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        customIpPrefixName
    ],
    headerParameters: [accept],
    serializer: serializer$d
};
const getOperationSpec$8 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/customIpPrefixes/{customIpPrefixName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CustomIpPrefix
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, expand],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        customIpPrefixName
    ],
    headerParameters: [accept],
    serializer: serializer$d
};
const createOrUpdateOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/customIpPrefixes/{customIpPrefixName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: CustomIpPrefix
        },
        201: {
            bodyMapper: CustomIpPrefix
        },
        202: {
            bodyMapper: CustomIpPrefix
        },
        204: {
            bodyMapper: CustomIpPrefix
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters8,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        customIpPrefixName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$d
};
const updateTagsOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/customIpPrefixes/{customIpPrefixName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: CustomIpPrefix
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        customIpPrefixName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$d
};
const listAllOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/customIpPrefixes",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CustomIpPrefixListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$d
};
const listOperationSpec$b = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/customIpPrefixes",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CustomIpPrefixListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$d
};
const listAllNextOperationSpec$6 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CustomIpPrefixListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$d
};
const listNextOperationSpec$b = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CustomIpPrefixListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$d
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing DdosCustomPolicies operations. */
class DdosCustomPoliciesImpl {
    /**
     * Initialize a new instance of the class DdosCustomPolicies class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Deletes the specified DDoS custom policy.
     * @param resourceGroupName The name of the resource group.
     * @param ddosCustomPolicyName The name of the DDoS custom policy.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, ddosCustomPolicyName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, ddosCustomPolicyName, options }, deleteOperationSpec$8);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Deletes the specified DDoS custom policy.
     * @param resourceGroupName The name of the resource group.
     * @param ddosCustomPolicyName The name of the DDoS custom policy.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, ddosCustomPolicyName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, ddosCustomPolicyName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets information about the specified DDoS custom policy.
     * @param resourceGroupName The name of the resource group.
     * @param ddosCustomPolicyName The name of the DDoS custom policy.
     * @param options The options parameters.
     */
    get(resourceGroupName, ddosCustomPolicyName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, ddosCustomPolicyName, options }, getOperationSpec$9);
    }
    /**
     * Creates or updates a DDoS custom policy.
     * @param resourceGroupName The name of the resource group.
     * @param ddosCustomPolicyName The name of the DDoS custom policy.
     * @param parameters Parameters supplied to the create or update operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, ddosCustomPolicyName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, ddosCustomPolicyName, parameters, options }, createOrUpdateOperationSpec$7);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
        });
    }
    /**
     * Creates or updates a DDoS custom policy.
     * @param resourceGroupName The name of the resource group.
     * @param ddosCustomPolicyName The name of the DDoS custom policy.
     * @param parameters Parameters supplied to the create or update operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, ddosCustomPolicyName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, ddosCustomPolicyName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Update a DDoS custom policy tags.
     * @param resourceGroupName The name of the resource group.
     * @param ddosCustomPolicyName The name of the DDoS custom policy.
     * @param parameters Parameters supplied to update DDoS custom policy resource tags.
     * @param options The options parameters.
     */
    updateTags(resourceGroupName, ddosCustomPolicyName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, ddosCustomPolicyName, parameters, options }, updateTagsOperationSpec$7);
    }
}
// Operation Specifications
const serializer$e = coreClient.createSerializer(Mappers, /* isXml */ false);
const deleteOperationSpec$8 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/ddosCustomPolicies/{ddosCustomPolicyName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        ddosCustomPolicyName
    ],
    headerParameters: [accept],
    serializer: serializer$e
};
const getOperationSpec$9 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/ddosCustomPolicies/{ddosCustomPolicyName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DdosCustomPolicy
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        ddosCustomPolicyName
    ],
    headerParameters: [accept],
    serializer: serializer$e
};
const createOrUpdateOperationSpec$7 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/ddosCustomPolicies/{ddosCustomPolicyName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: DdosCustomPolicy
        },
        201: {
            bodyMapper: DdosCustomPolicy
        },
        202: {
            bodyMapper: DdosCustomPolicy
        },
        204: {
            bodyMapper: DdosCustomPolicy
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters9,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        ddosCustomPolicyName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$e
};
const updateTagsOperationSpec$7 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/ddosCustomPolicies/{ddosCustomPolicyName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: DdosCustomPolicy
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        ddosCustomPolicyName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$e
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing DdosProtectionPlans operations. */
class DdosProtectionPlansImpl {
    /**
     * Initialize a new instance of the class DdosProtectionPlans class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all DDoS protection plans in a subscription.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(options);
            }
        };
    }
    listPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets all the DDoS protection plans in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByResourceGroupPagingPage(resourceGroupName, options);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Deletes the specified DDoS protection plan.
     * @param resourceGroupName The name of the resource group.
     * @param ddosProtectionPlanName The name of the DDoS protection plan.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, ddosProtectionPlanName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, ddosProtectionPlanName, options }, deleteOperationSpec$9);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Deletes the specified DDoS protection plan.
     * @param resourceGroupName The name of the resource group.
     * @param ddosProtectionPlanName The name of the DDoS protection plan.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, ddosProtectionPlanName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, ddosProtectionPlanName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets information about the specified DDoS protection plan.
     * @param resourceGroupName The name of the resource group.
     * @param ddosProtectionPlanName The name of the DDoS protection plan.
     * @param options The options parameters.
     */
    get(resourceGroupName, ddosProtectionPlanName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, ddosProtectionPlanName, options }, getOperationSpec$a);
    }
    /**
     * Creates or updates a DDoS protection plan.
     * @param resourceGroupName The name of the resource group.
     * @param ddosProtectionPlanName The name of the DDoS protection plan.
     * @param parameters Parameters supplied to the create or update operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, ddosProtectionPlanName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, ddosProtectionPlanName, parameters, options }, createOrUpdateOperationSpec$8);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
        });
    }
    /**
     * Creates or updates a DDoS protection plan.
     * @param resourceGroupName The name of the resource group.
     * @param ddosProtectionPlanName The name of the DDoS protection plan.
     * @param parameters Parameters supplied to the create or update operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, ddosProtectionPlanName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, ddosProtectionPlanName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Update a DDoS protection plan tags.
     * @param resourceGroupName The name of the resource group.
     * @param ddosProtectionPlanName The name of the DDoS protection plan.
     * @param parameters Parameters supplied to the update DDoS protection plan resource tags.
     * @param options The options parameters.
     */
    updateTags(resourceGroupName, ddosProtectionPlanName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, ddosProtectionPlanName, parameters, options }, updateTagsOperationSpec$8);
    }
    /**
     * Gets all DDoS protection plans in a subscription.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$c);
    }
    /**
     * Gets all the DDoS protection plans in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec$2);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$c);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The name of the resource group.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec$2);
    }
}
// Operation Specifications
const serializer$f = coreClient.createSerializer(Mappers, /* isXml */ false);
const deleteOperationSpec$9 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/ddosProtectionPlans/{ddosProtectionPlanName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        ddosProtectionPlanName
    ],
    headerParameters: [accept],
    serializer: serializer$f
};
const getOperationSpec$a = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/ddosProtectionPlans/{ddosProtectionPlanName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DdosProtectionPlan
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        ddosProtectionPlanName
    ],
    headerParameters: [accept],
    serializer: serializer$f
};
const createOrUpdateOperationSpec$8 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/ddosProtectionPlans/{ddosProtectionPlanName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: DdosProtectionPlan
        },
        201: {
            bodyMapper: DdosProtectionPlan
        },
        202: {
            bodyMapper: DdosProtectionPlan
        },
        204: {
            bodyMapper: DdosProtectionPlan
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters10,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        ddosProtectionPlanName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$f
};
const updateTagsOperationSpec$8 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/ddosProtectionPlans/{ddosProtectionPlanName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: DdosProtectionPlan
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        ddosProtectionPlanName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$f
};
const listOperationSpec$c = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/ddosProtectionPlans",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DdosProtectionPlanListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$f
};
const listByResourceGroupOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/ddosProtectionPlans",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DdosProtectionPlanListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$f
};
const listNextOperationSpec$c = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DdosProtectionPlanListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$f
};
const listByResourceGroupNextOperationSpec$2 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DdosProtectionPlanListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$f
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing DscpConfigurationOperations operations. */
class DscpConfigurationOperationsImpl {
    /**
     * Initialize a new instance of the class DscpConfigurationOperations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a DSCP Configuration.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    list(resourceGroupName, options) {
        const iter = this.listPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, options);
            }
        };
    }
    listPagingPage(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets all dscp configurations in a subscription.
     * @param options The options parameters.
     */
    listAll(options) {
        const iter = this.listAllPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listAllPagingPage(options);
            }
        };
    }
    listAllPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listAllPagingPage_1() {
            let result = yield tslib.__await(this._listAll(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listAllNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listAllPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listAllPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listAllPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Creates or updates a DSCP Configuration.
     * @param resourceGroupName The name of the resource group.
     * @param dscpConfigurationName The name of the resource.
     * @param parameters Parameters supplied to the create or update dscp configuration operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, dscpConfigurationName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, dscpConfigurationName, parameters, options }, createOrUpdateOperationSpec$9);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Creates or updates a DSCP Configuration.
     * @param resourceGroupName The name of the resource group.
     * @param dscpConfigurationName The name of the resource.
     * @param parameters Parameters supplied to the create or update dscp configuration operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, dscpConfigurationName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, dscpConfigurationName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes a DSCP Configuration.
     * @param resourceGroupName The name of the resource group.
     * @param dscpConfigurationName The name of the resource.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, dscpConfigurationName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, dscpConfigurationName, options }, deleteOperationSpec$a);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Deletes a DSCP Configuration.
     * @param resourceGroupName The name of the resource group.
     * @param dscpConfigurationName The name of the resource.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, dscpConfigurationName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, dscpConfigurationName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets a DSCP Configuration.
     * @param resourceGroupName The name of the resource group.
     * @param dscpConfigurationName The name of the resource.
     * @param options The options parameters.
     */
    get(resourceGroupName, dscpConfigurationName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, dscpConfigurationName, options }, getOperationSpec$b);
    }
    /**
     * Gets a DSCP Configuration.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    _list(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listOperationSpec$d);
    }
    /**
     * Gets all dscp configurations in a subscription.
     * @param options The options parameters.
     */
    _listAll(options) {
        return this.client.sendOperationRequest({ options }, listAllOperationSpec$7);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listNextOperationSpec$d);
    }
    /**
     * ListAllNext
     * @param nextLink The nextLink from the previous successful call to the ListAll method.
     * @param options The options parameters.
     */
    _listAllNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listAllNextOperationSpec$7);
    }
}
// Operation Specifications
const serializer$g = coreClient.createSerializer(Mappers, /* isXml */ false);
const createOrUpdateOperationSpec$9 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/dscpConfigurations/{dscpConfigurationName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: DscpConfiguration
        },
        201: {
            bodyMapper: DscpConfiguration
        },
        202: {
            bodyMapper: DscpConfiguration
        },
        204: {
            bodyMapper: DscpConfiguration
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters11,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        dscpConfigurationName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$g
};
const deleteOperationSpec$a = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/dscpConfigurations/{dscpConfigurationName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        dscpConfigurationName
    ],
    headerParameters: [accept],
    serializer: serializer$g
};
const getOperationSpec$b = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/dscpConfigurations/{dscpConfigurationName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DscpConfiguration
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        dscpConfigurationName
    ],
    headerParameters: [accept],
    serializer: serializer$g
};
const listOperationSpec$d = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/dscpConfigurations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DscpConfigurationListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$g
};
const listAllOperationSpec$7 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/dscpConfigurations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DscpConfigurationListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$g
};
const listNextOperationSpec$d = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DscpConfigurationListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$g
};
const listAllNextOperationSpec$7 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DscpConfigurationListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$g
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing AvailableEndpointServices operations. */
class AvailableEndpointServicesImpl {
    /**
     * Initialize a new instance of the class AvailableEndpointServices class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List what values of endpoint services are available for use.
     * @param location The location to check available endpoint services.
     * @param options The options parameters.
     */
    list(location, options) {
        const iter = this.listPagingAll(location, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(location, options);
            }
        };
    }
    listPagingPage(location, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(location, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(location, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(location, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(location, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List what values of endpoint services are available for use.
     * @param location The location to check available endpoint services.
     * @param options The options parameters.
     */
    _list(location, options) {
        return this.client.sendOperationRequest({ location, options }, listOperationSpec$e);
    }
    /**
     * ListNext
     * @param location The location to check available endpoint services.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(location, nextLink, options) {
        return this.client.sendOperationRequest({ location, nextLink, options }, listNextOperationSpec$e);
    }
}
// Operation Specifications
const serializer$h = coreClient.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$e = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/locations/{location}/virtualNetworkAvailableEndpointServices",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: EndpointServicesListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        location
    ],
    headerParameters: [accept],
    serializer: serializer$h
};
const listNextOperationSpec$e = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: EndpointServicesListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
        location
    ],
    headerParameters: [accept],
    serializer: serializer$h
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ExpressRouteCircuitAuthorizations operations. */
class ExpressRouteCircuitAuthorizationsImpl {
    /**
     * Initialize a new instance of the class ExpressRouteCircuitAuthorizations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all authorizations in an express route circuit.
     * @param resourceGroupName The name of the resource group.
     * @param circuitName The name of the circuit.
     * @param options The options parameters.
     */
    list(resourceGroupName, circuitName, options) {
        const iter = this.listPagingAll(resourceGroupName, circuitName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, circuitName, options);
            }
        };
    }
    listPagingPage(resourceGroupName, circuitName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, circuitName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, circuitName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceGroupName, circuitName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, circuitName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Deletes the specified authorization from the specified express route circuit.
     * @param resourceGroupName The name of the resource group.
     * @param circuitName The name of the express route circuit.
     * @param authorizationName The name of the authorization.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, circuitName, authorizationName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, circuitName, authorizationName, options }, deleteOperationSpec$b);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Deletes the specified authorization from the specified express route circuit.
     * @param resourceGroupName The name of the resource group.
     * @param circuitName The name of the express route circuit.
     * @param authorizationName The name of the authorization.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, circuitName, authorizationName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, circuitName, authorizationName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the specified authorization from the specified express route circuit.
     * @param resourceGroupName The name of the resource group.
     * @param circuitName The name of the express route circuit.
     * @param authorizationName The name of the authorization.
     * @param options The options parameters.
     */
    get(resourceGroupName, circuitName, authorizationName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, circuitName, authorizationName, options }, getOperationSpec$c);
    }
    /**
     * Creates or updates an authorization in the specified express route circuit.
     * @param resourceGroupName The name of the resource group.
     * @param circuitName The name of the express route circuit.
     * @param authorizationName The name of the authorization.
     * @param authorizationParameters Parameters supplied to the create or update express route circuit
     *                                authorization operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, circuitName, authorizationName, authorizationParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                circuitName,
                authorizationName,
                authorizationParameters,
                options
            }, createOrUpdateOperationSpec$a);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
        });
    }
    /**
     * Creates or updates an authorization in the specified express route circuit.
     * @param resourceGroupName The name of the resource group.
     * @param circuitName The name of the express route circuit.
     * @param authorizationName The name of the authorization.
     * @param authorizationParameters Parameters supplied to the create or update express route circuit
     *                                authorization operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, circuitName, authorizationName, authorizationParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, circuitName, authorizationName, authorizationParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets all authorizations in an express route circuit.
     * @param resourceGroupName The name of the resource group.
     * @param circuitName The name of the circuit.
     * @param options The options parameters.
     */
    _list(resourceGroupName, circuitName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, circuitName, options }, listOperationSpec$f);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param circuitName The name of the circuit.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, circuitName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, circuitName, nextLink, options }, listNextOperationSpec$f);
    }
}
// Operation Specifications
const serializer$i = coreClient.createSerializer(Mappers, /* isXml */ false);
const deleteOperationSpec$b = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/expressRouteCircuits/{circuitName}/authorizations/{authorizationName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        circuitName,
        authorizationName
    ],
    headerParameters: [accept],
    serializer: serializer$i
};
const getOperationSpec$c = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/expressRouteCircuits/{circuitName}/authorizations/{authorizationName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ExpressRouteCircuitAuthorization
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        circuitName,
        authorizationName
    ],
    headerParameters: [accept],
    serializer: serializer$i
};
const createOrUpdateOperationSpec$a = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/expressRouteCircuits/{circuitName}/authorizations/{authorizationName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ExpressRouteCircuitAuthorization
        },
        201: {
            bodyMapper: ExpressRouteCircuitAuthorization
        },
        202: {
            bodyMapper: ExpressRouteCircuitAuthorization
        },
        204: {
            bodyMapper: ExpressRouteCircuitAuthorization
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: authorizationParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        circuitName,
        authorizationName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$i
};
const listOperationSpec$f = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/expressRouteCircuits/{circuitName}/authorizations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AuthorizationListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        circuitName
    ],
    headerParameters: [accept],
    serializer: serializer$i
};
const listNextOperationSpec$f = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AuthorizationListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        circuitName
    ],
    headerParameters: [accept],
    serializer: serializer$i
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ExpressRouteCircuitPeerings operations. */
class ExpressRouteCircuitPeeringsImpl {
    /**
     * Initialize a new instance of the class ExpressRouteCircuitPeerings class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all peerings in a specified express route circuit.
     * @param resourceGroupName The name of the resource group.
     * @param circuitName The name of the express route circuit.
     * @param options The options parameters.
     */
    list(resourceGroupName, circuitName, options) {
        const iter = this.listPagingAll(resourceGroupName, circuitName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, circuitName, options);
            }
        };
    }
    listPagingPage(resourceGroupName, circuitName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, circuitName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, circuitName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceGroupName, circuitName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, circuitName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Deletes the specified peering from the specified express route circuit.
     * @param resourceGroupName The name of the resource group.
     * @param circuitName The name of the express route circuit.
     * @param peeringName The name of the peering.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, circuitName, peeringName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, circuitName, peeringName, options }, deleteOperationSpec$c);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Deletes the specified peering from the specified express route circuit.
     * @param resourceGroupName The name of the resource group.
     * @param circuitName The name of the express route circuit.
     * @param peeringName The name of the peering.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, circuitName, peeringName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, circuitName, peeringName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the specified peering for the express route circuit.
     * @param resourceGroupName The name of the resource group.
     * @param circuitName The name of the express route circuit.
     * @param peeringName The name of the peering.
     * @param options The options parameters.
     */
    get(resourceGroupName, circuitName, peeringName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, circuitName, peeringName, options }, getOperationSpec$d);
    }
    /**
     * Creates or updates a peering in the specified express route circuits.
     * @param resourceGroupName The name of the resource group.
     * @param circuitName The name of the express route circuit.
     * @param peeringName The name of the peering.
     * @param peeringParameters Parameters supplied to the create or update express route circuit peering
     *                          operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, circuitName, peeringName, peeringParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                circuitName,
                peeringName,
                peeringParameters,
                options
            }, createOrUpdateOperationSpec$b);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
        });
    }
    /**
     * Creates or updates a peering in the specified express route circuits.
     * @param resourceGroupName The name of the resource group.
     * @param circuitName The name of the express route circuit.
     * @param peeringName The name of the peering.
     * @param peeringParameters Parameters supplied to the create or update express route circuit peering
     *                          operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, circuitName, peeringName, peeringParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, circuitName, peeringName, peeringParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets all peerings in a specified express route circuit.
     * @param resourceGroupName The name of the resource group.
     * @param circuitName The name of the express route circuit.
     * @param options The options parameters.
     */
    _list(resourceGroupName, circuitName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, circuitName, options }, listOperationSpec$g);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param circuitName The name of the express route circuit.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, circuitName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, circuitName, nextLink, options }, listNextOperationSpec$g);
    }
}
// Operation Specifications
const serializer$j = coreClient.createSerializer(Mappers, /* isXml */ false);
const deleteOperationSpec$c = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/expressRouteCircuits/{circuitName}/peerings/{peeringName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        circuitName,
        peeringName
    ],
    headerParameters: [accept],
    serializer: serializer$j
};
const getOperationSpec$d = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/expressRouteCircuits/{circuitName}/peerings/{peeringName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ExpressRouteCircuitPeering
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        circuitName,
        peeringName
    ],
    headerParameters: [accept],
    serializer: serializer$j
};
const createOrUpdateOperationSpec$b = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/expressRouteCircuits/{circuitName}/peerings/{peeringName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ExpressRouteCircuitPeering
        },
        201: {
            bodyMapper: ExpressRouteCircuitPeering
        },
        202: {
            bodyMapper: ExpressRouteCircuitPeering
        },
        204: {
            bodyMapper: ExpressRouteCircuitPeering
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: peeringParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        circuitName,
        peeringName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$j
};
const listOperationSpec$g = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/expressRouteCircuits/{circuitName}/peerings",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ExpressRouteCircuitPeeringListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        circuitName
    ],
    headerParameters: [accept],
    serializer: serializer$j
};
const listNextOperationSpec$g = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ExpressRouteCircuitPeeringListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        circuitName
    ],
    headerParameters: [accept],
    serializer: serializer$j
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ExpressRouteCircuitConnections operations. */
class ExpressRouteCircuitConnectionsImpl {
    /**
     * Initialize a new instance of the class ExpressRouteCircuitConnections class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all global reach connections associated with a private peering in an express route circuit.
     * @param resourceGroupName The name of the resource group.
     * @param circuitName The name of the circuit.
     * @param peeringName The name of the peering.
     * @param options The options parameters.
     */
    list(resourceGroupName, circuitName, peeringName, options) {
        const iter = this.listPagingAll(resourceGroupName, circuitName, peeringName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, circuitName, peeringName, options);
            }
        };
    }
    listPagingPage(resourceGroupName, circuitName, peeringName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, circuitName, peeringName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, circuitName, peeringName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceGroupName, circuitName, peeringName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, circuitName, peeringName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Deletes the specified Express Route Circuit Connection from the specified express route circuit.
     * @param resourceGroupName The name of the resource group.
     * @param circuitName The name of the express route circuit.
     * @param peeringName The name of the peering.
     * @param connectionName The name of the express route circuit connection.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, circuitName, peeringName, connectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, circuitName, peeringName, connectionName, options }, deleteOperationSpec$d);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Deletes the specified Express Route Circuit Connection from the specified express route circuit.
     * @param resourceGroupName The name of the resource group.
     * @param circuitName The name of the express route circuit.
     * @param peeringName The name of the peering.
     * @param connectionName The name of the express route circuit connection.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, circuitName, peeringName, connectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, circuitName, peeringName, connectionName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the specified Express Route Circuit Connection from the specified express route circuit.
     * @param resourceGroupName The name of the resource group.
     * @param circuitName The name of the express route circuit.
     * @param peeringName The name of the peering.
     * @param connectionName The name of the express route circuit connection.
     * @param options The options parameters.
     */
    get(resourceGroupName, circuitName, peeringName, connectionName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, circuitName, peeringName, connectionName, options }, getOperationSpec$e);
    }
    /**
     * Creates or updates a Express Route Circuit Connection in the specified express route circuits.
     * @param resourceGroupName The name of the resource group.
     * @param circuitName The name of the express route circuit.
     * @param peeringName The name of the peering.
     * @param connectionName The name of the express route circuit connection.
     * @param expressRouteCircuitConnectionParameters Parameters supplied to the create or update express
     *                                                route circuit connection operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, circuitName, peeringName, connectionName, expressRouteCircuitConnectionParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                circuitName,
                peeringName,
                connectionName,
                expressRouteCircuitConnectionParameters,
                options
            }, createOrUpdateOperationSpec$c);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
        });
    }
    /**
     * Creates or updates a Express Route Circuit Connection in the specified express route circuits.
     * @param resourceGroupName The name of the resource group.
     * @param circuitName The name of the express route circuit.
     * @param peeringName The name of the peering.
     * @param connectionName The name of the express route circuit connection.
     * @param expressRouteCircuitConnectionParameters Parameters supplied to the create or update express
     *                                                route circuit connection operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, circuitName, peeringName, connectionName, expressRouteCircuitConnectionParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, circuitName, peeringName, connectionName, expressRouteCircuitConnectionParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets all global reach connections associated with a private peering in an express route circuit.
     * @param resourceGroupName The name of the resource group.
     * @param circuitName The name of the circuit.
     * @param peeringName The name of the peering.
     * @param options The options parameters.
     */
    _list(resourceGroupName, circuitName, peeringName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, circuitName, peeringName, options }, listOperationSpec$h);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param circuitName The name of the circuit.
     * @param peeringName The name of the peering.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, circuitName, peeringName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, circuitName, peeringName, nextLink, options }, listNextOperationSpec$h);
    }
}
// Operation Specifications
const serializer$k = coreClient.createSerializer(Mappers, /* isXml */ false);
const deleteOperationSpec$d = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/expressRouteCircuits/{circuitName}/peerings/{peeringName}/connections/{connectionName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        connectionName,
        circuitName,
        peeringName
    ],
    headerParameters: [accept],
    serializer: serializer$k
};
const getOperationSpec$e = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/expressRouteCircuits/{circuitName}/peerings/{peeringName}/connections/{connectionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ExpressRouteCircuitConnection
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        connectionName,
        circuitName,
        peeringName
    ],
    headerParameters: [accept],
    serializer: serializer$k
};
const createOrUpdateOperationSpec$c = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/expressRouteCircuits/{circuitName}/peerings/{peeringName}/connections/{connectionName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ExpressRouteCircuitConnection
        },
        201: {
            bodyMapper: ExpressRouteCircuitConnection
        },
        202: {
            bodyMapper: ExpressRouteCircuitConnection
        },
        204: {
            bodyMapper: ExpressRouteCircuitConnection
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: expressRouteCircuitConnectionParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        connectionName,
        circuitName,
        peeringName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$k
};
const listOperationSpec$h = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/expressRouteCircuits/{circuitName}/peerings/{peeringName}/connections",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ExpressRouteCircuitConnectionListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        circuitName,
        peeringName
    ],
    headerParameters: [accept],
    serializer: serializer$k
};
const listNextOperationSpec$h = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ExpressRouteCircuitConnectionListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        circuitName,
        peeringName
    ],
    headerParameters: [accept],
    serializer: serializer$k
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing PeerExpressRouteCircuitConnections operations. */
class PeerExpressRouteCircuitConnectionsImpl {
    /**
     * Initialize a new instance of the class PeerExpressRouteCircuitConnections class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all global reach peer connections associated with a private peering in an express route
     * circuit.
     * @param resourceGroupName The name of the resource group.
     * @param circuitName The name of the circuit.
     * @param peeringName The name of the peering.
     * @param options The options parameters.
     */
    list(resourceGroupName, circuitName, peeringName, options) {
        const iter = this.listPagingAll(resourceGroupName, circuitName, peeringName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, circuitName, peeringName, options);
            }
        };
    }
    listPagingPage(resourceGroupName, circuitName, peeringName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, circuitName, peeringName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, circuitName, peeringName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceGroupName, circuitName, peeringName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, circuitName, peeringName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets the specified Peer Express Route Circuit Connection from the specified express route circuit.
     * @param resourceGroupName The name of the resource group.
     * @param circuitName The name of the express route circuit.
     * @param peeringName The name of the peering.
     * @param connectionName The name of the peer express route circuit connection.
     * @param options The options parameters.
     */
    get(resourceGroupName, circuitName, peeringName, connectionName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, circuitName, peeringName, connectionName, options }, getOperationSpec$f);
    }
    /**
     * Gets all global reach peer connections associated with a private peering in an express route
     * circuit.
     * @param resourceGroupName The name of the resource group.
     * @param circuitName The name of the circuit.
     * @param peeringName The name of the peering.
     * @param options The options parameters.
     */
    _list(resourceGroupName, circuitName, peeringName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, circuitName, peeringName, options }, listOperationSpec$i);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param circuitName The name of the circuit.
     * @param peeringName The name of the peering.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, circuitName, peeringName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, circuitName, peeringName, nextLink, options }, listNextOperationSpec$i);
    }
}
// Operation Specifications
const serializer$l = coreClient.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$f = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/expressRouteCircuits/{circuitName}/peerings/{peeringName}/peerConnections/{connectionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PeerExpressRouteCircuitConnection
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        connectionName,
        circuitName,
        peeringName
    ],
    headerParameters: [accept],
    serializer: serializer$l
};
const listOperationSpec$i = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/expressRouteCircuits/{circuitName}/peerings/{peeringName}/peerConnections",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PeerExpressRouteCircuitConnectionListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        circuitName,
        peeringName
    ],
    headerParameters: [accept],
    serializer: serializer$l
};
const listNextOperationSpec$i = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PeerExpressRouteCircuitConnectionListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        circuitName,
        peeringName
    ],
    headerParameters: [accept],
    serializer: serializer$l
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ExpressRouteCircuits operations. */
class ExpressRouteCircuitsImpl {
    /**
     * Initialize a new instance of the class ExpressRouteCircuits class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all the express route circuits in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    list(resourceGroupName, options) {
        const iter = this.listPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, options);
            }
        };
    }
    listPagingPage(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets all the express route circuits in a subscription.
     * @param options The options parameters.
     */
    listAll(options) {
        const iter = this.listAllPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listAllPagingPage(options);
            }
        };
    }
    listAllPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listAllPagingPage_1() {
            let result = yield tslib.__await(this._listAll(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listAllNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listAllPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listAllPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listAllPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Deletes the specified express route circuit.
     * @param resourceGroupName The name of the resource group.
     * @param circuitName The name of the express route circuit.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, circuitName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, circuitName, options }, deleteOperationSpec$e);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Deletes the specified express route circuit.
     * @param resourceGroupName The name of the resource group.
     * @param circuitName The name of the express route circuit.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, circuitName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, circuitName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets information about the specified express route circuit.
     * @param resourceGroupName The name of the resource group.
     * @param circuitName The name of express route circuit.
     * @param options The options parameters.
     */
    get(resourceGroupName, circuitName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, circuitName, options }, getOperationSpec$g);
    }
    /**
     * Creates or updates an express route circuit.
     * @param resourceGroupName The name of the resource group.
     * @param circuitName The name of the circuit.
     * @param parameters Parameters supplied to the create or update express route circuit operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, circuitName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, circuitName, parameters, options }, createOrUpdateOperationSpec$d);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
        });
    }
    /**
     * Creates or updates an express route circuit.
     * @param resourceGroupName The name of the resource group.
     * @param circuitName The name of the circuit.
     * @param parameters Parameters supplied to the create or update express route circuit operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, circuitName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, circuitName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates an express route circuit tags.
     * @param resourceGroupName The name of the resource group.
     * @param circuitName The name of the circuit.
     * @param parameters Parameters supplied to update express route circuit tags.
     * @param options The options parameters.
     */
    updateTags(resourceGroupName, circuitName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, circuitName, parameters, options }, updateTagsOperationSpec$9);
    }
    /**
     * Gets the currently advertised ARP table associated with the express route circuit in a resource
     * group.
     * @param resourceGroupName The name of the resource group.
     * @param circuitName The name of the express route circuit.
     * @param peeringName The name of the peering.
     * @param devicePath The path of the device.
     * @param options The options parameters.
     */
    beginListArpTable(resourceGroupName, circuitName, peeringName, devicePath, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, circuitName, peeringName, devicePath, options }, listArpTableOperationSpec);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Gets the currently advertised ARP table associated with the express route circuit in a resource
     * group.
     * @param resourceGroupName The name of the resource group.
     * @param circuitName The name of the express route circuit.
     * @param peeringName The name of the peering.
     * @param devicePath The path of the device.
     * @param options The options parameters.
     */
    beginListArpTableAndWait(resourceGroupName, circuitName, peeringName, devicePath, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginListArpTable(resourceGroupName, circuitName, peeringName, devicePath, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the currently advertised routes table associated with the express route circuit in a resource
     * group.
     * @param resourceGroupName The name of the resource group.
     * @param circuitName The name of the express route circuit.
     * @param peeringName The name of the peering.
     * @param devicePath The path of the device.
     * @param options The options parameters.
     */
    beginListRoutesTable(resourceGroupName, circuitName, peeringName, devicePath, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, circuitName, peeringName, devicePath, options }, listRoutesTableOperationSpec);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Gets the currently advertised routes table associated with the express route circuit in a resource
     * group.
     * @param resourceGroupName The name of the resource group.
     * @param circuitName The name of the express route circuit.
     * @param peeringName The name of the peering.
     * @param devicePath The path of the device.
     * @param options The options parameters.
     */
    beginListRoutesTableAndWait(resourceGroupName, circuitName, peeringName, devicePath, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginListRoutesTable(resourceGroupName, circuitName, peeringName, devicePath, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the currently advertised routes table summary associated with the express route circuit in a
     * resource group.
     * @param resourceGroupName The name of the resource group.
     * @param circuitName The name of the express route circuit.
     * @param peeringName The name of the peering.
     * @param devicePath The path of the device.
     * @param options The options parameters.
     */
    beginListRoutesTableSummary(resourceGroupName, circuitName, peeringName, devicePath, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, circuitName, peeringName, devicePath, options }, listRoutesTableSummaryOperationSpec);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Gets the currently advertised routes table summary associated with the express route circuit in a
     * resource group.
     * @param resourceGroupName The name of the resource group.
     * @param circuitName The name of the express route circuit.
     * @param peeringName The name of the peering.
     * @param devicePath The path of the device.
     * @param options The options parameters.
     */
    beginListRoutesTableSummaryAndWait(resourceGroupName, circuitName, peeringName, devicePath, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginListRoutesTableSummary(resourceGroupName, circuitName, peeringName, devicePath, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets all the stats from an express route circuit in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param circuitName The name of the express route circuit.
     * @param options The options parameters.
     */
    getStats(resourceGroupName, circuitName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, circuitName, options }, getStatsOperationSpec);
    }
    /**
     * Gets all stats from an express route circuit in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param circuitName The name of the express route circuit.
     * @param peeringName The name of the peering.
     * @param options The options parameters.
     */
    getPeeringStats(resourceGroupName, circuitName, peeringName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, circuitName, peeringName, options }, getPeeringStatsOperationSpec);
    }
    /**
     * Gets all the express route circuits in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    _list(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listOperationSpec$j);
    }
    /**
     * Gets all the express route circuits in a subscription.
     * @param options The options parameters.
     */
    _listAll(options) {
        return this.client.sendOperationRequest({ options }, listAllOperationSpec$8);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listNextOperationSpec$j);
    }
    /**
     * ListAllNext
     * @param nextLink The nextLink from the previous successful call to the ListAll method.
     * @param options The options parameters.
     */
    _listAllNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listAllNextOperationSpec$8);
    }
}
// Operation Specifications
const serializer$m = coreClient.createSerializer(Mappers, /* isXml */ false);
const deleteOperationSpec$e = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/expressRouteCircuits/{circuitName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        circuitName
    ],
    headerParameters: [accept],
    serializer: serializer$m
};
const getOperationSpec$g = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/expressRouteCircuits/{circuitName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ExpressRouteCircuit
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        circuitName
    ],
    headerParameters: [accept],
    serializer: serializer$m
};
const createOrUpdateOperationSpec$d = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/expressRouteCircuits/{circuitName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ExpressRouteCircuit
        },
        201: {
            bodyMapper: ExpressRouteCircuit
        },
        202: {
            bodyMapper: ExpressRouteCircuit
        },
        204: {
            bodyMapper: ExpressRouteCircuit
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters12,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        circuitName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$m
};
const updateTagsOperationSpec$9 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/expressRouteCircuits/{circuitName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: ExpressRouteCircuit
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        circuitName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$m
};
const listArpTableOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/expressRouteCircuits/{circuitName}/peerings/{peeringName}/arpTables/{devicePath}",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: ExpressRouteCircuitsArpTableListResult
        },
        201: {
            bodyMapper: ExpressRouteCircuitsArpTableListResult
        },
        202: {
            bodyMapper: ExpressRouteCircuitsArpTableListResult
        },
        204: {
            bodyMapper: ExpressRouteCircuitsArpTableListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        circuitName,
        peeringName,
        devicePath
    ],
    headerParameters: [accept],
    serializer: serializer$m
};
const listRoutesTableOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/expressRouteCircuits/{circuitName}/peerings/{peeringName}/routeTables/{devicePath}",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: ExpressRouteCircuitsRoutesTableListResult
        },
        201: {
            bodyMapper: ExpressRouteCircuitsRoutesTableListResult
        },
        202: {
            bodyMapper: ExpressRouteCircuitsRoutesTableListResult
        },
        204: {
            bodyMapper: ExpressRouteCircuitsRoutesTableListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        circuitName,
        peeringName,
        devicePath
    ],
    headerParameters: [accept],
    serializer: serializer$m
};
const listRoutesTableSummaryOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/expressRouteCircuits/{circuitName}/peerings/{peeringName}/routeTablesSummary/{devicePath}",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: ExpressRouteCircuitsRoutesTableSummaryListResult
        },
        201: {
            bodyMapper: ExpressRouteCircuitsRoutesTableSummaryListResult
        },
        202: {
            bodyMapper: ExpressRouteCircuitsRoutesTableSummaryListResult
        },
        204: {
            bodyMapper: ExpressRouteCircuitsRoutesTableSummaryListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        circuitName,
        peeringName,
        devicePath
    ],
    headerParameters: [accept],
    serializer: serializer$m
};
const getStatsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/expressRouteCircuits/{circuitName}/stats",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ExpressRouteCircuitStats
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        circuitName
    ],
    headerParameters: [accept],
    serializer: serializer$m
};
const getPeeringStatsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/expressRouteCircuits/{circuitName}/peerings/{peeringName}/stats",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ExpressRouteCircuitStats
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        circuitName,
        peeringName
    ],
    headerParameters: [accept],
    serializer: serializer$m
};
const listOperationSpec$j = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/expressRouteCircuits",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ExpressRouteCircuitListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$m
};
const listAllOperationSpec$8 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/expressRouteCircuits",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ExpressRouteCircuitListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$m
};
const listNextOperationSpec$j = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ExpressRouteCircuitListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$m
};
const listAllNextOperationSpec$8 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ExpressRouteCircuitListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$m
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ExpressRouteServiceProviders operations. */
class ExpressRouteServiceProvidersImpl {
    /**
     * Initialize a new instance of the class ExpressRouteServiceProviders class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all the available express route service providers.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(options);
            }
        };
    }
    listPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets all the available express route service providers.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$k);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$k);
    }
}
// Operation Specifications
const serializer$n = coreClient.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$k = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/expressRouteServiceProviders",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ExpressRouteServiceProviderListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$n
};
const listNextOperationSpec$k = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ExpressRouteServiceProviderListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$n
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ExpressRouteCrossConnections operations. */
class ExpressRouteCrossConnectionsImpl {
    /**
     * Initialize a new instance of the class ExpressRouteCrossConnections class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Retrieves all the ExpressRouteCrossConnections in a subscription.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(options);
            }
        };
    }
    listPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Retrieves all the ExpressRouteCrossConnections in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByResourceGroupPagingPage(resourceGroupName, options);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Retrieves all the ExpressRouteCrossConnections in a subscription.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$l);
    }
    /**
     * Retrieves all the ExpressRouteCrossConnections in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec$3);
    }
    /**
     * Gets details about the specified ExpressRouteCrossConnection.
     * @param resourceGroupName The name of the resource group (peering location of the circuit).
     * @param crossConnectionName The name of the ExpressRouteCrossConnection (service key of the circuit).
     * @param options The options parameters.
     */
    get(resourceGroupName, crossConnectionName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, crossConnectionName, options }, getOperationSpec$h);
    }
    /**
     * Update the specified ExpressRouteCrossConnection.
     * @param resourceGroupName The name of the resource group.
     * @param crossConnectionName The name of the ExpressRouteCrossConnection.
     * @param parameters Parameters supplied to the update express route crossConnection operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, crossConnectionName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, crossConnectionName, parameters, options }, createOrUpdateOperationSpec$e);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
        });
    }
    /**
     * Update the specified ExpressRouteCrossConnection.
     * @param resourceGroupName The name of the resource group.
     * @param crossConnectionName The name of the ExpressRouteCrossConnection.
     * @param parameters Parameters supplied to the update express route crossConnection operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, crossConnectionName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, crossConnectionName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates an express route cross connection tags.
     * @param resourceGroupName The name of the resource group.
     * @param crossConnectionName The name of the cross connection.
     * @param crossConnectionParameters Parameters supplied to update express route cross connection tags.
     * @param options The options parameters.
     */
    updateTags(resourceGroupName, crossConnectionName, crossConnectionParameters, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            crossConnectionName,
            crossConnectionParameters,
            options
        }, updateTagsOperationSpec$a);
    }
    /**
     * Gets the currently advertised ARP table associated with the express route cross connection in a
     * resource group.
     * @param resourceGroupName The name of the resource group.
     * @param crossConnectionName The name of the ExpressRouteCrossConnection.
     * @param peeringName The name of the peering.
     * @param devicePath The path of the device.
     * @param options The options parameters.
     */
    beginListArpTable(resourceGroupName, crossConnectionName, peeringName, devicePath, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                crossConnectionName,
                peeringName,
                devicePath,
                options
            }, listArpTableOperationSpec$1);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Gets the currently advertised ARP table associated with the express route cross connection in a
     * resource group.
     * @param resourceGroupName The name of the resource group.
     * @param crossConnectionName The name of the ExpressRouteCrossConnection.
     * @param peeringName The name of the peering.
     * @param devicePath The path of the device.
     * @param options The options parameters.
     */
    beginListArpTableAndWait(resourceGroupName, crossConnectionName, peeringName, devicePath, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginListArpTable(resourceGroupName, crossConnectionName, peeringName, devicePath, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the route table summary associated with the express route cross connection in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param crossConnectionName The name of the ExpressRouteCrossConnection.
     * @param peeringName The name of the peering.
     * @param devicePath The path of the device.
     * @param options The options parameters.
     */
    beginListRoutesTableSummary(resourceGroupName, crossConnectionName, peeringName, devicePath, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                crossConnectionName,
                peeringName,
                devicePath,
                options
            }, listRoutesTableSummaryOperationSpec$1);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Gets the route table summary associated with the express route cross connection in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param crossConnectionName The name of the ExpressRouteCrossConnection.
     * @param peeringName The name of the peering.
     * @param devicePath The path of the device.
     * @param options The options parameters.
     */
    beginListRoutesTableSummaryAndWait(resourceGroupName, crossConnectionName, peeringName, devicePath, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginListRoutesTableSummary(resourceGroupName, crossConnectionName, peeringName, devicePath, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the currently advertised routes table associated with the express route cross connection in a
     * resource group.
     * @param resourceGroupName The name of the resource group.
     * @param crossConnectionName The name of the ExpressRouteCrossConnection.
     * @param peeringName The name of the peering.
     * @param devicePath The path of the device.
     * @param options The options parameters.
     */
    beginListRoutesTable(resourceGroupName, crossConnectionName, peeringName, devicePath, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                crossConnectionName,
                peeringName,
                devicePath,
                options
            }, listRoutesTableOperationSpec$1);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Gets the currently advertised routes table associated with the express route cross connection in a
     * resource group.
     * @param resourceGroupName The name of the resource group.
     * @param crossConnectionName The name of the ExpressRouteCrossConnection.
     * @param peeringName The name of the peering.
     * @param devicePath The path of the device.
     * @param options The options parameters.
     */
    beginListRoutesTableAndWait(resourceGroupName, crossConnectionName, peeringName, devicePath, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginListRoutesTable(resourceGroupName, crossConnectionName, peeringName, devicePath, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$l);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The name of the resource group.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec$3);
    }
}
// Operation Specifications
const serializer$o = coreClient.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$l = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/expressRouteCrossConnections",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ExpressRouteCrossConnectionListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$o
};
const listByResourceGroupOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/expressRouteCrossConnections",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ExpressRouteCrossConnectionListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$o
};
const getOperationSpec$h = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/expressRouteCrossConnections/{crossConnectionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ExpressRouteCrossConnection
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        crossConnectionName
    ],
    headerParameters: [accept],
    serializer: serializer$o
};
const createOrUpdateOperationSpec$e = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/expressRouteCrossConnections/{crossConnectionName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ExpressRouteCrossConnection
        },
        201: {
            bodyMapper: ExpressRouteCrossConnection
        },
        202: {
            bodyMapper: ExpressRouteCrossConnection
        },
        204: {
            bodyMapper: ExpressRouteCrossConnection
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters13,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        crossConnectionName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$o
};
const updateTagsOperationSpec$a = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/expressRouteCrossConnections/{crossConnectionName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: ExpressRouteCrossConnection
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: crossConnectionParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        crossConnectionName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$o
};
const listArpTableOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/expressRouteCrossConnections/{crossConnectionName}/peerings/{peeringName}/arpTables/{devicePath}",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: ExpressRouteCircuitsArpTableListResult
        },
        201: {
            bodyMapper: ExpressRouteCircuitsArpTableListResult
        },
        202: {
            bodyMapper: ExpressRouteCircuitsArpTableListResult
        },
        204: {
            bodyMapper: ExpressRouteCircuitsArpTableListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        peeringName,
        devicePath,
        crossConnectionName
    ],
    headerParameters: [accept],
    serializer: serializer$o
};
const listRoutesTableSummaryOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/expressRouteCrossConnections/{crossConnectionName}/peerings/{peeringName}/routeTablesSummary/{devicePath}",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: ExpressRouteCrossConnectionsRoutesTableSummaryListResult
        },
        201: {
            bodyMapper: ExpressRouteCrossConnectionsRoutesTableSummaryListResult
        },
        202: {
            bodyMapper: ExpressRouteCrossConnectionsRoutesTableSummaryListResult
        },
        204: {
            bodyMapper: ExpressRouteCrossConnectionsRoutesTableSummaryListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        peeringName,
        devicePath,
        crossConnectionName
    ],
    headerParameters: [accept],
    serializer: serializer$o
};
const listRoutesTableOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/expressRouteCrossConnections/{crossConnectionName}/peerings/{peeringName}/routeTables/{devicePath}",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: ExpressRouteCircuitsRoutesTableListResult
        },
        201: {
            bodyMapper: ExpressRouteCircuitsRoutesTableListResult
        },
        202: {
            bodyMapper: ExpressRouteCircuitsRoutesTableListResult
        },
        204: {
            bodyMapper: ExpressRouteCircuitsRoutesTableListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        peeringName,
        devicePath,
        crossConnectionName
    ],
    headerParameters: [accept],
    serializer: serializer$o
};
const listNextOperationSpec$l = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ExpressRouteCrossConnectionListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$o
};
const listByResourceGroupNextOperationSpec$3 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ExpressRouteCrossConnectionListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$o
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ExpressRouteCrossConnectionPeerings operations. */
class ExpressRouteCrossConnectionPeeringsImpl {
    /**
     * Initialize a new instance of the class ExpressRouteCrossConnectionPeerings class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all peerings in a specified ExpressRouteCrossConnection.
     * @param resourceGroupName The name of the resource group.
     * @param crossConnectionName The name of the ExpressRouteCrossConnection.
     * @param options The options parameters.
     */
    list(resourceGroupName, crossConnectionName, options) {
        const iter = this.listPagingAll(resourceGroupName, crossConnectionName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, crossConnectionName, options);
            }
        };
    }
    listPagingPage(resourceGroupName, crossConnectionName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, crossConnectionName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, crossConnectionName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceGroupName, crossConnectionName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, crossConnectionName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets all peerings in a specified ExpressRouteCrossConnection.
     * @param resourceGroupName The name of the resource group.
     * @param crossConnectionName The name of the ExpressRouteCrossConnection.
     * @param options The options parameters.
     */
    _list(resourceGroupName, crossConnectionName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, crossConnectionName, options }, listOperationSpec$m);
    }
    /**
     * Deletes the specified peering from the ExpressRouteCrossConnection.
     * @param resourceGroupName The name of the resource group.
     * @param crossConnectionName The name of the ExpressRouteCrossConnection.
     * @param peeringName The name of the peering.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, crossConnectionName, peeringName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, crossConnectionName, peeringName, options }, deleteOperationSpec$f);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Deletes the specified peering from the ExpressRouteCrossConnection.
     * @param resourceGroupName The name of the resource group.
     * @param crossConnectionName The name of the ExpressRouteCrossConnection.
     * @param peeringName The name of the peering.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, crossConnectionName, peeringName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, crossConnectionName, peeringName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the specified peering for the ExpressRouteCrossConnection.
     * @param resourceGroupName The name of the resource group.
     * @param crossConnectionName The name of the ExpressRouteCrossConnection.
     * @param peeringName The name of the peering.
     * @param options The options parameters.
     */
    get(resourceGroupName, crossConnectionName, peeringName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, crossConnectionName, peeringName, options }, getOperationSpec$i);
    }
    /**
     * Creates or updates a peering in the specified ExpressRouteCrossConnection.
     * @param resourceGroupName The name of the resource group.
     * @param crossConnectionName The name of the ExpressRouteCrossConnection.
     * @param peeringName The name of the peering.
     * @param peeringParameters Parameters supplied to the create or update ExpressRouteCrossConnection
     *                          peering operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, crossConnectionName, peeringName, peeringParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                crossConnectionName,
                peeringName,
                peeringParameters,
                options
            }, createOrUpdateOperationSpec$f);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
        });
    }
    /**
     * Creates or updates a peering in the specified ExpressRouteCrossConnection.
     * @param resourceGroupName The name of the resource group.
     * @param crossConnectionName The name of the ExpressRouteCrossConnection.
     * @param peeringName The name of the peering.
     * @param peeringParameters Parameters supplied to the create or update ExpressRouteCrossConnection
     *                          peering operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, crossConnectionName, peeringName, peeringParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, crossConnectionName, peeringName, peeringParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param crossConnectionName The name of the ExpressRouteCrossConnection.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, crossConnectionName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, crossConnectionName, nextLink, options }, listNextOperationSpec$m);
    }
}
// Operation Specifications
const serializer$p = coreClient.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$m = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/expressRouteCrossConnections/{crossConnectionName}/peerings",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ExpressRouteCrossConnectionPeeringList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        crossConnectionName
    ],
    headerParameters: [accept],
    serializer: serializer$p
};
const deleteOperationSpec$f = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/expressRouteCrossConnections/{crossConnectionName}/peerings/{peeringName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        peeringName,
        crossConnectionName
    ],
    headerParameters: [accept],
    serializer: serializer$p
};
const getOperationSpec$i = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/expressRouteCrossConnections/{crossConnectionName}/peerings/{peeringName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ExpressRouteCrossConnectionPeering
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        peeringName,
        crossConnectionName
    ],
    headerParameters: [accept],
    serializer: serializer$p
};
const createOrUpdateOperationSpec$f = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/expressRouteCrossConnections/{crossConnectionName}/peerings/{peeringName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ExpressRouteCrossConnectionPeering
        },
        201: {
            bodyMapper: ExpressRouteCrossConnectionPeering
        },
        202: {
            bodyMapper: ExpressRouteCrossConnectionPeering
        },
        204: {
            bodyMapper: ExpressRouteCrossConnectionPeering
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: peeringParameters1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        peeringName,
        crossConnectionName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$p
};
const listNextOperationSpec$m = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ExpressRouteCrossConnectionPeeringList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        crossConnectionName
    ],
    headerParameters: [accept],
    serializer: serializer$p
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ExpressRoutePortsLocations operations. */
class ExpressRoutePortsLocationsImpl {
    /**
     * Initialize a new instance of the class ExpressRoutePortsLocations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Retrieves all ExpressRoutePort peering locations. Does not return available bandwidths for each
     * location. Available bandwidths can only be obtained when retrieving a specific peering location.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(options);
            }
        };
    }
    listPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Retrieves all ExpressRoutePort peering locations. Does not return available bandwidths for each
     * location. Available bandwidths can only be obtained when retrieving a specific peering location.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$n);
    }
    /**
     * Retrieves a single ExpressRoutePort peering location, including the list of available bandwidths
     * available at said peering location.
     * @param locationName Name of the requested ExpressRoutePort peering location.
     * @param options The options parameters.
     */
    get(locationName, options) {
        return this.client.sendOperationRequest({ locationName, options }, getOperationSpec$j);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$n);
    }
}
// Operation Specifications
const serializer$q = coreClient.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$n = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/ExpressRoutePortsLocations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ExpressRoutePortsLocationListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$q
};
const getOperationSpec$j = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/ExpressRoutePortsLocations/{locationName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ExpressRoutePortsLocation
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        locationName
    ],
    headerParameters: [accept],
    serializer: serializer$q
};
const listNextOperationSpec$n = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ExpressRoutePortsLocationListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$q
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ExpressRoutePorts operations. */
class ExpressRoutePortsImpl {
    /**
     * Initialize a new instance of the class ExpressRoutePorts class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List all the ExpressRoutePort resources in the specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByResourceGroupPagingPage(resourceGroupName, options);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List all the ExpressRoutePort resources in the specified subscription.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(options);
            }
        };
    }
    listPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Deletes the specified ExpressRoutePort resource.
     * @param resourceGroupName The name of the resource group.
     * @param expressRoutePortName The name of the ExpressRoutePort resource.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, expressRoutePortName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, expressRoutePortName, options }, deleteOperationSpec$g);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Deletes the specified ExpressRoutePort resource.
     * @param resourceGroupName The name of the resource group.
     * @param expressRoutePortName The name of the ExpressRoutePort resource.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, expressRoutePortName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, expressRoutePortName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Retrieves the requested ExpressRoutePort resource.
     * @param resourceGroupName The name of the resource group.
     * @param expressRoutePortName The name of ExpressRoutePort.
     * @param options The options parameters.
     */
    get(resourceGroupName, expressRoutePortName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, expressRoutePortName, options }, getOperationSpec$k);
    }
    /**
     * Creates or updates the specified ExpressRoutePort resource.
     * @param resourceGroupName The name of the resource group.
     * @param expressRoutePortName The name of the ExpressRoutePort resource.
     * @param parameters Parameters supplied to the create ExpressRoutePort operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, expressRoutePortName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, expressRoutePortName, parameters, options }, createOrUpdateOperationSpec$g);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
        });
    }
    /**
     * Creates or updates the specified ExpressRoutePort resource.
     * @param resourceGroupName The name of the resource group.
     * @param expressRoutePortName The name of the ExpressRoutePort resource.
     * @param parameters Parameters supplied to the create ExpressRoutePort operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, expressRoutePortName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, expressRoutePortName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Update ExpressRoutePort tags.
     * @param resourceGroupName The name of the resource group.
     * @param expressRoutePortName The name of the ExpressRoutePort resource.
     * @param parameters Parameters supplied to update ExpressRoutePort resource tags.
     * @param options The options parameters.
     */
    updateTags(resourceGroupName, expressRoutePortName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, expressRoutePortName, parameters, options }, updateTagsOperationSpec$b);
    }
    /**
     * List all the ExpressRoutePort resources in the specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec$4);
    }
    /**
     * List all the ExpressRoutePort resources in the specified subscription.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$o);
    }
    /**
     * Generate a letter of authorization for the requested ExpressRoutePort resource.
     * @param resourceGroupName The name of the resource group.
     * @param expressRoutePortName The name of ExpressRoutePort.
     * @param request Request parameters supplied to generate a letter of authorization.
     * @param options The options parameters.
     */
    generateLOA(resourceGroupName, expressRoutePortName, request, options) {
        return this.client.sendOperationRequest({ resourceGroupName, expressRoutePortName, request, options }, generateLOAOperationSpec);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The name of the resource group.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec$4);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$o);
    }
}
// Operation Specifications
const serializer$r = coreClient.createSerializer(Mappers, /* isXml */ false);
const deleteOperationSpec$g = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/ExpressRoutePorts/{expressRoutePortName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        expressRoutePortName
    ],
    headerParameters: [accept],
    serializer: serializer$r
};
const getOperationSpec$k = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/ExpressRoutePorts/{expressRoutePortName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ExpressRoutePort
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        expressRoutePortName
    ],
    headerParameters: [accept],
    serializer: serializer$r
};
const createOrUpdateOperationSpec$g = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/ExpressRoutePorts/{expressRoutePortName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ExpressRoutePort
        },
        201: {
            bodyMapper: ExpressRoutePort
        },
        202: {
            bodyMapper: ExpressRoutePort
        },
        204: {
            bodyMapper: ExpressRoutePort
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters14,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        expressRoutePortName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$r
};
const updateTagsOperationSpec$b = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/ExpressRoutePorts/{expressRoutePortName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: ExpressRoutePort
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        expressRoutePortName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$r
};
const listByResourceGroupOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/ExpressRoutePorts",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ExpressRoutePortListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$r
};
const listOperationSpec$o = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/ExpressRoutePorts",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ExpressRoutePortListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$r
};
const generateLOAOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/expressRoutePorts/{expressRoutePortName}/generateLoa",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: GenerateExpressRoutePortsLOAResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: request,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        expressRoutePortName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$r
};
const listByResourceGroupNextOperationSpec$4 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ExpressRoutePortListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$r
};
const listNextOperationSpec$o = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ExpressRoutePortListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$r
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ExpressRouteLinks operations. */
class ExpressRouteLinksImpl {
    /**
     * Initialize a new instance of the class ExpressRouteLinks class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Retrieve the ExpressRouteLink sub-resources of the specified ExpressRoutePort resource.
     * @param resourceGroupName The name of the resource group.
     * @param expressRoutePortName The name of the ExpressRoutePort resource.
     * @param options The options parameters.
     */
    list(resourceGroupName, expressRoutePortName, options) {
        const iter = this.listPagingAll(resourceGroupName, expressRoutePortName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, expressRoutePortName, options);
            }
        };
    }
    listPagingPage(resourceGroupName, expressRoutePortName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, expressRoutePortName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, expressRoutePortName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceGroupName, expressRoutePortName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, expressRoutePortName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Retrieves the specified ExpressRouteLink resource.
     * @param resourceGroupName The name of the resource group.
     * @param expressRoutePortName The name of the ExpressRoutePort resource.
     * @param linkName The name of the ExpressRouteLink resource.
     * @param options The options parameters.
     */
    get(resourceGroupName, expressRoutePortName, linkName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, expressRoutePortName, linkName, options }, getOperationSpec$l);
    }
    /**
     * Retrieve the ExpressRouteLink sub-resources of the specified ExpressRoutePort resource.
     * @param resourceGroupName The name of the resource group.
     * @param expressRoutePortName The name of the ExpressRoutePort resource.
     * @param options The options parameters.
     */
    _list(resourceGroupName, expressRoutePortName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, expressRoutePortName, options }, listOperationSpec$p);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param expressRoutePortName The name of the ExpressRoutePort resource.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, expressRoutePortName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, expressRoutePortName, nextLink, options }, listNextOperationSpec$p);
    }
}
// Operation Specifications
const serializer$s = coreClient.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$l = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/ExpressRoutePorts/{expressRoutePortName}/links/{linkName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ExpressRouteLink
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        expressRoutePortName,
        linkName
    ],
    headerParameters: [accept],
    serializer: serializer$s
};
const listOperationSpec$p = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/ExpressRoutePorts/{expressRoutePortName}/links",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ExpressRouteLinkListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        expressRoutePortName
    ],
    headerParameters: [accept],
    serializer: serializer$s
};
const listNextOperationSpec$p = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ExpressRouteLinkListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        expressRoutePortName
    ],
    headerParameters: [accept],
    serializer: serializer$s
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing FirewallPolicies operations. */
class FirewallPoliciesImpl {
    /**
     * Initialize a new instance of the class FirewallPolicies class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all Firewall Policies in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    list(resourceGroupName, options) {
        const iter = this.listPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, options);
            }
        };
    }
    listPagingPage(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets all the Firewall Policies in a subscription.
     * @param options The options parameters.
     */
    listAll(options) {
        const iter = this.listAllPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listAllPagingPage(options);
            }
        };
    }
    listAllPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listAllPagingPage_1() {
            let result = yield tslib.__await(this._listAll(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listAllNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listAllPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listAllPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listAllPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Deletes the specified Firewall Policy.
     * @param resourceGroupName The name of the resource group.
     * @param firewallPolicyName The name of the Firewall Policy.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, firewallPolicyName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, firewallPolicyName, options }, deleteOperationSpec$h);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Deletes the specified Firewall Policy.
     * @param resourceGroupName The name of the resource group.
     * @param firewallPolicyName The name of the Firewall Policy.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, firewallPolicyName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, firewallPolicyName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the specified Firewall Policy.
     * @param resourceGroupName The name of the resource group.
     * @param firewallPolicyName The name of the Firewall Policy.
     * @param options The options parameters.
     */
    get(resourceGroupName, firewallPolicyName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, firewallPolicyName, options }, getOperationSpec$m);
    }
    /**
     * Creates or updates the specified Firewall Policy.
     * @param resourceGroupName The name of the resource group.
     * @param firewallPolicyName The name of the Firewall Policy.
     * @param parameters Parameters supplied to the create or update Firewall Policy operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, firewallPolicyName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, firewallPolicyName, parameters, options }, createOrUpdateOperationSpec$h);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
        });
    }
    /**
     * Creates or updates the specified Firewall Policy.
     * @param resourceGroupName The name of the resource group.
     * @param firewallPolicyName The name of the Firewall Policy.
     * @param parameters Parameters supplied to the create or update Firewall Policy operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, firewallPolicyName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, firewallPolicyName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Lists all Firewall Policies in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    _list(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listOperationSpec$q);
    }
    /**
     * Gets all the Firewall Policies in a subscription.
     * @param options The options parameters.
     */
    _listAll(options) {
        return this.client.sendOperationRequest({ options }, listAllOperationSpec$9);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listNextOperationSpec$q);
    }
    /**
     * ListAllNext
     * @param nextLink The nextLink from the previous successful call to the ListAll method.
     * @param options The options parameters.
     */
    _listAllNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listAllNextOperationSpec$9);
    }
}
// Operation Specifications
const serializer$t = coreClient.createSerializer(Mappers, /* isXml */ false);
const deleteOperationSpec$h = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/firewallPolicies/{firewallPolicyName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        firewallPolicyName
    ],
    headerParameters: [accept],
    serializer: serializer$t
};
const getOperationSpec$m = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/firewallPolicies/{firewallPolicyName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: FirewallPolicy
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, expand],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        firewallPolicyName
    ],
    headerParameters: [accept],
    serializer: serializer$t
};
const createOrUpdateOperationSpec$h = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/firewallPolicies/{firewallPolicyName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: FirewallPolicy
        },
        201: {
            bodyMapper: FirewallPolicy
        },
        202: {
            bodyMapper: FirewallPolicy
        },
        204: {
            bodyMapper: FirewallPolicy
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters15,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        firewallPolicyName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$t
};
const listOperationSpec$q = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/firewallPolicies",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: FirewallPolicyListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$t
};
const listAllOperationSpec$9 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/firewallPolicies",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: FirewallPolicyListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$t
};
const listNextOperationSpec$q = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: FirewallPolicyListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$t
};
const listAllNextOperationSpec$9 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: FirewallPolicyListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$t
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing FirewallPolicyRuleCollectionGroups operations. */
class FirewallPolicyRuleCollectionGroupsImpl {
    /**
     * Initialize a new instance of the class FirewallPolicyRuleCollectionGroups class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all FirewallPolicyRuleCollectionGroups in a FirewallPolicy resource.
     * @param resourceGroupName The name of the resource group.
     * @param firewallPolicyName The name of the Firewall Policy.
     * @param options The options parameters.
     */
    list(resourceGroupName, firewallPolicyName, options) {
        const iter = this.listPagingAll(resourceGroupName, firewallPolicyName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, firewallPolicyName, options);
            }
        };
    }
    listPagingPage(resourceGroupName, firewallPolicyName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, firewallPolicyName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, firewallPolicyName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceGroupName, firewallPolicyName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, firewallPolicyName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Deletes the specified FirewallPolicyRuleCollectionGroup.
     * @param resourceGroupName The name of the resource group.
     * @param firewallPolicyName The name of the Firewall Policy.
     * @param ruleCollectionGroupName The name of the FirewallPolicyRuleCollectionGroup.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, firewallPolicyName, ruleCollectionGroupName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                firewallPolicyName,
                ruleCollectionGroupName,
                options
            }, deleteOperationSpec$i);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Deletes the specified FirewallPolicyRuleCollectionGroup.
     * @param resourceGroupName The name of the resource group.
     * @param firewallPolicyName The name of the Firewall Policy.
     * @param ruleCollectionGroupName The name of the FirewallPolicyRuleCollectionGroup.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, firewallPolicyName, ruleCollectionGroupName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, firewallPolicyName, ruleCollectionGroupName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the specified FirewallPolicyRuleCollectionGroup.
     * @param resourceGroupName The name of the resource group.
     * @param firewallPolicyName The name of the Firewall Policy.
     * @param ruleCollectionGroupName The name of the FirewallPolicyRuleCollectionGroup.
     * @param options The options parameters.
     */
    get(resourceGroupName, firewallPolicyName, ruleCollectionGroupName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            firewallPolicyName,
            ruleCollectionGroupName,
            options
        }, getOperationSpec$n);
    }
    /**
     * Creates or updates the specified FirewallPolicyRuleCollectionGroup.
     * @param resourceGroupName The name of the resource group.
     * @param firewallPolicyName The name of the Firewall Policy.
     * @param ruleCollectionGroupName The name of the FirewallPolicyRuleCollectionGroup.
     * @param parameters Parameters supplied to the create or update FirewallPolicyRuleCollectionGroup
     *                   operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, firewallPolicyName, ruleCollectionGroupName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                firewallPolicyName,
                ruleCollectionGroupName,
                parameters,
                options
            }, createOrUpdateOperationSpec$i);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
        });
    }
    /**
     * Creates or updates the specified FirewallPolicyRuleCollectionGroup.
     * @param resourceGroupName The name of the resource group.
     * @param firewallPolicyName The name of the Firewall Policy.
     * @param ruleCollectionGroupName The name of the FirewallPolicyRuleCollectionGroup.
     * @param parameters Parameters supplied to the create or update FirewallPolicyRuleCollectionGroup
     *                   operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, firewallPolicyName, ruleCollectionGroupName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, firewallPolicyName, ruleCollectionGroupName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Lists all FirewallPolicyRuleCollectionGroups in a FirewallPolicy resource.
     * @param resourceGroupName The name of the resource group.
     * @param firewallPolicyName The name of the Firewall Policy.
     * @param options The options parameters.
     */
    _list(resourceGroupName, firewallPolicyName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, firewallPolicyName, options }, listOperationSpec$r);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param firewallPolicyName The name of the Firewall Policy.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, firewallPolicyName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, firewallPolicyName, nextLink, options }, listNextOperationSpec$r);
    }
}
// Operation Specifications
const serializer$u = coreClient.createSerializer(Mappers, /* isXml */ false);
const deleteOperationSpec$i = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/firewallPolicies/{firewallPolicyName}/ruleCollectionGroups/{ruleCollectionGroupName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        firewallPolicyName,
        ruleCollectionGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$u
};
const getOperationSpec$n = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/firewallPolicies/{firewallPolicyName}/ruleCollectionGroups/{ruleCollectionGroupName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: FirewallPolicyRuleCollectionGroup
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        firewallPolicyName,
        ruleCollectionGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$u
};
const createOrUpdateOperationSpec$i = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/firewallPolicies/{firewallPolicyName}/ruleCollectionGroups/{ruleCollectionGroupName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: FirewallPolicyRuleCollectionGroup
        },
        201: {
            bodyMapper: FirewallPolicyRuleCollectionGroup
        },
        202: {
            bodyMapper: FirewallPolicyRuleCollectionGroup
        },
        204: {
            bodyMapper: FirewallPolicyRuleCollectionGroup
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters16,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        firewallPolicyName,
        ruleCollectionGroupName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$u
};
const listOperationSpec$r = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/firewallPolicies/{firewallPolicyName}/ruleCollectionGroups",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: FirewallPolicyRuleCollectionGroupListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        firewallPolicyName
    ],
    headerParameters: [accept],
    serializer: serializer$u
};
const listNextOperationSpec$r = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: FirewallPolicyRuleCollectionGroupListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        firewallPolicyName
    ],
    headerParameters: [accept],
    serializer: serializer$u
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing FirewallPolicyIdpsSignatures operations. */
class FirewallPolicyIdpsSignaturesImpl {
    /**
     * Initialize a new instance of the class FirewallPolicyIdpsSignatures class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Retrieves the current status of IDPS signatures for the relevant policy
     * @param resourceGroupName The name of the resource group.
     * @param firewallPolicyName The name of the Firewall Policy.
     * @param parameters Will describe the query to run against the IDPS signatures DB
     * @param options The options parameters.
     */
    list(resourceGroupName, firewallPolicyName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, firewallPolicyName, parameters, options }, listOperationSpec$s);
    }
}
// Operation Specifications
const serializer$v = coreClient.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$s = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/firewallPolicies/{firewallPolicyName}/listIdpsSignatures",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: QueryResults
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters17,
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        firewallPolicyName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$v
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing FirewallPolicyIdpsSignaturesOverrides operations. */
class FirewallPolicyIdpsSignaturesOverridesImpl {
    /**
     * Initialize a new instance of the class FirewallPolicyIdpsSignaturesOverrides class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Will update the status of policy's signature overrides for IDPS
     * @param resourceGroupName The name of the resource group.
     * @param firewallPolicyName The name of the Firewall Policy.
     * @param parameters Will contain all properties of the object to put
     * @param options The options parameters.
     */
    patch(resourceGroupName, firewallPolicyName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, firewallPolicyName, parameters, options }, patchOperationSpec);
    }
    /**
     * Will override/create a new signature overrides for the policy's IDPS
     * @param resourceGroupName The name of the resource group.
     * @param firewallPolicyName The name of the Firewall Policy.
     * @param parameters Will contain all properties of the object to put
     * @param options The options parameters.
     */
    put(resourceGroupName, firewallPolicyName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, firewallPolicyName, parameters, options }, putOperationSpec);
    }
    /**
     * Returns all signatures overrides for a specific policy.
     * @param resourceGroupName The name of the resource group.
     * @param firewallPolicyName The name of the Firewall Policy.
     * @param options The options parameters.
     */
    get(resourceGroupName, firewallPolicyName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, firewallPolicyName, options }, getOperationSpec$o);
    }
    /**
     * Returns all signatures overrides objects for a specific policy as a list containing a single value.
     * @param resourceGroupName The name of the resource group.
     * @param firewallPolicyName The name of the Firewall Policy.
     * @param options The options parameters.
     */
    list(resourceGroupName, firewallPolicyName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, firewallPolicyName, options }, listOperationSpec$t);
    }
}
// Operation Specifications
const serializer$w = coreClient.createSerializer(Mappers, /* isXml */ false);
const patchOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/firewallPolicies/{firewallPolicyName}/signatureOverrides/default",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: SignaturesOverrides
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters18,
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        firewallPolicyName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$w
};
const putOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/firewallPolicies/{firewallPolicyName}/signatureOverrides/default",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: SignaturesOverrides
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters18,
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        firewallPolicyName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$w
};
const getOperationSpec$o = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/firewallPolicies/{firewallPolicyName}/signatureOverrides/default",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SignaturesOverrides
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        firewallPolicyName
    ],
    headerParameters: [accept],
    serializer: serializer$w
};
const listOperationSpec$t = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/firewallPolicies/{firewallPolicyName}/signatureOverrides",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SignaturesOverridesList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        firewallPolicyName
    ],
    headerParameters: [accept],
    serializer: serializer$w
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing FirewallPolicyIdpsSignaturesFilterValues operations. */
class FirewallPolicyIdpsSignaturesFilterValuesImpl {
    /**
     * Initialize a new instance of the class FirewallPolicyIdpsSignaturesFilterValues class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Retrieves the current filter values for the signatures overrides
     * @param resourceGroupName The name of the resource group.
     * @param firewallPolicyName The name of the Firewall Policy.
     * @param parameters Describes the filter values possibles for a given column
     * @param options The options parameters.
     */
    list(resourceGroupName, firewallPolicyName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, firewallPolicyName, parameters, options }, listOperationSpec$u);
    }
}
// Operation Specifications
const serializer$x = coreClient.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$u = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/firewallPolicies/{firewallPolicyName}/listIdpsFilterOptions",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: SignatureOverridesFilterValuesResponse
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters19,
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        firewallPolicyName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$x
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing IpAllocations operations. */
class IpAllocationsImpl {
    /**
     * Initialize a new instance of the class IpAllocations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all IpAllocations in a subscription.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(options);
            }
        };
    }
    listPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets all IpAllocations in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByResourceGroupPagingPage(resourceGroupName, options);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Deletes the specified IpAllocation.
     * @param resourceGroupName The name of the resource group.
     * @param ipAllocationName The name of the IpAllocation.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, ipAllocationName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, ipAllocationName, options }, deleteOperationSpec$j);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Deletes the specified IpAllocation.
     * @param resourceGroupName The name of the resource group.
     * @param ipAllocationName The name of the IpAllocation.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, ipAllocationName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, ipAllocationName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the specified IpAllocation by resource group.
     * @param resourceGroupName The name of the resource group.
     * @param ipAllocationName The name of the IpAllocation.
     * @param options The options parameters.
     */
    get(resourceGroupName, ipAllocationName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, ipAllocationName, options }, getOperationSpec$p);
    }
    /**
     * Creates or updates an IpAllocation in the specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param ipAllocationName The name of the IpAllocation.
     * @param parameters Parameters supplied to the create or update virtual network operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, ipAllocationName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, ipAllocationName, parameters, options }, createOrUpdateOperationSpec$j);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
        });
    }
    /**
     * Creates or updates an IpAllocation in the specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param ipAllocationName The name of the IpAllocation.
     * @param parameters Parameters supplied to the create or update virtual network operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, ipAllocationName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, ipAllocationName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates a IpAllocation tags.
     * @param resourceGroupName The name of the resource group.
     * @param ipAllocationName The name of the IpAllocation.
     * @param parameters Parameters supplied to update IpAllocation tags.
     * @param options The options parameters.
     */
    updateTags(resourceGroupName, ipAllocationName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, ipAllocationName, parameters, options }, updateTagsOperationSpec$c);
    }
    /**
     * Gets all IpAllocations in a subscription.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$v);
    }
    /**
     * Gets all IpAllocations in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec$5);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$s);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The name of the resource group.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec$5);
    }
}
// Operation Specifications
const serializer$y = coreClient.createSerializer(Mappers, /* isXml */ false);
const deleteOperationSpec$j = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/IpAllocations/{ipAllocationName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        ipAllocationName
    ],
    headerParameters: [accept],
    serializer: serializer$y
};
const getOperationSpec$p = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/IpAllocations/{ipAllocationName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: IpAllocation
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, expand],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        ipAllocationName
    ],
    headerParameters: [accept],
    serializer: serializer$y
};
const createOrUpdateOperationSpec$j = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/IpAllocations/{ipAllocationName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: IpAllocation
        },
        201: {
            bodyMapper: IpAllocation
        },
        202: {
            bodyMapper: IpAllocation
        },
        204: {
            bodyMapper: IpAllocation
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters20,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        ipAllocationName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$y
};
const updateTagsOperationSpec$c = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/IpAllocations/{ipAllocationName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: IpAllocation
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        ipAllocationName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$y
};
const listOperationSpec$v = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/IpAllocations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: IpAllocationListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$y
};
const listByResourceGroupOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/IpAllocations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: IpAllocationListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$y
};
const listNextOperationSpec$s = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: IpAllocationListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$y
};
const listByResourceGroupNextOperationSpec$5 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: IpAllocationListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$y
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing IpGroups operations. */
class IpGroupsImpl {
    /**
     * Initialize a new instance of the class IpGroups class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all IpGroups in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByResourceGroupPagingPage(resourceGroupName, options);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets all IpGroups in a subscription.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(options);
            }
        };
    }
    listPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Gets the specified ipGroups.
     * @param resourceGroupName The name of the resource group.
     * @param ipGroupsName The name of the ipGroups.
     * @param options The options parameters.
     */
    get(resourceGroupName, ipGroupsName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, ipGroupsName, options }, getOperationSpec$q);
    }
    /**
     * Creates or updates an ipGroups in a specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param ipGroupsName The name of the ipGroups.
     * @param parameters Parameters supplied to the create or update IpGroups operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, ipGroupsName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, ipGroupsName, parameters, options }, createOrUpdateOperationSpec$k);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
        });
    }
    /**
     * Creates or updates an ipGroups in a specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param ipGroupsName The name of the ipGroups.
     * @param parameters Parameters supplied to the create or update IpGroups operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, ipGroupsName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, ipGroupsName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates tags of an IpGroups resource.
     * @param resourceGroupName The name of the resource group.
     * @param ipGroupsName The name of the ipGroups.
     * @param parameters Parameters supplied to the update ipGroups operation.
     * @param options The options parameters.
     */
    updateGroups(resourceGroupName, ipGroupsName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, ipGroupsName, parameters, options }, updateGroupsOperationSpec);
    }
    /**
     * Deletes the specified ipGroups.
     * @param resourceGroupName The name of the resource group.
     * @param ipGroupsName The name of the ipGroups.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, ipGroupsName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, ipGroupsName, options }, deleteOperationSpec$k);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Deletes the specified ipGroups.
     * @param resourceGroupName The name of the resource group.
     * @param ipGroupsName The name of the ipGroups.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, ipGroupsName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, ipGroupsName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets all IpGroups in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec$6);
    }
    /**
     * Gets all IpGroups in a subscription.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$w);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The name of the resource group.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec$6);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$t);
    }
}
// Operation Specifications
const serializer$z = coreClient.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$q = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/ipGroups/{ipGroupsName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: IpGroup
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [apiVersion, expand],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        ipGroupsName
    ],
    headerParameters: [accept],
    serializer: serializer$z
};
const createOrUpdateOperationSpec$k = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/ipGroups/{ipGroupsName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: IpGroup
        },
        201: {
            bodyMapper: IpGroup
        },
        202: {
            bodyMapper: IpGroup
        },
        204: {
            bodyMapper: IpGroup
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    requestBody: parameters21,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        ipGroupsName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$z
};
const updateGroupsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/ipGroups/{ipGroupsName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: IpGroup
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    requestBody: parameters1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        ipGroupsName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$z
};
const deleteOperationSpec$k = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/ipGroups/{ipGroupsName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        ipGroupsName
    ],
    headerParameters: [accept],
    serializer: serializer$z
};
const listByResourceGroupOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/ipGroups",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: IpGroupListResult
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$z
};
const listOperationSpec$w = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/ipGroups",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: IpGroupListResult
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$z
};
const listByResourceGroupNextOperationSpec$6 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: IpGroupListResult
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$z
};
const listNextOperationSpec$t = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: IpGroupListResult
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$z
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing LoadBalancers operations. */
class LoadBalancersImpl {
    /**
     * Initialize a new instance of the class LoadBalancers class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all the load balancers in a subscription.
     * @param options The options parameters.
     */
    listAll(options) {
        const iter = this.listAllPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listAllPagingPage(options);
            }
        };
    }
    listAllPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listAllPagingPage_1() {
            let result = yield tslib.__await(this._listAll(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listAllNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listAllPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listAllPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listAllPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets all the load balancers in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    list(resourceGroupName, options) {
        const iter = this.listPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, options);
            }
        };
    }
    listPagingPage(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Deletes the specified load balancer.
     * @param resourceGroupName The name of the resource group.
     * @param loadBalancerName The name of the load balancer.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, loadBalancerName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, loadBalancerName, options }, deleteOperationSpec$l);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Deletes the specified load balancer.
     * @param resourceGroupName The name of the resource group.
     * @param loadBalancerName The name of the load balancer.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, loadBalancerName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, loadBalancerName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the specified load balancer.
     * @param resourceGroupName The name of the resource group.
     * @param loadBalancerName The name of the load balancer.
     * @param options The options parameters.
     */
    get(resourceGroupName, loadBalancerName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, loadBalancerName, options }, getOperationSpec$r);
    }
    /**
     * Creates or updates a load balancer.
     * @param resourceGroupName The name of the resource group.
     * @param loadBalancerName The name of the load balancer.
     * @param parameters Parameters supplied to the create or update load balancer operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, loadBalancerName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, loadBalancerName, parameters, options }, createOrUpdateOperationSpec$l);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
        });
    }
    /**
     * Creates or updates a load balancer.
     * @param resourceGroupName The name of the resource group.
     * @param loadBalancerName The name of the load balancer.
     * @param parameters Parameters supplied to the create or update load balancer operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, loadBalancerName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, loadBalancerName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates a load balancer tags.
     * @param resourceGroupName The name of the resource group.
     * @param loadBalancerName The name of the load balancer.
     * @param parameters Parameters supplied to update load balancer tags.
     * @param options The options parameters.
     */
    updateTags(resourceGroupName, loadBalancerName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, loadBalancerName, parameters, options }, updateTagsOperationSpec$d);
    }
    /**
     * Gets all the load balancers in a subscription.
     * @param options The options parameters.
     */
    _listAll(options) {
        return this.client.sendOperationRequest({ options }, listAllOperationSpec$a);
    }
    /**
     * Gets all the load balancers in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    _list(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listOperationSpec$x);
    }
    /**
     * Swaps VIPs between two load balancers.
     * @param location The region where load balancers are located at.
     * @param parameters Parameters that define which VIPs should be swapped.
     * @param options The options parameters.
     */
    beginSwapPublicIpAddresses(location, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { location, parameters, options }, swapPublicIpAddressesOperationSpec);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Swaps VIPs between two load balancers.
     * @param location The region where load balancers are located at.
     * @param parameters Parameters that define which VIPs should be swapped.
     * @param options The options parameters.
     */
    beginSwapPublicIpAddressesAndWait(location, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginSwapPublicIpAddresses(location, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * List of inbound NAT rule port mappings.
     * @param groupName The name of the resource group.
     * @param loadBalancerName The name of the load balancer.
     * @param backendPoolName The name of the load balancer backend address pool.
     * @param parameters Query inbound NAT rule port mapping request.
     * @param options The options parameters.
     */
    beginListInboundNatRulePortMappings(groupName, loadBalancerName, backendPoolName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { groupName, loadBalancerName, backendPoolName, parameters, options }, listInboundNatRulePortMappingsOperationSpec);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * List of inbound NAT rule port mappings.
     * @param groupName The name of the resource group.
     * @param loadBalancerName The name of the load balancer.
     * @param backendPoolName The name of the load balancer backend address pool.
     * @param parameters Query inbound NAT rule port mapping request.
     * @param options The options parameters.
     */
    beginListInboundNatRulePortMappingsAndWait(groupName, loadBalancerName, backendPoolName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginListInboundNatRulePortMappings(groupName, loadBalancerName, backendPoolName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListAllNext
     * @param nextLink The nextLink from the previous successful call to the ListAll method.
     * @param options The options parameters.
     */
    _listAllNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listAllNextOperationSpec$a);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listNextOperationSpec$u);
    }
}
// Operation Specifications
const serializer$A = coreClient.createSerializer(Mappers, /* isXml */ false);
const deleteOperationSpec$l = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/loadBalancers/{loadBalancerName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        loadBalancerName
    ],
    headerParameters: [accept],
    serializer: serializer$A
};
const getOperationSpec$r = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/loadBalancers/{loadBalancerName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: LoadBalancer
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, expand],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        loadBalancerName
    ],
    headerParameters: [accept],
    serializer: serializer$A
};
const createOrUpdateOperationSpec$l = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/loadBalancers/{loadBalancerName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: LoadBalancer
        },
        201: {
            bodyMapper: LoadBalancer
        },
        202: {
            bodyMapper: LoadBalancer
        },
        204: {
            bodyMapper: LoadBalancer
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters22,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        loadBalancerName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$A
};
const updateTagsOperationSpec$d = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/loadBalancers/{loadBalancerName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: LoadBalancer
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        loadBalancerName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$A
};
const listAllOperationSpec$a = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/loadBalancers",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: LoadBalancerListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$A
};
const listOperationSpec$x = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/loadBalancers",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: LoadBalancerListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$A
};
const swapPublicIpAddressesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/locations/{location}/setLoadBalancerFrontendPublicIpAddresses",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters23,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        location
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$A
};
const listInboundNatRulePortMappingsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{groupName}/providers/Microsoft.Network/loadBalancers/{loadBalancerName}/backendAddressPools/{backendPoolName}/queryInboundNatRulePortMapping",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: BackendAddressInboundNatRulePortMappings
        },
        201: {
            bodyMapper: BackendAddressInboundNatRulePortMappings
        },
        202: {
            bodyMapper: BackendAddressInboundNatRulePortMappings
        },
        204: {
            bodyMapper: BackendAddressInboundNatRulePortMappings
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters24,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        loadBalancerName,
        groupName,
        backendPoolName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$A
};
const listAllNextOperationSpec$a = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: LoadBalancerListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$A
};
const listNextOperationSpec$u = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: LoadBalancerListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$A
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing LoadBalancerBackendAddressPools operations. */
class LoadBalancerBackendAddressPoolsImpl {
    /**
     * Initialize a new instance of the class LoadBalancerBackendAddressPools class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all the load balancer backed address pools.
     * @param resourceGroupName The name of the resource group.
     * @param loadBalancerName The name of the load balancer.
     * @param options The options parameters.
     */
    list(resourceGroupName, loadBalancerName, options) {
        const iter = this.listPagingAll(resourceGroupName, loadBalancerName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, loadBalancerName, options);
            }
        };
    }
    listPagingPage(resourceGroupName, loadBalancerName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, loadBalancerName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, loadBalancerName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceGroupName, loadBalancerName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, loadBalancerName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets all the load balancer backed address pools.
     * @param resourceGroupName The name of the resource group.
     * @param loadBalancerName The name of the load balancer.
     * @param options The options parameters.
     */
    _list(resourceGroupName, loadBalancerName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, loadBalancerName, options }, listOperationSpec$y);
    }
    /**
     * Gets load balancer backend address pool.
     * @param resourceGroupName The name of the resource group.
     * @param loadBalancerName The name of the load balancer.
     * @param backendAddressPoolName The name of the backend address pool.
     * @param options The options parameters.
     */
    get(resourceGroupName, loadBalancerName, backendAddressPoolName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, loadBalancerName, backendAddressPoolName, options }, getOperationSpec$s);
    }
    /**
     * Creates or updates a load balancer backend address pool.
     * @param resourceGroupName The name of the resource group.
     * @param loadBalancerName The name of the load balancer.
     * @param backendAddressPoolName The name of the backend address pool.
     * @param parameters Parameters supplied to the create or update load balancer backend address pool
     *                   operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, loadBalancerName, backendAddressPoolName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                loadBalancerName,
                backendAddressPoolName,
                parameters,
                options
            }, createOrUpdateOperationSpec$m);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
        });
    }
    /**
     * Creates or updates a load balancer backend address pool.
     * @param resourceGroupName The name of the resource group.
     * @param loadBalancerName The name of the load balancer.
     * @param backendAddressPoolName The name of the backend address pool.
     * @param parameters Parameters supplied to the create or update load balancer backend address pool
     *                   operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, loadBalancerName, backendAddressPoolName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, loadBalancerName, backendAddressPoolName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes the specified load balancer backend address pool.
     * @param resourceGroupName The name of the resource group.
     * @param loadBalancerName The name of the load balancer.
     * @param backendAddressPoolName The name of the backend address pool.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, loadBalancerName, backendAddressPoolName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, loadBalancerName, backendAddressPoolName, options }, deleteOperationSpec$m);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Deletes the specified load balancer backend address pool.
     * @param resourceGroupName The name of the resource group.
     * @param loadBalancerName The name of the load balancer.
     * @param backendAddressPoolName The name of the backend address pool.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, loadBalancerName, backendAddressPoolName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, loadBalancerName, backendAddressPoolName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param loadBalancerName The name of the load balancer.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, loadBalancerName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, loadBalancerName, nextLink, options }, listNextOperationSpec$v);
    }
}
// Operation Specifications
const serializer$B = coreClient.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$y = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/loadBalancers/{loadBalancerName}/backendAddressPools",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: LoadBalancerBackendAddressPoolListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        loadBalancerName
    ],
    headerParameters: [accept],
    serializer: serializer$B
};
const getOperationSpec$s = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/loadBalancers/{loadBalancerName}/backendAddressPools/{backendAddressPoolName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: BackendAddressPool
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        loadBalancerName,
        backendAddressPoolName
    ],
    headerParameters: [accept],
    serializer: serializer$B
};
const createOrUpdateOperationSpec$m = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/loadBalancers/{loadBalancerName}/backendAddressPools/{backendAddressPoolName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: BackendAddressPool
        },
        201: {
            bodyMapper: BackendAddressPool
        },
        202: {
            bodyMapper: BackendAddressPool
        },
        204: {
            bodyMapper: BackendAddressPool
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters25,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        loadBalancerName,
        backendAddressPoolName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$B
};
const deleteOperationSpec$m = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/loadBalancers/{loadBalancerName}/backendAddressPools/{backendAddressPoolName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        loadBalancerName,
        backendAddressPoolName
    ],
    headerParameters: [accept],
    serializer: serializer$B
};
const listNextOperationSpec$v = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: LoadBalancerBackendAddressPoolListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        loadBalancerName
    ],
    headerParameters: [accept],
    serializer: serializer$B
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing LoadBalancerFrontendIPConfigurations operations. */
class LoadBalancerFrontendIPConfigurationsImpl {
    /**
     * Initialize a new instance of the class LoadBalancerFrontendIPConfigurations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all the load balancer frontend IP configurations.
     * @param resourceGroupName The name of the resource group.
     * @param loadBalancerName The name of the load balancer.
     * @param options The options parameters.
     */
    list(resourceGroupName, loadBalancerName, options) {
        const iter = this.listPagingAll(resourceGroupName, loadBalancerName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, loadBalancerName, options);
            }
        };
    }
    listPagingPage(resourceGroupName, loadBalancerName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, loadBalancerName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, loadBalancerName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceGroupName, loadBalancerName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, loadBalancerName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets all the load balancer frontend IP configurations.
     * @param resourceGroupName The name of the resource group.
     * @param loadBalancerName The name of the load balancer.
     * @param options The options parameters.
     */
    _list(resourceGroupName, loadBalancerName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, loadBalancerName, options }, listOperationSpec$z);
    }
    /**
     * Gets load balancer frontend IP configuration.
     * @param resourceGroupName The name of the resource group.
     * @param loadBalancerName The name of the load balancer.
     * @param frontendIPConfigurationName The name of the frontend IP configuration.
     * @param options The options parameters.
     */
    get(resourceGroupName, loadBalancerName, frontendIPConfigurationName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            loadBalancerName,
            frontendIPConfigurationName,
            options
        }, getOperationSpec$t);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param loadBalancerName The name of the load balancer.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, loadBalancerName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, loadBalancerName, nextLink, options }, listNextOperationSpec$w);
    }
}
// Operation Specifications
const serializer$C = coreClient.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$z = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/loadBalancers/{loadBalancerName}/frontendIPConfigurations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: LoadBalancerFrontendIPConfigurationListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        loadBalancerName
    ],
    headerParameters: [accept],
    serializer: serializer$C
};
const getOperationSpec$t = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/loadBalancers/{loadBalancerName}/frontendIPConfigurations/{frontendIPConfigurationName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: FrontendIPConfiguration
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        loadBalancerName,
        frontendIPConfigurationName
    ],
    headerParameters: [accept],
    serializer: serializer$C
};
const listNextOperationSpec$w = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: LoadBalancerFrontendIPConfigurationListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        loadBalancerName
    ],
    headerParameters: [accept],
    serializer: serializer$C
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing InboundNatRules operations. */
class InboundNatRulesImpl {
    /**
     * Initialize a new instance of the class InboundNatRules class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all the inbound NAT rules in a load balancer.
     * @param resourceGroupName The name of the resource group.
     * @param loadBalancerName The name of the load balancer.
     * @param options The options parameters.
     */
    list(resourceGroupName, loadBalancerName, options) {
        const iter = this.listPagingAll(resourceGroupName, loadBalancerName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, loadBalancerName, options);
            }
        };
    }
    listPagingPage(resourceGroupName, loadBalancerName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, loadBalancerName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, loadBalancerName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceGroupName, loadBalancerName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, loadBalancerName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets all the inbound NAT rules in a load balancer.
     * @param resourceGroupName The name of the resource group.
     * @param loadBalancerName The name of the load balancer.
     * @param options The options parameters.
     */
    _list(resourceGroupName, loadBalancerName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, loadBalancerName, options }, listOperationSpec$A);
    }
    /**
     * Deletes the specified load balancer inbound NAT rule.
     * @param resourceGroupName The name of the resource group.
     * @param loadBalancerName The name of the load balancer.
     * @param inboundNatRuleName The name of the inbound NAT rule.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, loadBalancerName, inboundNatRuleName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, loadBalancerName, inboundNatRuleName, options }, deleteOperationSpec$n);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Deletes the specified load balancer inbound NAT rule.
     * @param resourceGroupName The name of the resource group.
     * @param loadBalancerName The name of the load balancer.
     * @param inboundNatRuleName The name of the inbound NAT rule.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, loadBalancerName, inboundNatRuleName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, loadBalancerName, inboundNatRuleName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the specified load balancer inbound NAT rule.
     * @param resourceGroupName The name of the resource group.
     * @param loadBalancerName The name of the load balancer.
     * @param inboundNatRuleName The name of the inbound NAT rule.
     * @param options The options parameters.
     */
    get(resourceGroupName, loadBalancerName, inboundNatRuleName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, loadBalancerName, inboundNatRuleName, options }, getOperationSpec$u);
    }
    /**
     * Creates or updates a load balancer inbound NAT rule.
     * @param resourceGroupName The name of the resource group.
     * @param loadBalancerName The name of the load balancer.
     * @param inboundNatRuleName The name of the inbound NAT rule.
     * @param inboundNatRuleParameters Parameters supplied to the create or update inbound NAT rule
     *                                 operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, loadBalancerName, inboundNatRuleName, inboundNatRuleParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                loadBalancerName,
                inboundNatRuleName,
                inboundNatRuleParameters,
                options
            }, createOrUpdateOperationSpec$n);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
        });
    }
    /**
     * Creates or updates a load balancer inbound NAT rule.
     * @param resourceGroupName The name of the resource group.
     * @param loadBalancerName The name of the load balancer.
     * @param inboundNatRuleName The name of the inbound NAT rule.
     * @param inboundNatRuleParameters Parameters supplied to the create or update inbound NAT rule
     *                                 operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, loadBalancerName, inboundNatRuleName, inboundNatRuleParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, loadBalancerName, inboundNatRuleName, inboundNatRuleParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param loadBalancerName The name of the load balancer.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, loadBalancerName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, loadBalancerName, nextLink, options }, listNextOperationSpec$x);
    }
}
// Operation Specifications
const serializer$D = coreClient.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$A = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/loadBalancers/{loadBalancerName}/inboundNatRules",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: InboundNatRuleListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        loadBalancerName
    ],
    headerParameters: [accept],
    serializer: serializer$D
};
const deleteOperationSpec$n = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/loadBalancers/{loadBalancerName}/inboundNatRules/{inboundNatRuleName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        loadBalancerName,
        inboundNatRuleName
    ],
    headerParameters: [accept],
    serializer: serializer$D
};
const getOperationSpec$u = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/loadBalancers/{loadBalancerName}/inboundNatRules/{inboundNatRuleName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: InboundNatRule
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, expand],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        loadBalancerName,
        inboundNatRuleName
    ],
    headerParameters: [accept],
    serializer: serializer$D
};
const createOrUpdateOperationSpec$n = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/loadBalancers/{loadBalancerName}/inboundNatRules/{inboundNatRuleName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: InboundNatRule
        },
        201: {
            bodyMapper: InboundNatRule
        },
        202: {
            bodyMapper: InboundNatRule
        },
        204: {
            bodyMapper: InboundNatRule
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: inboundNatRuleParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        loadBalancerName,
        inboundNatRuleName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$D
};
const listNextOperationSpec$x = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: InboundNatRuleListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        loadBalancerName
    ],
    headerParameters: [accept],
    serializer: serializer$D
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing LoadBalancerLoadBalancingRules operations. */
class LoadBalancerLoadBalancingRulesImpl {
    /**
     * Initialize a new instance of the class LoadBalancerLoadBalancingRules class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all the load balancing rules in a load balancer.
     * @param resourceGroupName The name of the resource group.
     * @param loadBalancerName The name of the load balancer.
     * @param options The options parameters.
     */
    list(resourceGroupName, loadBalancerName, options) {
        const iter = this.listPagingAll(resourceGroupName, loadBalancerName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, loadBalancerName, options);
            }
        };
    }
    listPagingPage(resourceGroupName, loadBalancerName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, loadBalancerName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, loadBalancerName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceGroupName, loadBalancerName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, loadBalancerName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets all the load balancing rules in a load balancer.
     * @param resourceGroupName The name of the resource group.
     * @param loadBalancerName The name of the load balancer.
     * @param options The options parameters.
     */
    _list(resourceGroupName, loadBalancerName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, loadBalancerName, options }, listOperationSpec$B);
    }
    /**
     * Gets the specified load balancer load balancing rule.
     * @param resourceGroupName The name of the resource group.
     * @param loadBalancerName The name of the load balancer.
     * @param loadBalancingRuleName The name of the load balancing rule.
     * @param options The options parameters.
     */
    get(resourceGroupName, loadBalancerName, loadBalancingRuleName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, loadBalancerName, loadBalancingRuleName, options }, getOperationSpec$v);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param loadBalancerName The name of the load balancer.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, loadBalancerName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, loadBalancerName, nextLink, options }, listNextOperationSpec$y);
    }
}
// Operation Specifications
const serializer$E = coreClient.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$B = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/loadBalancers/{loadBalancerName}/loadBalancingRules",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: LoadBalancerLoadBalancingRuleListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        loadBalancerName
    ],
    headerParameters: [accept],
    serializer: serializer$E
};
const getOperationSpec$v = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/loadBalancers/{loadBalancerName}/loadBalancingRules/{loadBalancingRuleName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: LoadBalancingRule
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        loadBalancerName,
        loadBalancingRuleName
    ],
    headerParameters: [accept],
    serializer: serializer$E
};
const listNextOperationSpec$y = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: LoadBalancerLoadBalancingRuleListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        loadBalancerName
    ],
    headerParameters: [accept],
    serializer: serializer$E
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing LoadBalancerOutboundRules operations. */
class LoadBalancerOutboundRulesImpl {
    /**
     * Initialize a new instance of the class LoadBalancerOutboundRules class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all the outbound rules in a load balancer.
     * @param resourceGroupName The name of the resource group.
     * @param loadBalancerName The name of the load balancer.
     * @param options The options parameters.
     */
    list(resourceGroupName, loadBalancerName, options) {
        const iter = this.listPagingAll(resourceGroupName, loadBalancerName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, loadBalancerName, options);
            }
        };
    }
    listPagingPage(resourceGroupName, loadBalancerName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, loadBalancerName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, loadBalancerName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceGroupName, loadBalancerName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, loadBalancerName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets all the outbound rules in a load balancer.
     * @param resourceGroupName The name of the resource group.
     * @param loadBalancerName The name of the load balancer.
     * @param options The options parameters.
     */
    _list(resourceGroupName, loadBalancerName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, loadBalancerName, options }, listOperationSpec$C);
    }
    /**
     * Gets the specified load balancer outbound rule.
     * @param resourceGroupName The name of the resource group.
     * @param loadBalancerName The name of the load balancer.
     * @param outboundRuleName The name of the outbound rule.
     * @param options The options parameters.
     */
    get(resourceGroupName, loadBalancerName, outboundRuleName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, loadBalancerName, outboundRuleName, options }, getOperationSpec$w);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param loadBalancerName The name of the load balancer.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, loadBalancerName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, loadBalancerName, nextLink, options }, listNextOperationSpec$z);
    }
}
// Operation Specifications
const serializer$F = coreClient.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$C = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/loadBalancers/{loadBalancerName}/outboundRules",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: LoadBalancerOutboundRuleListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        loadBalancerName
    ],
    headerParameters: [accept],
    serializer: serializer$F
};
const getOperationSpec$w = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/loadBalancers/{loadBalancerName}/outboundRules/{outboundRuleName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: OutboundRule
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        loadBalancerName,
        outboundRuleName
    ],
    headerParameters: [accept],
    serializer: serializer$F
};
const listNextOperationSpec$z = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: LoadBalancerOutboundRuleListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        loadBalancerName
    ],
    headerParameters: [accept],
    serializer: serializer$F
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing LoadBalancerNetworkInterfaces operations. */
class LoadBalancerNetworkInterfacesImpl {
    /**
     * Initialize a new instance of the class LoadBalancerNetworkInterfaces class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets associated load balancer network interfaces.
     * @param resourceGroupName The name of the resource group.
     * @param loadBalancerName The name of the load balancer.
     * @param options The options parameters.
     */
    list(resourceGroupName, loadBalancerName, options) {
        const iter = this.listPagingAll(resourceGroupName, loadBalancerName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, loadBalancerName, options);
            }
        };
    }
    listPagingPage(resourceGroupName, loadBalancerName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, loadBalancerName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, loadBalancerName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceGroupName, loadBalancerName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, loadBalancerName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets associated load balancer network interfaces.
     * @param resourceGroupName The name of the resource group.
     * @param loadBalancerName The name of the load balancer.
     * @param options The options parameters.
     */
    _list(resourceGroupName, loadBalancerName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, loadBalancerName, options }, listOperationSpec$D);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param loadBalancerName The name of the load balancer.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, loadBalancerName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, loadBalancerName, nextLink, options }, listNextOperationSpec$A);
    }
}
// Operation Specifications
const serializer$G = coreClient.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$D = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/loadBalancers/{loadBalancerName}/networkInterfaces",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkInterfaceListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        loadBalancerName
    ],
    headerParameters: [accept],
    serializer: serializer$G
};
const listNextOperationSpec$A = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkInterfaceListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        loadBalancerName
    ],
    headerParameters: [accept],
    serializer: serializer$G
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing LoadBalancerProbes operations. */
class LoadBalancerProbesImpl {
    /**
     * Initialize a new instance of the class LoadBalancerProbes class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all the load balancer probes.
     * @param resourceGroupName The name of the resource group.
     * @param loadBalancerName The name of the load balancer.
     * @param options The options parameters.
     */
    list(resourceGroupName, loadBalancerName, options) {
        const iter = this.listPagingAll(resourceGroupName, loadBalancerName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, loadBalancerName, options);
            }
        };
    }
    listPagingPage(resourceGroupName, loadBalancerName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, loadBalancerName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, loadBalancerName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceGroupName, loadBalancerName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, loadBalancerName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets all the load balancer probes.
     * @param resourceGroupName The name of the resource group.
     * @param loadBalancerName The name of the load balancer.
     * @param options The options parameters.
     */
    _list(resourceGroupName, loadBalancerName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, loadBalancerName, options }, listOperationSpec$E);
    }
    /**
     * Gets load balancer probe.
     * @param resourceGroupName The name of the resource group.
     * @param loadBalancerName The name of the load balancer.
     * @param probeName The name of the probe.
     * @param options The options parameters.
     */
    get(resourceGroupName, loadBalancerName, probeName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, loadBalancerName, probeName, options }, getOperationSpec$x);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param loadBalancerName The name of the load balancer.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, loadBalancerName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, loadBalancerName, nextLink, options }, listNextOperationSpec$B);
    }
}
// Operation Specifications
const serializer$H = coreClient.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$E = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/loadBalancers/{loadBalancerName}/probes",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: LoadBalancerProbeListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        loadBalancerName
    ],
    headerParameters: [accept],
    serializer: serializer$H
};
const getOperationSpec$x = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/loadBalancers/{loadBalancerName}/probes/{probeName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Probe
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        loadBalancerName,
        probeName
    ],
    headerParameters: [accept],
    serializer: serializer$H
};
const listNextOperationSpec$B = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: LoadBalancerProbeListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        loadBalancerName
    ],
    headerParameters: [accept],
    serializer: serializer$H
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing NatGateways operations. */
class NatGatewaysImpl {
    /**
     * Initialize a new instance of the class NatGateways class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all the Nat Gateways in a subscription.
     * @param options The options parameters.
     */
    listAll(options) {
        const iter = this.listAllPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listAllPagingPage(options);
            }
        };
    }
    listAllPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listAllPagingPage_1() {
            let result = yield tslib.__await(this._listAll(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listAllNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listAllPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listAllPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listAllPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets all nat gateways in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    list(resourceGroupName, options) {
        const iter = this.listPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, options);
            }
        };
    }
    listPagingPage(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Deletes the specified nat gateway.
     * @param resourceGroupName The name of the resource group.
     * @param natGatewayName The name of the nat gateway.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, natGatewayName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, natGatewayName, options }, deleteOperationSpec$o);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Deletes the specified nat gateway.
     * @param resourceGroupName The name of the resource group.
     * @param natGatewayName The name of the nat gateway.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, natGatewayName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, natGatewayName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the specified nat gateway in a specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param natGatewayName The name of the nat gateway.
     * @param options The options parameters.
     */
    get(resourceGroupName, natGatewayName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, natGatewayName, options }, getOperationSpec$y);
    }
    /**
     * Creates or updates a nat gateway.
     * @param resourceGroupName The name of the resource group.
     * @param natGatewayName The name of the nat gateway.
     * @param parameters Parameters supplied to the create or update nat gateway operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, natGatewayName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, natGatewayName, parameters, options }, createOrUpdateOperationSpec$o);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
        });
    }
    /**
     * Creates or updates a nat gateway.
     * @param resourceGroupName The name of the resource group.
     * @param natGatewayName The name of the nat gateway.
     * @param parameters Parameters supplied to the create or update nat gateway operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, natGatewayName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, natGatewayName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates nat gateway tags.
     * @param resourceGroupName The name of the resource group.
     * @param natGatewayName The name of the nat gateway.
     * @param parameters Parameters supplied to update nat gateway tags.
     * @param options The options parameters.
     */
    updateTags(resourceGroupName, natGatewayName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, natGatewayName, parameters, options }, updateTagsOperationSpec$e);
    }
    /**
     * Gets all the Nat Gateways in a subscription.
     * @param options The options parameters.
     */
    _listAll(options) {
        return this.client.sendOperationRequest({ options }, listAllOperationSpec$b);
    }
    /**
     * Gets all nat gateways in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    _list(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listOperationSpec$F);
    }
    /**
     * ListAllNext
     * @param nextLink The nextLink from the previous successful call to the ListAll method.
     * @param options The options parameters.
     */
    _listAllNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listAllNextOperationSpec$b);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listNextOperationSpec$C);
    }
}
// Operation Specifications
const serializer$I = coreClient.createSerializer(Mappers, /* isXml */ false);
const deleteOperationSpec$o = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/natGateways/{natGatewayName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        natGatewayName
    ],
    headerParameters: [accept],
    serializer: serializer$I
};
const getOperationSpec$y = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/natGateways/{natGatewayName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NatGateway
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, expand],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        natGatewayName
    ],
    headerParameters: [accept],
    serializer: serializer$I
};
const createOrUpdateOperationSpec$o = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/natGateways/{natGatewayName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: NatGateway
        },
        201: {
            bodyMapper: NatGateway
        },
        202: {
            bodyMapper: NatGateway
        },
        204: {
            bodyMapper: NatGateway
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters26,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        natGatewayName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$I
};
const updateTagsOperationSpec$e = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/natGateways/{natGatewayName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: NatGateway
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        natGatewayName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$I
};
const listAllOperationSpec$b = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/natGateways",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NatGatewayListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$I
};
const listOperationSpec$F = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/natGateways",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NatGatewayListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$I
};
const listAllNextOperationSpec$b = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NatGatewayListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$I
};
const listNextOperationSpec$C = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NatGatewayListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$I
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing NetworkInterfaceIPConfigurations operations. */
class NetworkInterfaceIPConfigurationsImpl {
    /**
     * Initialize a new instance of the class NetworkInterfaceIPConfigurations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Get all ip configurations in a network interface.
     * @param resourceGroupName The name of the resource group.
     * @param networkInterfaceName The name of the network interface.
     * @param options The options parameters.
     */
    list(resourceGroupName, networkInterfaceName, options) {
        const iter = this.listPagingAll(resourceGroupName, networkInterfaceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, networkInterfaceName, options);
            }
        };
    }
    listPagingPage(resourceGroupName, networkInterfaceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, networkInterfaceName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, networkInterfaceName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceGroupName, networkInterfaceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, networkInterfaceName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Get all ip configurations in a network interface.
     * @param resourceGroupName The name of the resource group.
     * @param networkInterfaceName The name of the network interface.
     * @param options The options parameters.
     */
    _list(resourceGroupName, networkInterfaceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, networkInterfaceName, options }, listOperationSpec$G);
    }
    /**
     * Gets the specified network interface ip configuration.
     * @param resourceGroupName The name of the resource group.
     * @param networkInterfaceName The name of the network interface.
     * @param ipConfigurationName The name of the ip configuration name.
     * @param options The options parameters.
     */
    get(resourceGroupName, networkInterfaceName, ipConfigurationName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, networkInterfaceName, ipConfigurationName, options }, getOperationSpec$z);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param networkInterfaceName The name of the network interface.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, networkInterfaceName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, networkInterfaceName, nextLink, options }, listNextOperationSpec$D);
    }
}
// Operation Specifications
const serializer$J = coreClient.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$G = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkInterfaces/{networkInterfaceName}/ipConfigurations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkInterfaceIPConfigurationListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkInterfaceName
    ],
    headerParameters: [accept],
    serializer: serializer$J
};
const getOperationSpec$z = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkInterfaces/{networkInterfaceName}/ipConfigurations/{ipConfigurationName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkInterfaceIPConfiguration
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkInterfaceName,
        ipConfigurationName
    ],
    headerParameters: [accept],
    serializer: serializer$J
};
const listNextOperationSpec$D = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkInterfaceIPConfigurationListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        networkInterfaceName
    ],
    headerParameters: [accept],
    serializer: serializer$J
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing NetworkInterfaceLoadBalancers operations. */
class NetworkInterfaceLoadBalancersImpl {
    /**
     * Initialize a new instance of the class NetworkInterfaceLoadBalancers class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List all load balancers in a network interface.
     * @param resourceGroupName The name of the resource group.
     * @param networkInterfaceName The name of the network interface.
     * @param options The options parameters.
     */
    list(resourceGroupName, networkInterfaceName, options) {
        const iter = this.listPagingAll(resourceGroupName, networkInterfaceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, networkInterfaceName, options);
            }
        };
    }
    listPagingPage(resourceGroupName, networkInterfaceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, networkInterfaceName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, networkInterfaceName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceGroupName, networkInterfaceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, networkInterfaceName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List all load balancers in a network interface.
     * @param resourceGroupName The name of the resource group.
     * @param networkInterfaceName The name of the network interface.
     * @param options The options parameters.
     */
    _list(resourceGroupName, networkInterfaceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, networkInterfaceName, options }, listOperationSpec$H);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param networkInterfaceName The name of the network interface.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, networkInterfaceName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, networkInterfaceName, nextLink, options }, listNextOperationSpec$E);
    }
}
// Operation Specifications
const serializer$K = coreClient.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$H = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkInterfaces/{networkInterfaceName}/loadBalancers",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkInterfaceLoadBalancerListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkInterfaceName
    ],
    headerParameters: [accept],
    serializer: serializer$K
};
const listNextOperationSpec$E = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkInterfaceLoadBalancerListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        networkInterfaceName
    ],
    headerParameters: [accept],
    serializer: serializer$K
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing NetworkInterfaceTapConfigurations operations. */
class NetworkInterfaceTapConfigurationsImpl {
    /**
     * Initialize a new instance of the class NetworkInterfaceTapConfigurations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Get all Tap configurations in a network interface.
     * @param resourceGroupName The name of the resource group.
     * @param networkInterfaceName The name of the network interface.
     * @param options The options parameters.
     */
    list(resourceGroupName, networkInterfaceName, options) {
        const iter = this.listPagingAll(resourceGroupName, networkInterfaceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, networkInterfaceName, options);
            }
        };
    }
    listPagingPage(resourceGroupName, networkInterfaceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, networkInterfaceName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, networkInterfaceName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceGroupName, networkInterfaceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, networkInterfaceName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Deletes the specified tap configuration from the NetworkInterface.
     * @param resourceGroupName The name of the resource group.
     * @param networkInterfaceName The name of the network interface.
     * @param tapConfigurationName The name of the tap configuration.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, networkInterfaceName, tapConfigurationName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                networkInterfaceName,
                tapConfigurationName,
                options
            }, deleteOperationSpec$p);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Deletes the specified tap configuration from the NetworkInterface.
     * @param resourceGroupName The name of the resource group.
     * @param networkInterfaceName The name of the network interface.
     * @param tapConfigurationName The name of the tap configuration.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, networkInterfaceName, tapConfigurationName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, networkInterfaceName, tapConfigurationName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Get the specified tap configuration on a network interface.
     * @param resourceGroupName The name of the resource group.
     * @param networkInterfaceName The name of the network interface.
     * @param tapConfigurationName The name of the tap configuration.
     * @param options The options parameters.
     */
    get(resourceGroupName, networkInterfaceName, tapConfigurationName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            networkInterfaceName,
            tapConfigurationName,
            options
        }, getOperationSpec$A);
    }
    /**
     * Creates or updates a Tap configuration in the specified NetworkInterface.
     * @param resourceGroupName The name of the resource group.
     * @param networkInterfaceName The name of the network interface.
     * @param tapConfigurationName The name of the tap configuration.
     * @param tapConfigurationParameters Parameters supplied to the create or update tap configuration
     *                                   operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, networkInterfaceName, tapConfigurationName, tapConfigurationParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                networkInterfaceName,
                tapConfigurationName,
                tapConfigurationParameters,
                options
            }, createOrUpdateOperationSpec$p);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
        });
    }
    /**
     * Creates or updates a Tap configuration in the specified NetworkInterface.
     * @param resourceGroupName The name of the resource group.
     * @param networkInterfaceName The name of the network interface.
     * @param tapConfigurationName The name of the tap configuration.
     * @param tapConfigurationParameters Parameters supplied to the create or update tap configuration
     *                                   operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, networkInterfaceName, tapConfigurationName, tapConfigurationParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, networkInterfaceName, tapConfigurationName, tapConfigurationParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Get all Tap configurations in a network interface.
     * @param resourceGroupName The name of the resource group.
     * @param networkInterfaceName The name of the network interface.
     * @param options The options parameters.
     */
    _list(resourceGroupName, networkInterfaceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, networkInterfaceName, options }, listOperationSpec$I);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param networkInterfaceName The name of the network interface.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, networkInterfaceName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, networkInterfaceName, nextLink, options }, listNextOperationSpec$F);
    }
}
// Operation Specifications
const serializer$L = coreClient.createSerializer(Mappers, /* isXml */ false);
const deleteOperationSpec$p = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkInterfaces/{networkInterfaceName}/tapConfigurations/{tapConfigurationName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkInterfaceName,
        tapConfigurationName
    ],
    headerParameters: [accept],
    serializer: serializer$L
};
const getOperationSpec$A = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkInterfaces/{networkInterfaceName}/tapConfigurations/{tapConfigurationName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkInterfaceTapConfiguration
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkInterfaceName,
        tapConfigurationName
    ],
    headerParameters: [accept],
    serializer: serializer$L
};
const createOrUpdateOperationSpec$p = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkInterfaces/{networkInterfaceName}/tapConfigurations/{tapConfigurationName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: NetworkInterfaceTapConfiguration
        },
        201: {
            bodyMapper: NetworkInterfaceTapConfiguration
        },
        202: {
            bodyMapper: NetworkInterfaceTapConfiguration
        },
        204: {
            bodyMapper: NetworkInterfaceTapConfiguration
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: tapConfigurationParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkInterfaceName,
        tapConfigurationName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$L
};
const listOperationSpec$I = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkInterfaces/{networkInterfaceName}/tapConfigurations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkInterfaceTapConfigurationListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkInterfaceName
    ],
    headerParameters: [accept],
    serializer: serializer$L
};
const listNextOperationSpec$F = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkInterfaceTapConfigurationListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        networkInterfaceName
    ],
    headerParameters: [accept],
    serializer: serializer$L
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing NetworkProfiles operations. */
class NetworkProfilesImpl {
    /**
     * Initialize a new instance of the class NetworkProfiles class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all the network profiles in a subscription.
     * @param options The options parameters.
     */
    listAll(options) {
        const iter = this.listAllPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listAllPagingPage(options);
            }
        };
    }
    listAllPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listAllPagingPage_1() {
            let result = yield tslib.__await(this._listAll(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listAllNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listAllPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listAllPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listAllPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets all network profiles in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    list(resourceGroupName, options) {
        const iter = this.listPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, options);
            }
        };
    }
    listPagingPage(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Deletes the specified network profile.
     * @param resourceGroupName The name of the resource group.
     * @param networkProfileName The name of the NetworkProfile.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, networkProfileName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, networkProfileName, options }, deleteOperationSpec$q);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Deletes the specified network profile.
     * @param resourceGroupName The name of the resource group.
     * @param networkProfileName The name of the NetworkProfile.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, networkProfileName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, networkProfileName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the specified network profile in a specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param networkProfileName The name of the public IP prefix.
     * @param options The options parameters.
     */
    get(resourceGroupName, networkProfileName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, networkProfileName, options }, getOperationSpec$B);
    }
    /**
     * Creates or updates a network profile.
     * @param resourceGroupName The name of the resource group.
     * @param networkProfileName The name of the network profile.
     * @param parameters Parameters supplied to the create or update network profile operation.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, networkProfileName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, networkProfileName, parameters, options }, createOrUpdateOperationSpec$q);
    }
    /**
     * Updates network profile tags.
     * @param resourceGroupName The name of the resource group.
     * @param networkProfileName The name of the network profile.
     * @param parameters Parameters supplied to update network profile tags.
     * @param options The options parameters.
     */
    updateTags(resourceGroupName, networkProfileName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, networkProfileName, parameters, options }, updateTagsOperationSpec$f);
    }
    /**
     * Gets all the network profiles in a subscription.
     * @param options The options parameters.
     */
    _listAll(options) {
        return this.client.sendOperationRequest({ options }, listAllOperationSpec$c);
    }
    /**
     * Gets all network profiles in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    _list(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listOperationSpec$J);
    }
    /**
     * ListAllNext
     * @param nextLink The nextLink from the previous successful call to the ListAll method.
     * @param options The options parameters.
     */
    _listAllNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listAllNextOperationSpec$c);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listNextOperationSpec$G);
    }
}
// Operation Specifications
const serializer$M = coreClient.createSerializer(Mappers, /* isXml */ false);
const deleteOperationSpec$q = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkProfiles/{networkProfileName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkProfileName
    ],
    headerParameters: [accept],
    serializer: serializer$M
};
const getOperationSpec$B = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkProfiles/{networkProfileName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkProfile
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, expand],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkProfileName
    ],
    headerParameters: [accept],
    serializer: serializer$M
};
const createOrUpdateOperationSpec$q = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkProfiles/{networkProfileName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: NetworkProfile
        },
        201: {
            bodyMapper: NetworkProfile
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters27,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkProfileName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$M
};
const updateTagsOperationSpec$f = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkProfiles/{networkProfileName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: NetworkProfile
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkProfileName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$M
};
const listAllOperationSpec$c = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/networkProfiles",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkProfileListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$M
};
const listOperationSpec$J = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkProfiles",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkProfileListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$M
};
const listAllNextOperationSpec$c = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkProfileListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$M
};
const listNextOperationSpec$G = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkProfileListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$M
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing NetworkSecurityGroups operations. */
class NetworkSecurityGroupsImpl {
    /**
     * Initialize a new instance of the class NetworkSecurityGroups class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all network security groups in a subscription.
     * @param options The options parameters.
     */
    listAll(options) {
        const iter = this.listAllPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listAllPagingPage(options);
            }
        };
    }
    listAllPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listAllPagingPage_1() {
            let result = yield tslib.__await(this._listAll(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listAllNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listAllPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listAllPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listAllPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets all network security groups in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    list(resourceGroupName, options) {
        const iter = this.listPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, options);
            }
        };
    }
    listPagingPage(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Deletes the specified network security group.
     * @param resourceGroupName The name of the resource group.
     * @param networkSecurityGroupName The name of the network security group.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, networkSecurityGroupName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, networkSecurityGroupName, options }, deleteOperationSpec$r);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Deletes the specified network security group.
     * @param resourceGroupName The name of the resource group.
     * @param networkSecurityGroupName The name of the network security group.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, networkSecurityGroupName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, networkSecurityGroupName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the specified network security group.
     * @param resourceGroupName The name of the resource group.
     * @param networkSecurityGroupName The name of the network security group.
     * @param options The options parameters.
     */
    get(resourceGroupName, networkSecurityGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, networkSecurityGroupName, options }, getOperationSpec$C);
    }
    /**
     * Creates or updates a network security group in the specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param networkSecurityGroupName The name of the network security group.
     * @param parameters Parameters supplied to the create or update network security group operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, networkSecurityGroupName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, networkSecurityGroupName, parameters, options }, createOrUpdateOperationSpec$r);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
        });
    }
    /**
     * Creates or updates a network security group in the specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param networkSecurityGroupName The name of the network security group.
     * @param parameters Parameters supplied to the create or update network security group operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, networkSecurityGroupName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, networkSecurityGroupName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates a network security group tags.
     * @param resourceGroupName The name of the resource group.
     * @param networkSecurityGroupName The name of the network security group.
     * @param parameters Parameters supplied to update network security group tags.
     * @param options The options parameters.
     */
    updateTags(resourceGroupName, networkSecurityGroupName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, networkSecurityGroupName, parameters, options }, updateTagsOperationSpec$g);
    }
    /**
     * Gets all network security groups in a subscription.
     * @param options The options parameters.
     */
    _listAll(options) {
        return this.client.sendOperationRequest({ options }, listAllOperationSpec$d);
    }
    /**
     * Gets all network security groups in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    _list(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listOperationSpec$K);
    }
    /**
     * ListAllNext
     * @param nextLink The nextLink from the previous successful call to the ListAll method.
     * @param options The options parameters.
     */
    _listAllNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listAllNextOperationSpec$d);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listNextOperationSpec$H);
    }
}
// Operation Specifications
const serializer$N = coreClient.createSerializer(Mappers, /* isXml */ false);
const deleteOperationSpec$r = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkSecurityGroups/{networkSecurityGroupName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkSecurityGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$N
};
const getOperationSpec$C = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkSecurityGroups/{networkSecurityGroupName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkSecurityGroup
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, expand],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkSecurityGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$N
};
const createOrUpdateOperationSpec$r = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkSecurityGroups/{networkSecurityGroupName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: NetworkSecurityGroup
        },
        201: {
            bodyMapper: NetworkSecurityGroup
        },
        202: {
            bodyMapper: NetworkSecurityGroup
        },
        204: {
            bodyMapper: NetworkSecurityGroup
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters28,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkSecurityGroupName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$N
};
const updateTagsOperationSpec$g = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkSecurityGroups/{networkSecurityGroupName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: NetworkSecurityGroup
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkSecurityGroupName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$N
};
const listAllOperationSpec$d = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/networkSecurityGroups",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkSecurityGroupListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$N
};
const listOperationSpec$K = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkSecurityGroups",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkSecurityGroupListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$N
};
const listAllNextOperationSpec$d = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkSecurityGroupListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$N
};
const listNextOperationSpec$H = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkSecurityGroupListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$N
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing SecurityRules operations. */
class SecurityRulesImpl {
    /**
     * Initialize a new instance of the class SecurityRules class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all security rules in a network security group.
     * @param resourceGroupName The name of the resource group.
     * @param networkSecurityGroupName The name of the network security group.
     * @param options The options parameters.
     */
    list(resourceGroupName, networkSecurityGroupName, options) {
        const iter = this.listPagingAll(resourceGroupName, networkSecurityGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, networkSecurityGroupName, options);
            }
        };
    }
    listPagingPage(resourceGroupName, networkSecurityGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, networkSecurityGroupName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, networkSecurityGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceGroupName, networkSecurityGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, networkSecurityGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Deletes the specified network security rule.
     * @param resourceGroupName The name of the resource group.
     * @param networkSecurityGroupName The name of the network security group.
     * @param securityRuleName The name of the security rule.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, networkSecurityGroupName, securityRuleName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                networkSecurityGroupName,
                securityRuleName,
                options
            }, deleteOperationSpec$s);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Deletes the specified network security rule.
     * @param resourceGroupName The name of the resource group.
     * @param networkSecurityGroupName The name of the network security group.
     * @param securityRuleName The name of the security rule.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, networkSecurityGroupName, securityRuleName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, networkSecurityGroupName, securityRuleName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Get the specified network security rule.
     * @param resourceGroupName The name of the resource group.
     * @param networkSecurityGroupName The name of the network security group.
     * @param securityRuleName The name of the security rule.
     * @param options The options parameters.
     */
    get(resourceGroupName, networkSecurityGroupName, securityRuleName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            networkSecurityGroupName,
            securityRuleName,
            options
        }, getOperationSpec$D);
    }
    /**
     * Creates or updates a security rule in the specified network security group.
     * @param resourceGroupName The name of the resource group.
     * @param networkSecurityGroupName The name of the network security group.
     * @param securityRuleName The name of the security rule.
     * @param securityRuleParameters Parameters supplied to the create or update network security rule
     *                               operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, networkSecurityGroupName, securityRuleName, securityRuleParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                networkSecurityGroupName,
                securityRuleName,
                securityRuleParameters,
                options
            }, createOrUpdateOperationSpec$s);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
        });
    }
    /**
     * Creates or updates a security rule in the specified network security group.
     * @param resourceGroupName The name of the resource group.
     * @param networkSecurityGroupName The name of the network security group.
     * @param securityRuleName The name of the security rule.
     * @param securityRuleParameters Parameters supplied to the create or update network security rule
     *                               operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, networkSecurityGroupName, securityRuleName, securityRuleParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, networkSecurityGroupName, securityRuleName, securityRuleParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets all security rules in a network security group.
     * @param resourceGroupName The name of the resource group.
     * @param networkSecurityGroupName The name of the network security group.
     * @param options The options parameters.
     */
    _list(resourceGroupName, networkSecurityGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, networkSecurityGroupName, options }, listOperationSpec$L);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param networkSecurityGroupName The name of the network security group.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, networkSecurityGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, networkSecurityGroupName, nextLink, options }, listNextOperationSpec$I);
    }
}
// Operation Specifications
const serializer$O = coreClient.createSerializer(Mappers, /* isXml */ false);
const deleteOperationSpec$s = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkSecurityGroups/{networkSecurityGroupName}/securityRules/{securityRuleName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkSecurityGroupName,
        securityRuleName
    ],
    headerParameters: [accept],
    serializer: serializer$O
};
const getOperationSpec$D = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkSecurityGroups/{networkSecurityGroupName}/securityRules/{securityRuleName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SecurityRule
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkSecurityGroupName,
        securityRuleName
    ],
    headerParameters: [accept],
    serializer: serializer$O
};
const createOrUpdateOperationSpec$s = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkSecurityGroups/{networkSecurityGroupName}/securityRules/{securityRuleName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: SecurityRule
        },
        201: {
            bodyMapper: SecurityRule
        },
        202: {
            bodyMapper: SecurityRule
        },
        204: {
            bodyMapper: SecurityRule
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: securityRuleParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkSecurityGroupName,
        securityRuleName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$O
};
const listOperationSpec$L = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkSecurityGroups/{networkSecurityGroupName}/securityRules",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SecurityRuleListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkSecurityGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$O
};
const listNextOperationSpec$I = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SecurityRuleListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        networkSecurityGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$O
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing DefaultSecurityRules operations. */
class DefaultSecurityRulesImpl {
    /**
     * Initialize a new instance of the class DefaultSecurityRules class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all default security rules in a network security group.
     * @param resourceGroupName The name of the resource group.
     * @param networkSecurityGroupName The name of the network security group.
     * @param options The options parameters.
     */
    list(resourceGroupName, networkSecurityGroupName, options) {
        const iter = this.listPagingAll(resourceGroupName, networkSecurityGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, networkSecurityGroupName, options);
            }
        };
    }
    listPagingPage(resourceGroupName, networkSecurityGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, networkSecurityGroupName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, networkSecurityGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceGroupName, networkSecurityGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, networkSecurityGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets all default security rules in a network security group.
     * @param resourceGroupName The name of the resource group.
     * @param networkSecurityGroupName The name of the network security group.
     * @param options The options parameters.
     */
    _list(resourceGroupName, networkSecurityGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, networkSecurityGroupName, options }, listOperationSpec$M);
    }
    /**
     * Get the specified default network security rule.
     * @param resourceGroupName The name of the resource group.
     * @param networkSecurityGroupName The name of the network security group.
     * @param defaultSecurityRuleName The name of the default security rule.
     * @param options The options parameters.
     */
    get(resourceGroupName, networkSecurityGroupName, defaultSecurityRuleName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            networkSecurityGroupName,
            defaultSecurityRuleName,
            options
        }, getOperationSpec$E);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param networkSecurityGroupName The name of the network security group.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, networkSecurityGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, networkSecurityGroupName, nextLink, options }, listNextOperationSpec$J);
    }
}
// Operation Specifications
const serializer$P = coreClient.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$M = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkSecurityGroups/{networkSecurityGroupName}/defaultSecurityRules",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SecurityRuleListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkSecurityGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$P
};
const getOperationSpec$E = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkSecurityGroups/{networkSecurityGroupName}/defaultSecurityRules/{defaultSecurityRuleName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SecurityRule
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkSecurityGroupName,
        defaultSecurityRuleName
    ],
    headerParameters: [accept],
    serializer: serializer$P
};
const listNextOperationSpec$J = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SecurityRuleListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        networkSecurityGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$P
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing NetworkVirtualAppliances operations. */
class NetworkVirtualAppliancesImpl {
    /**
     * Initialize a new instance of the class NetworkVirtualAppliances class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all Network Virtual Appliances in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByResourceGroupPagingPage(resourceGroupName, options);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets all Network Virtual Appliances in a subscription.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(options);
            }
        };
    }
    listPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Deletes the specified Network Virtual Appliance.
     * @param resourceGroupName The name of the resource group.
     * @param networkVirtualApplianceName The name of Network Virtual Appliance.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, networkVirtualApplianceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, networkVirtualApplianceName, options }, deleteOperationSpec$t);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Deletes the specified Network Virtual Appliance.
     * @param resourceGroupName The name of the resource group.
     * @param networkVirtualApplianceName The name of Network Virtual Appliance.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, networkVirtualApplianceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, networkVirtualApplianceName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the specified Network Virtual Appliance.
     * @param resourceGroupName The name of the resource group.
     * @param networkVirtualApplianceName The name of Network Virtual Appliance.
     * @param options The options parameters.
     */
    get(resourceGroupName, networkVirtualApplianceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, networkVirtualApplianceName, options }, getOperationSpec$F);
    }
    /**
     * Updates a Network Virtual Appliance.
     * @param resourceGroupName The resource group name of Network Virtual Appliance.
     * @param networkVirtualApplianceName The name of Network Virtual Appliance being updated.
     * @param parameters Parameters supplied to Update Network Virtual Appliance Tags.
     * @param options The options parameters.
     */
    updateTags(resourceGroupName, networkVirtualApplianceName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, networkVirtualApplianceName, parameters, options }, updateTagsOperationSpec$h);
    }
    /**
     * Creates or updates the specified Network Virtual Appliance.
     * @param resourceGroupName The name of the resource group.
     * @param networkVirtualApplianceName The name of Network Virtual Appliance.
     * @param parameters Parameters supplied to the create or update Network Virtual Appliance.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, networkVirtualApplianceName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, networkVirtualApplianceName, parameters, options }, createOrUpdateOperationSpec$t);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
        });
    }
    /**
     * Creates or updates the specified Network Virtual Appliance.
     * @param resourceGroupName The name of the resource group.
     * @param networkVirtualApplianceName The name of Network Virtual Appliance.
     * @param parameters Parameters supplied to the create or update Network Virtual Appliance.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, networkVirtualApplianceName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, networkVirtualApplianceName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Lists all Network Virtual Appliances in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec$7);
    }
    /**
     * Gets all Network Virtual Appliances in a subscription.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$N);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The name of the resource group.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec$7);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$K);
    }
}
// Operation Specifications
const serializer$Q = coreClient.createSerializer(Mappers, /* isXml */ false);
const deleteOperationSpec$t = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkVirtualAppliances/{networkVirtualApplianceName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkVirtualApplianceName
    ],
    headerParameters: [accept],
    serializer: serializer$Q
};
const getOperationSpec$F = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkVirtualAppliances/{networkVirtualApplianceName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkVirtualAppliance
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, expand],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkVirtualApplianceName
    ],
    headerParameters: [accept],
    serializer: serializer$Q
};
const updateTagsOperationSpec$h = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkVirtualAppliances/{networkVirtualApplianceName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: NetworkVirtualAppliance
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkVirtualApplianceName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$Q
};
const createOrUpdateOperationSpec$t = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkVirtualAppliances/{networkVirtualApplianceName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: NetworkVirtualAppliance
        },
        201: {
            bodyMapper: NetworkVirtualAppliance
        },
        202: {
            bodyMapper: NetworkVirtualAppliance
        },
        204: {
            bodyMapper: NetworkVirtualAppliance
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters29,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkVirtualApplianceName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$Q
};
const listByResourceGroupOperationSpec$7 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkVirtualAppliances",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkVirtualApplianceListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$Q
};
const listOperationSpec$N = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/networkVirtualAppliances",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkVirtualApplianceListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$Q
};
const listByResourceGroupNextOperationSpec$7 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkVirtualApplianceListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$Q
};
const listNextOperationSpec$K = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkVirtualApplianceListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$Q
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing VirtualApplianceSites operations. */
class VirtualApplianceSitesImpl {
    /**
     * Initialize a new instance of the class VirtualApplianceSites class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all Network Virtual Appliance Sites in a Network Virtual Appliance resource.
     * @param resourceGroupName The name of the resource group.
     * @param networkVirtualApplianceName The name of the Network Virtual Appliance.
     * @param options The options parameters.
     */
    list(resourceGroupName, networkVirtualApplianceName, options) {
        const iter = this.listPagingAll(resourceGroupName, networkVirtualApplianceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, networkVirtualApplianceName, options);
            }
        };
    }
    listPagingPage(resourceGroupName, networkVirtualApplianceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, networkVirtualApplianceName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, networkVirtualApplianceName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceGroupName, networkVirtualApplianceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, networkVirtualApplianceName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Deletes the specified site from a Virtual Appliance.
     * @param resourceGroupName The name of the resource group.
     * @param networkVirtualApplianceName The name of the Network Virtual Appliance.
     * @param siteName The name of the site.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, networkVirtualApplianceName, siteName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, networkVirtualApplianceName, siteName, options }, deleteOperationSpec$u);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Deletes the specified site from a Virtual Appliance.
     * @param resourceGroupName The name of the resource group.
     * @param networkVirtualApplianceName The name of the Network Virtual Appliance.
     * @param siteName The name of the site.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, networkVirtualApplianceName, siteName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, networkVirtualApplianceName, siteName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the specified Virtual Appliance Site.
     * @param resourceGroupName The name of the resource group.
     * @param networkVirtualApplianceName The name of the Network Virtual Appliance.
     * @param siteName The name of the site.
     * @param options The options parameters.
     */
    get(resourceGroupName, networkVirtualApplianceName, siteName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, networkVirtualApplianceName, siteName, options }, getOperationSpec$G);
    }
    /**
     * Creates or updates the specified Network Virtual Appliance Site.
     * @param resourceGroupName The name of the resource group.
     * @param networkVirtualApplianceName The name of the Network Virtual Appliance.
     * @param siteName The name of the site.
     * @param parameters Parameters supplied to the create or update Network Virtual Appliance Site
     *                   operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, networkVirtualApplianceName, siteName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                networkVirtualApplianceName,
                siteName,
                parameters,
                options
            }, createOrUpdateOperationSpec$u);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
        });
    }
    /**
     * Creates or updates the specified Network Virtual Appliance Site.
     * @param resourceGroupName The name of the resource group.
     * @param networkVirtualApplianceName The name of the Network Virtual Appliance.
     * @param siteName The name of the site.
     * @param parameters Parameters supplied to the create or update Network Virtual Appliance Site
     *                   operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, networkVirtualApplianceName, siteName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, networkVirtualApplianceName, siteName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Lists all Network Virtual Appliance Sites in a Network Virtual Appliance resource.
     * @param resourceGroupName The name of the resource group.
     * @param networkVirtualApplianceName The name of the Network Virtual Appliance.
     * @param options The options parameters.
     */
    _list(resourceGroupName, networkVirtualApplianceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, networkVirtualApplianceName, options }, listOperationSpec$O);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param networkVirtualApplianceName The name of the Network Virtual Appliance.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, networkVirtualApplianceName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, networkVirtualApplianceName, nextLink, options }, listNextOperationSpec$L);
    }
}
// Operation Specifications
const serializer$R = coreClient.createSerializer(Mappers, /* isXml */ false);
const deleteOperationSpec$u = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkVirtualAppliances/{networkVirtualApplianceName}/virtualApplianceSites/{siteName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkVirtualApplianceName,
        siteName
    ],
    headerParameters: [accept],
    serializer: serializer$R
};
const getOperationSpec$G = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkVirtualAppliances/{networkVirtualApplianceName}/virtualApplianceSites/{siteName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualApplianceSite
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkVirtualApplianceName,
        siteName
    ],
    headerParameters: [accept],
    serializer: serializer$R
};
const createOrUpdateOperationSpec$u = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkVirtualAppliances/{networkVirtualApplianceName}/virtualApplianceSites/{siteName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: VirtualApplianceSite
        },
        201: {
            bodyMapper: VirtualApplianceSite
        },
        202: {
            bodyMapper: VirtualApplianceSite
        },
        204: {
            bodyMapper: VirtualApplianceSite
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters30,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkVirtualApplianceName,
        siteName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$R
};
const listOperationSpec$O = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkVirtualAppliances/{networkVirtualApplianceName}/virtualApplianceSites",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkVirtualApplianceSiteListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkVirtualApplianceName
    ],
    headerParameters: [accept],
    serializer: serializer$R
};
const listNextOperationSpec$L = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkVirtualApplianceSiteListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        networkVirtualApplianceName
    ],
    headerParameters: [accept],
    serializer: serializer$R
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing VirtualApplianceSkus operations. */
class VirtualApplianceSkusImpl {
    /**
     * Initialize a new instance of the class VirtualApplianceSkus class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List all SKUs available for a virtual appliance.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(options);
            }
        };
    }
    listPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List all SKUs available for a virtual appliance.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$P);
    }
    /**
     * Retrieves a single available sku for network virtual appliance.
     * @param skuName Name of the Sku.
     * @param options The options parameters.
     */
    get(skuName, options) {
        return this.client.sendOperationRequest({ skuName, options }, getOperationSpec$H);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$M);
    }
}
// Operation Specifications
const serializer$S = coreClient.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$P = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/networkVirtualApplianceSkus",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkVirtualApplianceSkuListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$S
};
const getOperationSpec$H = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/networkVirtualApplianceSkus/{skuName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkVirtualApplianceSku
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        skuName
    ],
    headerParameters: [accept],
    serializer: serializer$S
};
const listNextOperationSpec$M = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkVirtualApplianceSkuListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$S
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing InboundSecurityRuleOperations operations. */
class InboundSecurityRuleOperationsImpl {
    /**
     * Initialize a new instance of the class InboundSecurityRuleOperations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Creates or updates the specified Network Virtual Appliance Inbound Security Rules.
     * @param resourceGroupName The name of the resource group.
     * @param networkVirtualApplianceName The name of the Network Virtual Appliance.
     * @param ruleCollectionName The name of security rule collection.
     * @param parameters Parameters supplied to the create or update Network Virtual Appliance Inbound
     *                   Security Rules operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, networkVirtualApplianceName, ruleCollectionName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                networkVirtualApplianceName,
                ruleCollectionName,
                parameters,
                options
            }, createOrUpdateOperationSpec$v);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
        });
    }
    /**
     * Creates or updates the specified Network Virtual Appliance Inbound Security Rules.
     * @param resourceGroupName The name of the resource group.
     * @param networkVirtualApplianceName The name of the Network Virtual Appliance.
     * @param ruleCollectionName The name of security rule collection.
     * @param parameters Parameters supplied to the create or update Network Virtual Appliance Inbound
     *                   Security Rules operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, networkVirtualApplianceName, ruleCollectionName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, networkVirtualApplianceName, ruleCollectionName, parameters, options);
            return poller.pollUntilDone();
        });
    }
}
// Operation Specifications
const serializer$T = coreClient.createSerializer(Mappers, /* isXml */ false);
const createOrUpdateOperationSpec$v = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkVirtualAppliances/{networkVirtualApplianceName}/inboundSecurityRules/{ruleCollectionName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: InboundSecurityRule
        },
        201: {
            bodyMapper: InboundSecurityRule
        },
        202: {
            bodyMapper: InboundSecurityRule
        },
        204: {
            bodyMapper: InboundSecurityRule
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters31,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkVirtualApplianceName,
        ruleCollectionName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$T
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing NetworkWatchers operations. */
class NetworkWatchersImpl {
    /**
     * Initialize a new instance of the class NetworkWatchers class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all network watchers by resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    list(resourceGroupName, options) {
        const iter = this.listPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, options);
            }
        };
    }
    listPagingPage(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets all network watchers by subscription.
     * @param options The options parameters.
     */
    listAll(options) {
        const iter = this.listAllPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listAllPagingPage(options);
            }
        };
    }
    listAllPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listAllPagingPage_1() {
            let result = yield tslib.__await(this._listAll(options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listAllPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listAllPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listAllPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Creates or updates a network watcher in the specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param networkWatcherName The name of the network watcher.
     * @param parameters Parameters that define the network watcher resource.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, networkWatcherName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, networkWatcherName, parameters, options }, createOrUpdateOperationSpec$w);
    }
    /**
     * Gets the specified network watcher by resource group.
     * @param resourceGroupName The name of the resource group.
     * @param networkWatcherName The name of the network watcher.
     * @param options The options parameters.
     */
    get(resourceGroupName, networkWatcherName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, networkWatcherName, options }, getOperationSpec$I);
    }
    /**
     * Deletes the specified network watcher resource.
     * @param resourceGroupName The name of the resource group.
     * @param networkWatcherName The name of the network watcher.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, networkWatcherName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, networkWatcherName, options }, deleteOperationSpec$v);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Deletes the specified network watcher resource.
     * @param resourceGroupName The name of the resource group.
     * @param networkWatcherName The name of the network watcher.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, networkWatcherName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, networkWatcherName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates a network watcher tags.
     * @param resourceGroupName The name of the resource group.
     * @param networkWatcherName The name of the network watcher.
     * @param parameters Parameters supplied to update network watcher tags.
     * @param options The options parameters.
     */
    updateTags(resourceGroupName, networkWatcherName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, networkWatcherName, parameters, options }, updateTagsOperationSpec$i);
    }
    /**
     * Gets all network watchers by resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    _list(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listOperationSpec$Q);
    }
    /**
     * Gets all network watchers by subscription.
     * @param options The options parameters.
     */
    _listAll(options) {
        return this.client.sendOperationRequest({ options }, listAllOperationSpec$e);
    }
    /**
     * Gets the current network topology by resource group.
     * @param resourceGroupName The name of the resource group.
     * @param networkWatcherName The name of the network watcher.
     * @param parameters Parameters that define the representation of topology.
     * @param options The options parameters.
     */
    getTopology(resourceGroupName, networkWatcherName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, networkWatcherName, parameters, options }, getTopologyOperationSpec);
    }
    /**
     * Verify IP flow from the specified VM to a location given the currently configured NSG rules.
     * @param resourceGroupName The name of the resource group.
     * @param networkWatcherName The name of the network watcher.
     * @param parameters Parameters that define the IP flow to be verified.
     * @param options The options parameters.
     */
    beginVerifyIPFlow(resourceGroupName, networkWatcherName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, networkWatcherName, parameters, options }, verifyIPFlowOperationSpec);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Verify IP flow from the specified VM to a location given the currently configured NSG rules.
     * @param resourceGroupName The name of the resource group.
     * @param networkWatcherName The name of the network watcher.
     * @param parameters Parameters that define the IP flow to be verified.
     * @param options The options parameters.
     */
    beginVerifyIPFlowAndWait(resourceGroupName, networkWatcherName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginVerifyIPFlow(resourceGroupName, networkWatcherName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the next hop from the specified VM.
     * @param resourceGroupName The name of the resource group.
     * @param networkWatcherName The name of the network watcher.
     * @param parameters Parameters that define the source and destination endpoint.
     * @param options The options parameters.
     */
    beginGetNextHop(resourceGroupName, networkWatcherName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, networkWatcherName, parameters, options }, getNextHopOperationSpec);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Gets the next hop from the specified VM.
     * @param resourceGroupName The name of the resource group.
     * @param networkWatcherName The name of the network watcher.
     * @param parameters Parameters that define the source and destination endpoint.
     * @param options The options parameters.
     */
    beginGetNextHopAndWait(resourceGroupName, networkWatcherName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginGetNextHop(resourceGroupName, networkWatcherName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the configured and effective security group rules on the specified VM.
     * @param resourceGroupName The name of the resource group.
     * @param networkWatcherName The name of the network watcher.
     * @param parameters Parameters that define the VM to check security groups for.
     * @param options The options parameters.
     */
    beginGetVMSecurityRules(resourceGroupName, networkWatcherName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, networkWatcherName, parameters, options }, getVMSecurityRulesOperationSpec);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Gets the configured and effective security group rules on the specified VM.
     * @param resourceGroupName The name of the resource group.
     * @param networkWatcherName The name of the network watcher.
     * @param parameters Parameters that define the VM to check security groups for.
     * @param options The options parameters.
     */
    beginGetVMSecurityRulesAndWait(resourceGroupName, networkWatcherName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginGetVMSecurityRules(resourceGroupName, networkWatcherName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Initiate troubleshooting on a specified resource.
     * @param resourceGroupName The name of the resource group.
     * @param networkWatcherName The name of the network watcher resource.
     * @param parameters Parameters that define the resource to troubleshoot.
     * @param options The options parameters.
     */
    beginGetTroubleshooting(resourceGroupName, networkWatcherName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, networkWatcherName, parameters, options }, getTroubleshootingOperationSpec);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Initiate troubleshooting on a specified resource.
     * @param resourceGroupName The name of the resource group.
     * @param networkWatcherName The name of the network watcher resource.
     * @param parameters Parameters that define the resource to troubleshoot.
     * @param options The options parameters.
     */
    beginGetTroubleshootingAndWait(resourceGroupName, networkWatcherName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginGetTroubleshooting(resourceGroupName, networkWatcherName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Get the last completed troubleshooting result on a specified resource.
     * @param resourceGroupName The name of the resource group.
     * @param networkWatcherName The name of the network watcher resource.
     * @param parameters Parameters that define the resource to query the troubleshooting result.
     * @param options The options parameters.
     */
    beginGetTroubleshootingResult(resourceGroupName, networkWatcherName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, networkWatcherName, parameters, options }, getTroubleshootingResultOperationSpec);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Get the last completed troubleshooting result on a specified resource.
     * @param resourceGroupName The name of the resource group.
     * @param networkWatcherName The name of the network watcher resource.
     * @param parameters Parameters that define the resource to query the troubleshooting result.
     * @param options The options parameters.
     */
    beginGetTroubleshootingResultAndWait(resourceGroupName, networkWatcherName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginGetTroubleshootingResult(resourceGroupName, networkWatcherName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Configures flow log and traffic analytics (optional) on a specified resource.
     * @param resourceGroupName The name of the network watcher resource group.
     * @param networkWatcherName The name of the network watcher resource.
     * @param parameters Parameters that define the configuration of flow log.
     * @param options The options parameters.
     */
    beginSetFlowLogConfiguration(resourceGroupName, networkWatcherName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, networkWatcherName, parameters, options }, setFlowLogConfigurationOperationSpec);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Configures flow log and traffic analytics (optional) on a specified resource.
     * @param resourceGroupName The name of the network watcher resource group.
     * @param networkWatcherName The name of the network watcher resource.
     * @param parameters Parameters that define the configuration of flow log.
     * @param options The options parameters.
     */
    beginSetFlowLogConfigurationAndWait(resourceGroupName, networkWatcherName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginSetFlowLogConfiguration(resourceGroupName, networkWatcherName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Queries status of flow log and traffic analytics (optional) on a specified resource.
     * @param resourceGroupName The name of the network watcher resource group.
     * @param networkWatcherName The name of the network watcher resource.
     * @param parameters Parameters that define a resource to query flow log and traffic analytics
     *                   (optional) status.
     * @param options The options parameters.
     */
    beginGetFlowLogStatus(resourceGroupName, networkWatcherName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, networkWatcherName, parameters, options }, getFlowLogStatusOperationSpec);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Queries status of flow log and traffic analytics (optional) on a specified resource.
     * @param resourceGroupName The name of the network watcher resource group.
     * @param networkWatcherName The name of the network watcher resource.
     * @param parameters Parameters that define a resource to query flow log and traffic analytics
     *                   (optional) status.
     * @param options The options parameters.
     */
    beginGetFlowLogStatusAndWait(resourceGroupName, networkWatcherName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginGetFlowLogStatus(resourceGroupName, networkWatcherName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Verifies the possibility of establishing a direct TCP connection from a virtual machine to a given
     * endpoint including another VM or an arbitrary remote server.
     * @param resourceGroupName The name of the network watcher resource group.
     * @param networkWatcherName The name of the network watcher resource.
     * @param parameters Parameters that determine how the connectivity check will be performed.
     * @param options The options parameters.
     */
    beginCheckConnectivity(resourceGroupName, networkWatcherName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, networkWatcherName, parameters, options }, checkConnectivityOperationSpec);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Verifies the possibility of establishing a direct TCP connection from a virtual machine to a given
     * endpoint including another VM or an arbitrary remote server.
     * @param resourceGroupName The name of the network watcher resource group.
     * @param networkWatcherName The name of the network watcher resource.
     * @param parameters Parameters that determine how the connectivity check will be performed.
     * @param options The options parameters.
     */
    beginCheckConnectivityAndWait(resourceGroupName, networkWatcherName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCheckConnectivity(resourceGroupName, networkWatcherName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * NOTE: This feature is currently in preview and still being tested for stability. Gets the relative
     * latency score for internet service providers from a specified location to Azure regions.
     * @param resourceGroupName The name of the network watcher resource group.
     * @param networkWatcherName The name of the network watcher resource.
     * @param parameters Parameters that determine Azure reachability report configuration.
     * @param options The options parameters.
     */
    beginGetAzureReachabilityReport(resourceGroupName, networkWatcherName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, networkWatcherName, parameters, options }, getAzureReachabilityReportOperationSpec);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * NOTE: This feature is currently in preview and still being tested for stability. Gets the relative
     * latency score for internet service providers from a specified location to Azure regions.
     * @param resourceGroupName The name of the network watcher resource group.
     * @param networkWatcherName The name of the network watcher resource.
     * @param parameters Parameters that determine Azure reachability report configuration.
     * @param options The options parameters.
     */
    beginGetAzureReachabilityReportAndWait(resourceGroupName, networkWatcherName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginGetAzureReachabilityReport(resourceGroupName, networkWatcherName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * NOTE: This feature is currently in preview and still being tested for stability. Lists all available
     * internet service providers for a specified Azure region.
     * @param resourceGroupName The name of the network watcher resource group.
     * @param networkWatcherName The name of the network watcher resource.
     * @param parameters Parameters that scope the list of available providers.
     * @param options The options parameters.
     */
    beginListAvailableProviders(resourceGroupName, networkWatcherName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, networkWatcherName, parameters, options }, listAvailableProvidersOperationSpec);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * NOTE: This feature is currently in preview and still being tested for stability. Lists all available
     * internet service providers for a specified Azure region.
     * @param resourceGroupName The name of the network watcher resource group.
     * @param networkWatcherName The name of the network watcher resource.
     * @param parameters Parameters that scope the list of available providers.
     * @param options The options parameters.
     */
    beginListAvailableProvidersAndWait(resourceGroupName, networkWatcherName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginListAvailableProviders(resourceGroupName, networkWatcherName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets Network Configuration Diagnostic data to help customers understand and debug network behavior.
     * It provides detailed information on what security rules were applied to a specified traffic flow and
     * the result of evaluating these rules. Customers must provide details of a flow like source,
     * destination, protocol, etc. The API returns whether traffic was allowed or denied, the rules
     * evaluated for the specified flow and the evaluation results.
     * @param resourceGroupName The name of the resource group.
     * @param networkWatcherName The name of the network watcher.
     * @param parameters Parameters to get network configuration diagnostic.
     * @param options The options parameters.
     */
    beginGetNetworkConfigurationDiagnostic(resourceGroupName, networkWatcherName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, networkWatcherName, parameters, options }, getNetworkConfigurationDiagnosticOperationSpec);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Gets Network Configuration Diagnostic data to help customers understand and debug network behavior.
     * It provides detailed information on what security rules were applied to a specified traffic flow and
     * the result of evaluating these rules. Customers must provide details of a flow like source,
     * destination, protocol, etc. The API returns whether traffic was allowed or denied, the rules
     * evaluated for the specified flow and the evaluation results.
     * @param resourceGroupName The name of the resource group.
     * @param networkWatcherName The name of the network watcher.
     * @param parameters Parameters to get network configuration diagnostic.
     * @param options The options parameters.
     */
    beginGetNetworkConfigurationDiagnosticAndWait(resourceGroupName, networkWatcherName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginGetNetworkConfigurationDiagnostic(resourceGroupName, networkWatcherName, parameters, options);
            return poller.pollUntilDone();
        });
    }
}
// Operation Specifications
const serializer$U = coreClient.createSerializer(Mappers, /* isXml */ false);
const createOrUpdateOperationSpec$w = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkWatchers/{networkWatcherName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: NetworkWatcher
        },
        201: {
            bodyMapper: NetworkWatcher
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters32,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkWatcherName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$U
};
const getOperationSpec$I = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkWatchers/{networkWatcherName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkWatcher
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkWatcherName
    ],
    headerParameters: [accept],
    serializer: serializer$U
};
const deleteOperationSpec$v = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkWatchers/{networkWatcherName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkWatcherName
    ],
    headerParameters: [accept],
    serializer: serializer$U
};
const updateTagsOperationSpec$i = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkWatchers/{networkWatcherName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: NetworkWatcher
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkWatcherName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$U
};
const listOperationSpec$Q = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkWatchers",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkWatcherListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$U
};
const listAllOperationSpec$e = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/networkWatchers",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkWatcherListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$U
};
const getTopologyOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkWatchers/{networkWatcherName}/topology",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: Topology
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters33,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkWatcherName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$U
};
const verifyIPFlowOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkWatchers/{networkWatcherName}/ipFlowVerify",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: VerificationIPFlowResult
        },
        201: {
            bodyMapper: VerificationIPFlowResult
        },
        202: {
            bodyMapper: VerificationIPFlowResult
        },
        204: {
            bodyMapper: VerificationIPFlowResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters34,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkWatcherName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$U
};
const getNextHopOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkWatchers/{networkWatcherName}/nextHop",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: NextHopResult
        },
        201: {
            bodyMapper: NextHopResult
        },
        202: {
            bodyMapper: NextHopResult
        },
        204: {
            bodyMapper: NextHopResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters35,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkWatcherName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$U
};
const getVMSecurityRulesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkWatchers/{networkWatcherName}/securityGroupView",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: SecurityGroupViewResult
        },
        201: {
            bodyMapper: SecurityGroupViewResult
        },
        202: {
            bodyMapper: SecurityGroupViewResult
        },
        204: {
            bodyMapper: SecurityGroupViewResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters36,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkWatcherName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$U
};
const getTroubleshootingOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkWatchers/{networkWatcherName}/troubleshoot",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: TroubleshootingResult
        },
        201: {
            bodyMapper: TroubleshootingResult
        },
        202: {
            bodyMapper: TroubleshootingResult
        },
        204: {
            bodyMapper: TroubleshootingResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters37,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkWatcherName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$U
};
const getTroubleshootingResultOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkWatchers/{networkWatcherName}/queryTroubleshootResult",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: TroubleshootingResult
        },
        201: {
            bodyMapper: TroubleshootingResult
        },
        202: {
            bodyMapper: TroubleshootingResult
        },
        204: {
            bodyMapper: TroubleshootingResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters38,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkWatcherName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$U
};
const setFlowLogConfigurationOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkWatchers/{networkWatcherName}/configureFlowLog",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: FlowLogInformation
        },
        201: {
            bodyMapper: FlowLogInformation
        },
        202: {
            bodyMapper: FlowLogInformation
        },
        204: {
            bodyMapper: FlowLogInformation
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters39,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkWatcherName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$U
};
const getFlowLogStatusOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkWatchers/{networkWatcherName}/queryFlowLogStatus",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: FlowLogInformation
        },
        201: {
            bodyMapper: FlowLogInformation
        },
        202: {
            bodyMapper: FlowLogInformation
        },
        204: {
            bodyMapper: FlowLogInformation
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters40,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkWatcherName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$U
};
const checkConnectivityOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkWatchers/{networkWatcherName}/connectivityCheck",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: ConnectivityInformation
        },
        201: {
            bodyMapper: ConnectivityInformation
        },
        202: {
            bodyMapper: ConnectivityInformation
        },
        204: {
            bodyMapper: ConnectivityInformation
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters41,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkWatcherName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$U
};
const getAzureReachabilityReportOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkWatchers/{networkWatcherName}/azureReachabilityReport",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: AzureReachabilityReport
        },
        201: {
            bodyMapper: AzureReachabilityReport
        },
        202: {
            bodyMapper: AzureReachabilityReport
        },
        204: {
            bodyMapper: AzureReachabilityReport
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters42,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkWatcherName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$U
};
const listAvailableProvidersOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkWatchers/{networkWatcherName}/availableProvidersList",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: AvailableProvidersList
        },
        201: {
            bodyMapper: AvailableProvidersList
        },
        202: {
            bodyMapper: AvailableProvidersList
        },
        204: {
            bodyMapper: AvailableProvidersList
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters43,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkWatcherName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$U
};
const getNetworkConfigurationDiagnosticOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkWatchers/{networkWatcherName}/networkConfigurationDiagnostic",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: NetworkConfigurationDiagnosticResponse
        },
        201: {
            bodyMapper: NetworkConfigurationDiagnosticResponse
        },
        202: {
            bodyMapper: NetworkConfigurationDiagnosticResponse
        },
        204: {
            bodyMapper: NetworkConfigurationDiagnosticResponse
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters44,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkWatcherName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$U
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing PacketCaptures operations. */
class PacketCapturesImpl {
    /**
     * Initialize a new instance of the class PacketCaptures class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all packet capture sessions within the specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param networkWatcherName The name of the Network Watcher resource.
     * @param options The options parameters.
     */
    list(resourceGroupName, networkWatcherName, options) {
        const iter = this.listPagingAll(resourceGroupName, networkWatcherName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, networkWatcherName, options);
            }
        };
    }
    listPagingPage(resourceGroupName, networkWatcherName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, networkWatcherName, options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listPagingAll(resourceGroupName, networkWatcherName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, networkWatcherName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Create and start a packet capture on the specified VM.
     * @param resourceGroupName The name of the resource group.
     * @param networkWatcherName The name of the network watcher.
     * @param packetCaptureName The name of the packet capture session.
     * @param parameters Parameters that define the create packet capture operation.
     * @param options The options parameters.
     */
    beginCreate(resourceGroupName, networkWatcherName, packetCaptureName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                networkWatcherName,
                packetCaptureName,
                parameters,
                options
            }, createOperationSpec);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
        });
    }
    /**
     * Create and start a packet capture on the specified VM.
     * @param resourceGroupName The name of the resource group.
     * @param networkWatcherName The name of the network watcher.
     * @param packetCaptureName The name of the packet capture session.
     * @param parameters Parameters that define the create packet capture operation.
     * @param options The options parameters.
     */
    beginCreateAndWait(resourceGroupName, networkWatcherName, packetCaptureName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreate(resourceGroupName, networkWatcherName, packetCaptureName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets a packet capture session by name.
     * @param resourceGroupName The name of the resource group.
     * @param networkWatcherName The name of the network watcher.
     * @param packetCaptureName The name of the packet capture session.
     * @param options The options parameters.
     */
    get(resourceGroupName, networkWatcherName, packetCaptureName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, networkWatcherName, packetCaptureName, options }, getOperationSpec$J);
    }
    /**
     * Deletes the specified packet capture session.
     * @param resourceGroupName The name of the resource group.
     * @param networkWatcherName The name of the network watcher.
     * @param packetCaptureName The name of the packet capture session.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, networkWatcherName, packetCaptureName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, networkWatcherName, packetCaptureName, options }, deleteOperationSpec$w);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Deletes the specified packet capture session.
     * @param resourceGroupName The name of the resource group.
     * @param networkWatcherName The name of the network watcher.
     * @param packetCaptureName The name of the packet capture session.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, networkWatcherName, packetCaptureName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, networkWatcherName, packetCaptureName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Stops a specified packet capture session.
     * @param resourceGroupName The name of the resource group.
     * @param networkWatcherName The name of the network watcher.
     * @param packetCaptureName The name of the packet capture session.
     * @param options The options parameters.
     */
    beginStop(resourceGroupName, networkWatcherName, packetCaptureName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, networkWatcherName, packetCaptureName, options }, stopOperationSpec$1);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Stops a specified packet capture session.
     * @param resourceGroupName The name of the resource group.
     * @param networkWatcherName The name of the network watcher.
     * @param packetCaptureName The name of the packet capture session.
     * @param options The options parameters.
     */
    beginStopAndWait(resourceGroupName, networkWatcherName, packetCaptureName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginStop(resourceGroupName, networkWatcherName, packetCaptureName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Query the status of a running packet capture session.
     * @param resourceGroupName The name of the resource group.
     * @param networkWatcherName The name of the Network Watcher resource.
     * @param packetCaptureName The name given to the packet capture session.
     * @param options The options parameters.
     */
    beginGetStatus(resourceGroupName, networkWatcherName, packetCaptureName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, networkWatcherName, packetCaptureName, options }, getStatusOperationSpec);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Query the status of a running packet capture session.
     * @param resourceGroupName The name of the resource group.
     * @param networkWatcherName The name of the Network Watcher resource.
     * @param packetCaptureName The name given to the packet capture session.
     * @param options The options parameters.
     */
    beginGetStatusAndWait(resourceGroupName, networkWatcherName, packetCaptureName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginGetStatus(resourceGroupName, networkWatcherName, packetCaptureName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Lists all packet capture sessions within the specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param networkWatcherName The name of the Network Watcher resource.
     * @param options The options parameters.
     */
    _list(resourceGroupName, networkWatcherName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, networkWatcherName, options }, listOperationSpec$R);
    }
}
// Operation Specifications
const serializer$V = coreClient.createSerializer(Mappers, /* isXml */ false);
const createOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkWatchers/{networkWatcherName}/packetCaptures/{packetCaptureName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: PacketCaptureResult
        },
        201: {
            bodyMapper: PacketCaptureResult
        },
        202: {
            bodyMapper: PacketCaptureResult
        },
        204: {
            bodyMapper: PacketCaptureResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters45,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkWatcherName,
        packetCaptureName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$V
};
const getOperationSpec$J = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkWatchers/{networkWatcherName}/packetCaptures/{packetCaptureName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PacketCaptureResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkWatcherName,
        packetCaptureName
    ],
    headerParameters: [accept],
    serializer: serializer$V
};
const deleteOperationSpec$w = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkWatchers/{networkWatcherName}/packetCaptures/{packetCaptureName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkWatcherName,
        packetCaptureName
    ],
    headerParameters: [accept],
    serializer: serializer$V
};
const stopOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkWatchers/{networkWatcherName}/packetCaptures/{packetCaptureName}/stop",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkWatcherName,
        packetCaptureName
    ],
    headerParameters: [accept],
    serializer: serializer$V
};
const getStatusOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkWatchers/{networkWatcherName}/packetCaptures/{packetCaptureName}/queryStatus",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: PacketCaptureQueryStatusResult
        },
        201: {
            bodyMapper: PacketCaptureQueryStatusResult
        },
        202: {
            bodyMapper: PacketCaptureQueryStatusResult
        },
        204: {
            bodyMapper: PacketCaptureQueryStatusResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkWatcherName,
        packetCaptureName
    ],
    headerParameters: [accept],
    serializer: serializer$V
};
const listOperationSpec$R = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkWatchers/{networkWatcherName}/packetCaptures",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PacketCaptureListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkWatcherName
    ],
    headerParameters: [accept],
    serializer: serializer$V
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ConnectionMonitors operations. */
class ConnectionMonitorsImpl {
    /**
     * Initialize a new instance of the class ConnectionMonitors class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all connection monitors for the specified Network Watcher.
     * @param resourceGroupName The name of the resource group containing Network Watcher.
     * @param networkWatcherName The name of the Network Watcher resource.
     * @param options The options parameters.
     */
    list(resourceGroupName, networkWatcherName, options) {
        const iter = this.listPagingAll(resourceGroupName, networkWatcherName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, networkWatcherName, options);
            }
        };
    }
    listPagingPage(resourceGroupName, networkWatcherName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, networkWatcherName, options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listPagingAll(resourceGroupName, networkWatcherName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, networkWatcherName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Create or update a connection monitor.
     * @param resourceGroupName The name of the resource group containing Network Watcher.
     * @param networkWatcherName The name of the Network Watcher resource.
     * @param connectionMonitorName The name of the connection monitor.
     * @param parameters Parameters that define the operation to create a connection monitor.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, networkWatcherName, connectionMonitorName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                networkWatcherName,
                connectionMonitorName,
                parameters,
                options
            }, createOrUpdateOperationSpec$x);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
        });
    }
    /**
     * Create or update a connection monitor.
     * @param resourceGroupName The name of the resource group containing Network Watcher.
     * @param networkWatcherName The name of the Network Watcher resource.
     * @param connectionMonitorName The name of the connection monitor.
     * @param parameters Parameters that define the operation to create a connection monitor.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, networkWatcherName, connectionMonitorName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, networkWatcherName, connectionMonitorName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets a connection monitor by name.
     * @param resourceGroupName The name of the resource group containing Network Watcher.
     * @param networkWatcherName The name of the Network Watcher resource.
     * @param connectionMonitorName The name of the connection monitor.
     * @param options The options parameters.
     */
    get(resourceGroupName, networkWatcherName, connectionMonitorName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, networkWatcherName, connectionMonitorName, options }, getOperationSpec$K);
    }
    /**
     * Deletes the specified connection monitor.
     * @param resourceGroupName The name of the resource group containing Network Watcher.
     * @param networkWatcherName The name of the Network Watcher resource.
     * @param connectionMonitorName The name of the connection monitor.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, networkWatcherName, connectionMonitorName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, networkWatcherName, connectionMonitorName, options }, deleteOperationSpec$x);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Deletes the specified connection monitor.
     * @param resourceGroupName The name of the resource group containing Network Watcher.
     * @param networkWatcherName The name of the Network Watcher resource.
     * @param connectionMonitorName The name of the connection monitor.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, networkWatcherName, connectionMonitorName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, networkWatcherName, connectionMonitorName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Update tags of the specified connection monitor.
     * @param resourceGroupName The name of the resource group.
     * @param networkWatcherName The name of the network watcher.
     * @param connectionMonitorName The name of the connection monitor.
     * @param parameters Parameters supplied to update connection monitor tags.
     * @param options The options parameters.
     */
    updateTags(resourceGroupName, networkWatcherName, connectionMonitorName, parameters, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            networkWatcherName,
            connectionMonitorName,
            parameters,
            options
        }, updateTagsOperationSpec$j);
    }
    /**
     * Stops the specified connection monitor.
     * @param resourceGroupName The name of the resource group containing Network Watcher.
     * @param networkWatcherName The name of the Network Watcher resource.
     * @param connectionMonitorName The name of the connection monitor.
     * @param options The options parameters.
     */
    beginStop(resourceGroupName, networkWatcherName, connectionMonitorName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, networkWatcherName, connectionMonitorName, options }, stopOperationSpec$2);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Stops the specified connection monitor.
     * @param resourceGroupName The name of the resource group containing Network Watcher.
     * @param networkWatcherName The name of the Network Watcher resource.
     * @param connectionMonitorName The name of the connection monitor.
     * @param options The options parameters.
     */
    beginStopAndWait(resourceGroupName, networkWatcherName, connectionMonitorName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginStop(resourceGroupName, networkWatcherName, connectionMonitorName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Starts the specified connection monitor.
     * @param resourceGroupName The name of the resource group containing Network Watcher.
     * @param networkWatcherName The name of the Network Watcher resource.
     * @param connectionMonitorName The name of the connection monitor.
     * @param options The options parameters.
     */
    beginStart(resourceGroupName, networkWatcherName, connectionMonitorName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, networkWatcherName, connectionMonitorName, options }, startOperationSpec$1);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Starts the specified connection monitor.
     * @param resourceGroupName The name of the resource group containing Network Watcher.
     * @param networkWatcherName The name of the Network Watcher resource.
     * @param connectionMonitorName The name of the connection monitor.
     * @param options The options parameters.
     */
    beginStartAndWait(resourceGroupName, networkWatcherName, connectionMonitorName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginStart(resourceGroupName, networkWatcherName, connectionMonitorName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Query a snapshot of the most recent connection states.
     * @param resourceGroupName The name of the resource group containing Network Watcher.
     * @param networkWatcherName The name of the Network Watcher resource.
     * @param connectionMonitorName The name given to the connection monitor.
     * @param options The options parameters.
     */
    beginQuery(resourceGroupName, networkWatcherName, connectionMonitorName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, networkWatcherName, connectionMonitorName, options }, queryOperationSpec);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Query a snapshot of the most recent connection states.
     * @param resourceGroupName The name of the resource group containing Network Watcher.
     * @param networkWatcherName The name of the Network Watcher resource.
     * @param connectionMonitorName The name given to the connection monitor.
     * @param options The options parameters.
     */
    beginQueryAndWait(resourceGroupName, networkWatcherName, connectionMonitorName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginQuery(resourceGroupName, networkWatcherName, connectionMonitorName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Lists all connection monitors for the specified Network Watcher.
     * @param resourceGroupName The name of the resource group containing Network Watcher.
     * @param networkWatcherName The name of the Network Watcher resource.
     * @param options The options parameters.
     */
    _list(resourceGroupName, networkWatcherName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, networkWatcherName, options }, listOperationSpec$S);
    }
}
// Operation Specifications
const serializer$W = coreClient.createSerializer(Mappers, /* isXml */ false);
const createOrUpdateOperationSpec$x = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkWatchers/{networkWatcherName}/connectionMonitors/{connectionMonitorName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ConnectionMonitorResult
        },
        201: {
            bodyMapper: ConnectionMonitorResult
        },
        202: {
            bodyMapper: ConnectionMonitorResult
        },
        204: {
            bodyMapper: ConnectionMonitorResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters46,
    queryParameters: [apiVersion, migrate],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkWatcherName,
        connectionMonitorName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$W
};
const getOperationSpec$K = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkWatchers/{networkWatcherName}/connectionMonitors/{connectionMonitorName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ConnectionMonitorResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkWatcherName,
        connectionMonitorName
    ],
    headerParameters: [accept],
    serializer: serializer$W
};
const deleteOperationSpec$x = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkWatchers/{networkWatcherName}/connectionMonitors/{connectionMonitorName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkWatcherName,
        connectionMonitorName
    ],
    headerParameters: [accept],
    serializer: serializer$W
};
const updateTagsOperationSpec$j = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkWatchers/{networkWatcherName}/connectionMonitors/{connectionMonitorName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: ConnectionMonitorResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkWatcherName,
        connectionMonitorName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$W
};
const stopOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkWatchers/{networkWatcherName}/connectionMonitors/{connectionMonitorName}/stop",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkWatcherName,
        connectionMonitorName
    ],
    headerParameters: [accept],
    serializer: serializer$W
};
const startOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkWatchers/{networkWatcherName}/connectionMonitors/{connectionMonitorName}/start",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkWatcherName,
        connectionMonitorName
    ],
    headerParameters: [accept],
    serializer: serializer$W
};
const queryOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkWatchers/{networkWatcherName}/connectionMonitors/{connectionMonitorName}/query",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: ConnectionMonitorQueryResult
        },
        201: {
            bodyMapper: ConnectionMonitorQueryResult
        },
        202: {
            bodyMapper: ConnectionMonitorQueryResult
        },
        204: {
            bodyMapper: ConnectionMonitorQueryResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkWatcherName,
        connectionMonitorName
    ],
    headerParameters: [accept],
    serializer: serializer$W
};
const listOperationSpec$S = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkWatchers/{networkWatcherName}/connectionMonitors",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ConnectionMonitorListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkWatcherName
    ],
    headerParameters: [accept],
    serializer: serializer$W
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing FlowLogs operations. */
class FlowLogsImpl {
    /**
     * Initialize a new instance of the class FlowLogs class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all flow log resources for the specified Network Watcher.
     * @param resourceGroupName The name of the resource group containing Network Watcher.
     * @param networkWatcherName The name of the Network Watcher resource.
     * @param options The options parameters.
     */
    list(resourceGroupName, networkWatcherName, options) {
        const iter = this.listPagingAll(resourceGroupName, networkWatcherName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, networkWatcherName, options);
            }
        };
    }
    listPagingPage(resourceGroupName, networkWatcherName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, networkWatcherName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, networkWatcherName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceGroupName, networkWatcherName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, networkWatcherName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Create or update a flow log for the specified network security group.
     * @param resourceGroupName The name of the resource group.
     * @param networkWatcherName The name of the network watcher.
     * @param flowLogName The name of the flow log.
     * @param parameters Parameters that define the create or update flow log resource.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, networkWatcherName, flowLogName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                networkWatcherName,
                flowLogName,
                parameters,
                options
            }, createOrUpdateOperationSpec$y);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
        });
    }
    /**
     * Create or update a flow log for the specified network security group.
     * @param resourceGroupName The name of the resource group.
     * @param networkWatcherName The name of the network watcher.
     * @param flowLogName The name of the flow log.
     * @param parameters Parameters that define the create or update flow log resource.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, networkWatcherName, flowLogName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, networkWatcherName, flowLogName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Update tags of the specified flow log.
     * @param resourceGroupName The name of the resource group.
     * @param networkWatcherName The name of the network watcher.
     * @param flowLogName The name of the flow log.
     * @param parameters Parameters supplied to update flow log tags.
     * @param options The options parameters.
     */
    updateTags(resourceGroupName, networkWatcherName, flowLogName, parameters, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            networkWatcherName,
            flowLogName,
            parameters,
            options
        }, updateTagsOperationSpec$k);
    }
    /**
     * Gets a flow log resource by name.
     * @param resourceGroupName The name of the resource group.
     * @param networkWatcherName The name of the network watcher.
     * @param flowLogName The name of the flow log resource.
     * @param options The options parameters.
     */
    get(resourceGroupName, networkWatcherName, flowLogName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, networkWatcherName, flowLogName, options }, getOperationSpec$L);
    }
    /**
     * Deletes the specified flow log resource.
     * @param resourceGroupName The name of the resource group.
     * @param networkWatcherName The name of the network watcher.
     * @param flowLogName The name of the flow log resource.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, networkWatcherName, flowLogName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, networkWatcherName, flowLogName, options }, deleteOperationSpec$y);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Deletes the specified flow log resource.
     * @param resourceGroupName The name of the resource group.
     * @param networkWatcherName The name of the network watcher.
     * @param flowLogName The name of the flow log resource.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, networkWatcherName, flowLogName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, networkWatcherName, flowLogName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Lists all flow log resources for the specified Network Watcher.
     * @param resourceGroupName The name of the resource group containing Network Watcher.
     * @param networkWatcherName The name of the Network Watcher resource.
     * @param options The options parameters.
     */
    _list(resourceGroupName, networkWatcherName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, networkWatcherName, options }, listOperationSpec$T);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group containing Network Watcher.
     * @param networkWatcherName The name of the Network Watcher resource.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, networkWatcherName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, networkWatcherName, nextLink, options }, listNextOperationSpec$N);
    }
}
// Operation Specifications
const serializer$X = coreClient.createSerializer(Mappers, /* isXml */ false);
const createOrUpdateOperationSpec$y = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkWatchers/{networkWatcherName}/flowLogs/{flowLogName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: FlowLog
        },
        201: {
            bodyMapper: FlowLog
        },
        202: {
            bodyMapper: FlowLog
        },
        204: {
            bodyMapper: FlowLog
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters47,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkWatcherName,
        flowLogName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$X
};
const updateTagsOperationSpec$k = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkWatchers/{networkWatcherName}/flowLogs/{flowLogName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: FlowLog
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkWatcherName,
        flowLogName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$X
};
const getOperationSpec$L = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkWatchers/{networkWatcherName}/flowLogs/{flowLogName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: FlowLog
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkWatcherName,
        flowLogName
    ],
    headerParameters: [accept],
    serializer: serializer$X
};
const deleteOperationSpec$y = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkWatchers/{networkWatcherName}/flowLogs/{flowLogName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkWatcherName,
        flowLogName
    ],
    headerParameters: [accept],
    serializer: serializer$X
};
const listOperationSpec$T = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkWatchers/{networkWatcherName}/flowLogs",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: FlowLogListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkWatcherName
    ],
    headerParameters: [accept],
    serializer: serializer$X
};
const listNextOperationSpec$N = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: FlowLogListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        networkWatcherName
    ],
    headerParameters: [accept],
    serializer: serializer$X
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Operations operations. */
class OperationsImpl {
    /**
     * Initialize a new instance of the class Operations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all of the available Network Rest API operations.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(options);
            }
        };
    }
    listPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all of the available Network Rest API operations.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$U);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$O);
    }
}
// Operation Specifications
const serializer$Y = coreClient.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$U = {
    path: "/providers/Microsoft.Network/operations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: OperationListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host],
    headerParameters: [accept],
    serializer: serializer$Y
};
const listNextOperationSpec$O = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: OperationListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, nextLink],
    headerParameters: [accept],
    serializer: serializer$Y
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing PrivateEndpoints operations. */
class PrivateEndpointsImpl {
    /**
     * Initialize a new instance of the class PrivateEndpoints class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all private endpoints in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    list(resourceGroupName, options) {
        const iter = this.listPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, options);
            }
        };
    }
    listPagingPage(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets all private endpoints in a subscription.
     * @param options The options parameters.
     */
    listBySubscription(options) {
        const iter = this.listBySubscriptionPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listBySubscriptionPagingPage(options);
            }
        };
    }
    listBySubscriptionPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingPage_1() {
            let result = yield tslib.__await(this._listBySubscription(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listBySubscriptionNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listBySubscriptionPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listBySubscriptionPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Deletes the specified private endpoint.
     * @param resourceGroupName The name of the resource group.
     * @param privateEndpointName The name of the private endpoint.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, privateEndpointName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, privateEndpointName, options }, deleteOperationSpec$z);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Deletes the specified private endpoint.
     * @param resourceGroupName The name of the resource group.
     * @param privateEndpointName The name of the private endpoint.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, privateEndpointName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, privateEndpointName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the specified private endpoint by resource group.
     * @param resourceGroupName The name of the resource group.
     * @param privateEndpointName The name of the private endpoint.
     * @param options The options parameters.
     */
    get(resourceGroupName, privateEndpointName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, privateEndpointName, options }, getOperationSpec$M);
    }
    /**
     * Creates or updates an private endpoint in the specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param privateEndpointName The name of the private endpoint.
     * @param parameters Parameters supplied to the create or update private endpoint operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, privateEndpointName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, privateEndpointName, parameters, options }, createOrUpdateOperationSpec$z);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
        });
    }
    /**
     * Creates or updates an private endpoint in the specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param privateEndpointName The name of the private endpoint.
     * @param parameters Parameters supplied to the create or update private endpoint operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, privateEndpointName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, privateEndpointName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets all private endpoints in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    _list(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listOperationSpec$V);
    }
    /**
     * Gets all private endpoints in a subscription.
     * @param options The options parameters.
     */
    _listBySubscription(options) {
        return this.client.sendOperationRequest({ options }, listBySubscriptionOperationSpec$1);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listNextOperationSpec$P);
    }
    /**
     * ListBySubscriptionNext
     * @param nextLink The nextLink from the previous successful call to the ListBySubscription method.
     * @param options The options parameters.
     */
    _listBySubscriptionNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listBySubscriptionNextOperationSpec$1);
    }
}
// Operation Specifications
const serializer$Z = coreClient.createSerializer(Mappers, /* isXml */ false);
const deleteOperationSpec$z = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateEndpoints/{privateEndpointName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        privateEndpointName
    ],
    headerParameters: [accept],
    serializer: serializer$Z
};
const getOperationSpec$M = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateEndpoints/{privateEndpointName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateEndpoint
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [apiVersion, expand],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        privateEndpointName
    ],
    headerParameters: [accept],
    serializer: serializer$Z
};
const createOrUpdateOperationSpec$z = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateEndpoints/{privateEndpointName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: PrivateEndpoint
        },
        201: {
            bodyMapper: PrivateEndpoint
        },
        202: {
            bodyMapper: PrivateEndpoint
        },
        204: {
            bodyMapper: PrivateEndpoint
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    requestBody: parameters48,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        privateEndpointName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$Z
};
const listOperationSpec$V = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateEndpoints",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateEndpointListResult
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$Z
};
const listBySubscriptionOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/privateEndpoints",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateEndpointListResult
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$Z
};
const listNextOperationSpec$P = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateEndpointListResult
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$Z
};
const listBySubscriptionNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateEndpointListResult
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$Z
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing AvailablePrivateEndpointTypes operations. */
class AvailablePrivateEndpointTypesImpl {
    /**
     * Initialize a new instance of the class AvailablePrivateEndpointTypes class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Returns all of the resource types that can be linked to a Private Endpoint in this subscription in
     * this region.
     * @param location The location of the domain name.
     * @param options The options parameters.
     */
    list(location, options) {
        const iter = this.listPagingAll(location, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(location, options);
            }
        };
    }
    listPagingPage(location, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(location, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(location, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(location, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(location, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Returns all of the resource types that can be linked to a Private Endpoint in this subscription in
     * this region.
     * @param location The location of the domain name.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    listByResourceGroup(location, resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(location, resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByResourceGroupPagingPage(location, resourceGroupName, options);
            }
        };
    }
    listByResourceGroupPagingPage(location, resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result = yield tslib.__await(this._listByResourceGroup(location, resourceGroupName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(location, resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByResourceGroupPagingAll(location, resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupPagingPage(location, resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Returns all of the resource types that can be linked to a Private Endpoint in this subscription in
     * this region.
     * @param location The location of the domain name.
     * @param options The options parameters.
     */
    _list(location, options) {
        return this.client.sendOperationRequest({ location, options }, listOperationSpec$W);
    }
    /**
     * Returns all of the resource types that can be linked to a Private Endpoint in this subscription in
     * this region.
     * @param location The location of the domain name.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    _listByResourceGroup(location, resourceGroupName, options) {
        return this.client.sendOperationRequest({ location, resourceGroupName, options }, listByResourceGroupOperationSpec$8);
    }
    /**
     * ListNext
     * @param location The location of the domain name.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(location, nextLink, options) {
        return this.client.sendOperationRequest({ location, nextLink, options }, listNextOperationSpec$Q);
    }
    /**
     * ListByResourceGroupNext
     * @param location The location of the domain name.
     * @param resourceGroupName The name of the resource group.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(location, resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ location, resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec$8);
    }
}
// Operation Specifications
const serializer$_ = coreClient.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$W = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/locations/{location}/availablePrivateEndpointTypes",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AvailablePrivateEndpointTypesResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        location
    ],
    headerParameters: [accept],
    serializer: serializer$_
};
const listByResourceGroupOperationSpec$8 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/locations/{location}/availablePrivateEndpointTypes",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AvailablePrivateEndpointTypesResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        location
    ],
    headerParameters: [accept],
    serializer: serializer$_
};
const listNextOperationSpec$Q = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AvailablePrivateEndpointTypesResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
        location
    ],
    headerParameters: [accept],
    serializer: serializer$_
};
const listByResourceGroupNextOperationSpec$8 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AvailablePrivateEndpointTypesResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        location
    ],
    headerParameters: [accept],
    serializer: serializer$_
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing PrivateDnsZoneGroups operations. */
class PrivateDnsZoneGroupsImpl {
    /**
     * Initialize a new instance of the class PrivateDnsZoneGroups class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all private dns zone groups in a private endpoint.
     * @param privateEndpointName The name of the private endpoint.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    list(privateEndpointName, resourceGroupName, options) {
        const iter = this.listPagingAll(privateEndpointName, resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(privateEndpointName, resourceGroupName, options);
            }
        };
    }
    listPagingPage(privateEndpointName, resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(privateEndpointName, resourceGroupName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(privateEndpointName, resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(privateEndpointName, resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(privateEndpointName, resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Deletes the specified private dns zone group.
     * @param resourceGroupName The name of the resource group.
     * @param privateEndpointName The name of the private endpoint.
     * @param privateDnsZoneGroupName The name of the private dns zone group.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, privateEndpointName, privateDnsZoneGroupName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                privateEndpointName,
                privateDnsZoneGroupName,
                options
            }, deleteOperationSpec$A);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Deletes the specified private dns zone group.
     * @param resourceGroupName The name of the resource group.
     * @param privateEndpointName The name of the private endpoint.
     * @param privateDnsZoneGroupName The name of the private dns zone group.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, privateEndpointName, privateDnsZoneGroupName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, privateEndpointName, privateDnsZoneGroupName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the private dns zone group resource by specified private dns zone group name.
     * @param resourceGroupName The name of the resource group.
     * @param privateEndpointName The name of the private endpoint.
     * @param privateDnsZoneGroupName The name of the private dns zone group.
     * @param options The options parameters.
     */
    get(resourceGroupName, privateEndpointName, privateDnsZoneGroupName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            privateEndpointName,
            privateDnsZoneGroupName,
            options
        }, getOperationSpec$N);
    }
    /**
     * Creates or updates a private dns zone group in the specified private endpoint.
     * @param resourceGroupName The name of the resource group.
     * @param privateEndpointName The name of the private endpoint.
     * @param privateDnsZoneGroupName The name of the private dns zone group.
     * @param parameters Parameters supplied to the create or update private dns zone group operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, privateEndpointName, privateDnsZoneGroupName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                privateEndpointName,
                privateDnsZoneGroupName,
                parameters,
                options
            }, createOrUpdateOperationSpec$A);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
        });
    }
    /**
     * Creates or updates a private dns zone group in the specified private endpoint.
     * @param resourceGroupName The name of the resource group.
     * @param privateEndpointName The name of the private endpoint.
     * @param privateDnsZoneGroupName The name of the private dns zone group.
     * @param parameters Parameters supplied to the create or update private dns zone group operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, privateEndpointName, privateDnsZoneGroupName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, privateEndpointName, privateDnsZoneGroupName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets all private dns zone groups in a private endpoint.
     * @param privateEndpointName The name of the private endpoint.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    _list(privateEndpointName, resourceGroupName, options) {
        return this.client.sendOperationRequest({ privateEndpointName, resourceGroupName, options }, listOperationSpec$X);
    }
    /**
     * ListNext
     * @param privateEndpointName The name of the private endpoint.
     * @param resourceGroupName The name of the resource group.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(privateEndpointName, resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ privateEndpointName, resourceGroupName, nextLink, options }, listNextOperationSpec$R);
    }
}
// Operation Specifications
const serializer$$ = coreClient.createSerializer(Mappers, /* isXml */ false);
const deleteOperationSpec$A = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateEndpoints/{privateEndpointName}/privateDnsZoneGroups/{privateDnsZoneGroupName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        privateEndpointName,
        privateDnsZoneGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$$
};
const getOperationSpec$N = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateEndpoints/{privateEndpointName}/privateDnsZoneGroups/{privateDnsZoneGroupName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateDnsZoneGroup
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        privateEndpointName,
        privateDnsZoneGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$$
};
const createOrUpdateOperationSpec$A = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateEndpoints/{privateEndpointName}/privateDnsZoneGroups/{privateDnsZoneGroupName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: PrivateDnsZoneGroup
        },
        201: {
            bodyMapper: PrivateDnsZoneGroup
        },
        202: {
            bodyMapper: PrivateDnsZoneGroup
        },
        204: {
            bodyMapper: PrivateDnsZoneGroup
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters49,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        privateEndpointName,
        privateDnsZoneGroupName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$$
};
const listOperationSpec$X = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateEndpoints/{privateEndpointName}/privateDnsZoneGroups",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateDnsZoneGroupListResult
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        privateEndpointName
    ],
    headerParameters: [accept],
    serializer: serializer$$
};
const listNextOperationSpec$R = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateDnsZoneGroupListResult
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        privateEndpointName
    ],
    headerParameters: [accept],
    serializer: serializer$$
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing PrivateLinkServices operations. */
class PrivateLinkServicesImpl {
    /**
     * Initialize a new instance of the class PrivateLinkServices class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all private link services in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    list(resourceGroupName, options) {
        const iter = this.listPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, options);
            }
        };
    }
    listPagingPage(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets all private link service in a subscription.
     * @param options The options parameters.
     */
    listBySubscription(options) {
        const iter = this.listBySubscriptionPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listBySubscriptionPagingPage(options);
            }
        };
    }
    listBySubscriptionPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingPage_1() {
            let result = yield tslib.__await(this._listBySubscription(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listBySubscriptionNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listBySubscriptionPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listBySubscriptionPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Gets all private end point connections for a specific private link service.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the private link service.
     * @param options The options parameters.
     */
    listPrivateEndpointConnections(resourceGroupName, serviceName, options) {
        const iter = this.listPrivateEndpointConnectionsPagingAll(resourceGroupName, serviceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPrivateEndpointConnectionsPagingPage(resourceGroupName, serviceName, options);
            }
        };
    }
    listPrivateEndpointConnectionsPagingPage(resourceGroupName, serviceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPrivateEndpointConnectionsPagingPage_1() {
            let result = yield tslib.__await(this._listPrivateEndpointConnections(resourceGroupName, serviceName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listPrivateEndpointConnectionsNext(resourceGroupName, serviceName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPrivateEndpointConnectionsPagingAll(resourceGroupName, serviceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPrivateEndpointConnectionsPagingAll_1() {
            var e_3, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPrivateEndpointConnectionsPagingPage(resourceGroupName, serviceName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_3) throw e_3.error; }
            }
        });
    }
    /**
     * Returns all of the private link service ids that can be linked to a Private Endpoint with auto
     * approved in this subscription in this region.
     * @param location The location of the domain name.
     * @param options The options parameters.
     */
    listAutoApprovedPrivateLinkServices(location, options) {
        const iter = this.listAutoApprovedPrivateLinkServicesPagingAll(location, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listAutoApprovedPrivateLinkServicesPagingPage(location, options);
            }
        };
    }
    listAutoApprovedPrivateLinkServicesPagingPage(location, options) {
        return tslib.__asyncGenerator(this, arguments, function* listAutoApprovedPrivateLinkServicesPagingPage_1() {
            let result = yield tslib.__await(this._listAutoApprovedPrivateLinkServices(location, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listAutoApprovedPrivateLinkServicesNext(location, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listAutoApprovedPrivateLinkServicesPagingAll(location, options) {
        return tslib.__asyncGenerator(this, arguments, function* listAutoApprovedPrivateLinkServicesPagingAll_1() {
            var e_4, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listAutoApprovedPrivateLinkServicesPagingPage(location, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_4) throw e_4.error; }
            }
        });
    }
    /**
     * Returns all of the private link service ids that can be linked to a Private Endpoint with auto
     * approved in this subscription in this region.
     * @param location The location of the domain name.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    listAutoApprovedPrivateLinkServicesByResourceGroup(location, resourceGroupName, options) {
        const iter = this.listAutoApprovedPrivateLinkServicesByResourceGroupPagingAll(location, resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listAutoApprovedPrivateLinkServicesByResourceGroupPagingPage(location, resourceGroupName, options);
            }
        };
    }
    listAutoApprovedPrivateLinkServicesByResourceGroupPagingPage(location, resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listAutoApprovedPrivateLinkServicesByResourceGroupPagingPage_1() {
            let result = yield tslib.__await(this._listAutoApprovedPrivateLinkServicesByResourceGroup(location, resourceGroupName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listAutoApprovedPrivateLinkServicesByResourceGroupNext(location, resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listAutoApprovedPrivateLinkServicesByResourceGroupPagingAll(location, resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listAutoApprovedPrivateLinkServicesByResourceGroupPagingAll_1() {
            var e_5, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listAutoApprovedPrivateLinkServicesByResourceGroupPagingPage(location, resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_5_1) { e_5 = { error: e_5_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_5) throw e_5.error; }
            }
        });
    }
    /**
     * Deletes the specified private link service.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the private link service.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, serviceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, serviceName, options }, deleteOperationSpec$B);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Deletes the specified private link service.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the private link service.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, serviceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, serviceName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the specified private link service by resource group.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the private link service.
     * @param options The options parameters.
     */
    get(resourceGroupName, serviceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, options }, getOperationSpec$O);
    }
    /**
     * Creates or updates an private link service in the specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the private link service.
     * @param parameters Parameters supplied to the create or update private link service operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, serviceName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, serviceName, parameters, options }, createOrUpdateOperationSpec$B);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
        });
    }
    /**
     * Creates or updates an private link service in the specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the private link service.
     * @param parameters Parameters supplied to the create or update private link service operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, serviceName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, serviceName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets all private link services in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    _list(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listOperationSpec$Y);
    }
    /**
     * Gets all private link service in a subscription.
     * @param options The options parameters.
     */
    _listBySubscription(options) {
        return this.client.sendOperationRequest({ options }, listBySubscriptionOperationSpec$2);
    }
    /**
     * Get the specific private end point connection by specific private link service in the resource
     * group.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the private link service.
     * @param peConnectionName The name of the private end point connection.
     * @param options The options parameters.
     */
    getPrivateEndpointConnection(resourceGroupName, serviceName, peConnectionName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, peConnectionName, options }, getPrivateEndpointConnectionOperationSpec);
    }
    /**
     * Approve or reject private end point connection for a private link service in a subscription.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the private link service.
     * @param peConnectionName The name of the private end point connection.
     * @param parameters Parameters supplied to approve or reject the private end point connection.
     * @param options The options parameters.
     */
    updatePrivateEndpointConnection(resourceGroupName, serviceName, peConnectionName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, peConnectionName, parameters, options }, updatePrivateEndpointConnectionOperationSpec);
    }
    /**
     * Delete private end point connection for a private link service in a subscription.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the private link service.
     * @param peConnectionName The name of the private end point connection.
     * @param options The options parameters.
     */
    beginDeletePrivateEndpointConnection(resourceGroupName, serviceName, peConnectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, serviceName, peConnectionName, options }, deletePrivateEndpointConnectionOperationSpec);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Delete private end point connection for a private link service in a subscription.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the private link service.
     * @param peConnectionName The name of the private end point connection.
     * @param options The options parameters.
     */
    beginDeletePrivateEndpointConnectionAndWait(resourceGroupName, serviceName, peConnectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDeletePrivateEndpointConnection(resourceGroupName, serviceName, peConnectionName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets all private end point connections for a specific private link service.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the private link service.
     * @param options The options parameters.
     */
    _listPrivateEndpointConnections(resourceGroupName, serviceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, options }, listPrivateEndpointConnectionsOperationSpec);
    }
    /**
     * Checks whether the subscription is visible to private link service.
     * @param location The location of the domain name.
     * @param parameters The request body of CheckPrivateLinkService API call.
     * @param options The options parameters.
     */
    beginCheckPrivateLinkServiceVisibility(location, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { location, parameters, options }, checkPrivateLinkServiceVisibilityOperationSpec);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Checks whether the subscription is visible to private link service.
     * @param location The location of the domain name.
     * @param parameters The request body of CheckPrivateLinkService API call.
     * @param options The options parameters.
     */
    beginCheckPrivateLinkServiceVisibilityAndWait(location, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCheckPrivateLinkServiceVisibility(location, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Checks whether the subscription is visible to private link service in the specified resource group.
     * @param location The location of the domain name.
     * @param resourceGroupName The name of the resource group.
     * @param parameters The request body of CheckPrivateLinkService API call.
     * @param options The options parameters.
     */
    beginCheckPrivateLinkServiceVisibilityByResourceGroup(location, resourceGroupName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { location, resourceGroupName, parameters, options }, checkPrivateLinkServiceVisibilityByResourceGroupOperationSpec);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Checks whether the subscription is visible to private link service in the specified resource group.
     * @param location The location of the domain name.
     * @param resourceGroupName The name of the resource group.
     * @param parameters The request body of CheckPrivateLinkService API call.
     * @param options The options parameters.
     */
    beginCheckPrivateLinkServiceVisibilityByResourceGroupAndWait(location, resourceGroupName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCheckPrivateLinkServiceVisibilityByResourceGroup(location, resourceGroupName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Returns all of the private link service ids that can be linked to a Private Endpoint with auto
     * approved in this subscription in this region.
     * @param location The location of the domain name.
     * @param options The options parameters.
     */
    _listAutoApprovedPrivateLinkServices(location, options) {
        return this.client.sendOperationRequest({ location, options }, listAutoApprovedPrivateLinkServicesOperationSpec);
    }
    /**
     * Returns all of the private link service ids that can be linked to a Private Endpoint with auto
     * approved in this subscription in this region.
     * @param location The location of the domain name.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    _listAutoApprovedPrivateLinkServicesByResourceGroup(location, resourceGroupName, options) {
        return this.client.sendOperationRequest({ location, resourceGroupName, options }, listAutoApprovedPrivateLinkServicesByResourceGroupOperationSpec);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listNextOperationSpec$S);
    }
    /**
     * ListBySubscriptionNext
     * @param nextLink The nextLink from the previous successful call to the ListBySubscription method.
     * @param options The options parameters.
     */
    _listBySubscriptionNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listBySubscriptionNextOperationSpec$2);
    }
    /**
     * ListPrivateEndpointConnectionsNext
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the private link service.
     * @param nextLink The nextLink from the previous successful call to the ListPrivateEndpointConnections
     *                 method.
     * @param options The options parameters.
     */
    _listPrivateEndpointConnectionsNext(resourceGroupName, serviceName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, nextLink, options }, listPrivateEndpointConnectionsNextOperationSpec);
    }
    /**
     * ListAutoApprovedPrivateLinkServicesNext
     * @param location The location of the domain name.
     * @param nextLink The nextLink from the previous successful call to the
     *                 ListAutoApprovedPrivateLinkServices method.
     * @param options The options parameters.
     */
    _listAutoApprovedPrivateLinkServicesNext(location, nextLink, options) {
        return this.client.sendOperationRequest({ location, nextLink, options }, listAutoApprovedPrivateLinkServicesNextOperationSpec);
    }
    /**
     * ListAutoApprovedPrivateLinkServicesByResourceGroupNext
     * @param location The location of the domain name.
     * @param resourceGroupName The name of the resource group.
     * @param nextLink The nextLink from the previous successful call to the
     *                 ListAutoApprovedPrivateLinkServicesByResourceGroup method.
     * @param options The options parameters.
     */
    _listAutoApprovedPrivateLinkServicesByResourceGroupNext(location, resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ location, resourceGroupName, nextLink, options }, listAutoApprovedPrivateLinkServicesByResourceGroupNextOperationSpec);
    }
}
// Operation Specifications
const serializer$10 = coreClient.createSerializer(Mappers, /* isXml */ false);
const deleteOperationSpec$B = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateLinkServices/{serviceName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        serviceName
    ],
    headerParameters: [accept],
    serializer: serializer$10
};
const getOperationSpec$O = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateLinkServices/{serviceName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateLinkService
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [apiVersion, expand],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        serviceName
    ],
    headerParameters: [accept],
    serializer: serializer$10
};
const createOrUpdateOperationSpec$B = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateLinkServices/{serviceName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: PrivateLinkService
        },
        201: {
            bodyMapper: PrivateLinkService
        },
        202: {
            bodyMapper: PrivateLinkService
        },
        204: {
            bodyMapper: PrivateLinkService
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    requestBody: parameters50,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        serviceName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$10
};
const listOperationSpec$Y = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateLinkServices",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateLinkServiceListResult
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$10
};
const listBySubscriptionOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/privateLinkServices",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateLinkServiceListResult
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$10
};
const getPrivateEndpointConnectionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateLinkServices/{serviceName}/privateEndpointConnections/{peConnectionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateEndpointConnection
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [apiVersion, expand],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        serviceName,
        peConnectionName
    ],
    headerParameters: [accept],
    serializer: serializer$10
};
const updatePrivateEndpointConnectionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateLinkServices/{serviceName}/privateEndpointConnections/{peConnectionName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: PrivateEndpointConnection
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    requestBody: parameters51,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        serviceName,
        peConnectionName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$10
};
const deletePrivateEndpointConnectionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateLinkServices/{serviceName}/privateEndpointConnections/{peConnectionName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        serviceName,
        peConnectionName
    ],
    headerParameters: [accept],
    serializer: serializer$10
};
const listPrivateEndpointConnectionsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateLinkServices/{serviceName}/privateEndpointConnections",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateEndpointConnectionListResult
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        serviceName
    ],
    headerParameters: [accept],
    serializer: serializer$10
};
const checkPrivateLinkServiceVisibilityOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/locations/{location}/checkPrivateLinkServiceVisibility",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: PrivateLinkServiceVisibility
        },
        201: {
            bodyMapper: PrivateLinkServiceVisibility
        },
        202: {
            bodyMapper: PrivateLinkServiceVisibility
        },
        204: {
            bodyMapper: PrivateLinkServiceVisibility
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters52,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        location
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$10
};
const checkPrivateLinkServiceVisibilityByResourceGroupOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/locations/{location}/checkPrivateLinkServiceVisibility",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: PrivateLinkServiceVisibility
        },
        201: {
            bodyMapper: PrivateLinkServiceVisibility
        },
        202: {
            bodyMapper: PrivateLinkServiceVisibility
        },
        204: {
            bodyMapper: PrivateLinkServiceVisibility
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters52,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        location
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$10
};
const listAutoApprovedPrivateLinkServicesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/locations/{location}/autoApprovedPrivateLinkServices",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AutoApprovedPrivateLinkServicesResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        location
    ],
    headerParameters: [accept],
    serializer: serializer$10
};
const listAutoApprovedPrivateLinkServicesByResourceGroupOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/locations/{location}/autoApprovedPrivateLinkServices",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AutoApprovedPrivateLinkServicesResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        location
    ],
    headerParameters: [accept],
    serializer: serializer$10
};
const listNextOperationSpec$S = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateLinkServiceListResult
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$10
};
const listBySubscriptionNextOperationSpec$2 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateLinkServiceListResult
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$10
};
const listPrivateEndpointConnectionsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateEndpointConnectionListResult
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        serviceName
    ],
    headerParameters: [accept],
    serializer: serializer$10
};
const listAutoApprovedPrivateLinkServicesNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AutoApprovedPrivateLinkServicesResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
        location
    ],
    headerParameters: [accept],
    serializer: serializer$10
};
const listAutoApprovedPrivateLinkServicesByResourceGroupNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AutoApprovedPrivateLinkServicesResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        location
    ],
    headerParameters: [accept],
    serializer: serializer$10
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing PublicIPPrefixes operations. */
class PublicIPPrefixesImpl {
    /**
     * Initialize a new instance of the class PublicIPPrefixes class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all the public IP prefixes in a subscription.
     * @param options The options parameters.
     */
    listAll(options) {
        const iter = this.listAllPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listAllPagingPage(options);
            }
        };
    }
    listAllPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listAllPagingPage_1() {
            let result = yield tslib.__await(this._listAll(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listAllNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listAllPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listAllPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listAllPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets all public IP prefixes in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    list(resourceGroupName, options) {
        const iter = this.listPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, options);
            }
        };
    }
    listPagingPage(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Deletes the specified public IP prefix.
     * @param resourceGroupName The name of the resource group.
     * @param publicIpPrefixName The name of the PublicIpPrefix.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, publicIpPrefixName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, publicIpPrefixName, options }, deleteOperationSpec$C);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Deletes the specified public IP prefix.
     * @param resourceGroupName The name of the resource group.
     * @param publicIpPrefixName The name of the PublicIpPrefix.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, publicIpPrefixName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, publicIpPrefixName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the specified public IP prefix in a specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param publicIpPrefixName The name of the public IP prefix.
     * @param options The options parameters.
     */
    get(resourceGroupName, publicIpPrefixName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, publicIpPrefixName, options }, getOperationSpec$P);
    }
    /**
     * Creates or updates a static or dynamic public IP prefix.
     * @param resourceGroupName The name of the resource group.
     * @param publicIpPrefixName The name of the public IP prefix.
     * @param parameters Parameters supplied to the create or update public IP prefix operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, publicIpPrefixName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, publicIpPrefixName, parameters, options }, createOrUpdateOperationSpec$C);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Creates or updates a static or dynamic public IP prefix.
     * @param resourceGroupName The name of the resource group.
     * @param publicIpPrefixName The name of the public IP prefix.
     * @param parameters Parameters supplied to the create or update public IP prefix operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, publicIpPrefixName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, publicIpPrefixName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates public IP prefix tags.
     * @param resourceGroupName The name of the resource group.
     * @param publicIpPrefixName The name of the public IP prefix.
     * @param parameters Parameters supplied to update public IP prefix tags.
     * @param options The options parameters.
     */
    updateTags(resourceGroupName, publicIpPrefixName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, publicIpPrefixName, parameters, options }, updateTagsOperationSpec$l);
    }
    /**
     * Gets all the public IP prefixes in a subscription.
     * @param options The options parameters.
     */
    _listAll(options) {
        return this.client.sendOperationRequest({ options }, listAllOperationSpec$f);
    }
    /**
     * Gets all public IP prefixes in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    _list(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listOperationSpec$Z);
    }
    /**
     * ListAllNext
     * @param nextLink The nextLink from the previous successful call to the ListAll method.
     * @param options The options parameters.
     */
    _listAllNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listAllNextOperationSpec$e);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listNextOperationSpec$T);
    }
}
// Operation Specifications
const serializer$11 = coreClient.createSerializer(Mappers, /* isXml */ false);
const deleteOperationSpec$C = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/publicIPPrefixes/{publicIpPrefixName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        publicIpPrefixName
    ],
    headerParameters: [accept],
    serializer: serializer$11
};
const getOperationSpec$P = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/publicIPPrefixes/{publicIpPrefixName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PublicIPPrefix
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, expand],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        publicIpPrefixName
    ],
    headerParameters: [accept],
    serializer: serializer$11
};
const createOrUpdateOperationSpec$C = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/publicIPPrefixes/{publicIpPrefixName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: PublicIPPrefix
        },
        201: {
            bodyMapper: PublicIPPrefix
        },
        202: {
            bodyMapper: PublicIPPrefix
        },
        204: {
            bodyMapper: PublicIPPrefix
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters53,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        publicIpPrefixName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$11
};
const updateTagsOperationSpec$l = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/publicIPPrefixes/{publicIpPrefixName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: PublicIPPrefix
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        publicIpPrefixName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$11
};
const listAllOperationSpec$f = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/publicIPPrefixes",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PublicIPPrefixListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$11
};
const listOperationSpec$Z = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/publicIPPrefixes",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PublicIPPrefixListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$11
};
const listAllNextOperationSpec$e = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PublicIPPrefixListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$11
};
const listNextOperationSpec$T = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PublicIPPrefixListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$11
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing RouteFilters operations. */
class RouteFiltersImpl {
    /**
     * Initialize a new instance of the class RouteFilters class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all route filters in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByResourceGroupPagingPage(resourceGroupName, options);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets all route filters in a subscription.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(options);
            }
        };
    }
    listPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Deletes the specified route filter.
     * @param resourceGroupName The name of the resource group.
     * @param routeFilterName The name of the route filter.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, routeFilterName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, routeFilterName, options }, deleteOperationSpec$D);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Deletes the specified route filter.
     * @param resourceGroupName The name of the resource group.
     * @param routeFilterName The name of the route filter.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, routeFilterName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, routeFilterName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the specified route filter.
     * @param resourceGroupName The name of the resource group.
     * @param routeFilterName The name of the route filter.
     * @param options The options parameters.
     */
    get(resourceGroupName, routeFilterName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, routeFilterName, options }, getOperationSpec$Q);
    }
    /**
     * Creates or updates a route filter in a specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param routeFilterName The name of the route filter.
     * @param routeFilterParameters Parameters supplied to the create or update route filter operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, routeFilterName, routeFilterParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, routeFilterName, routeFilterParameters, options }, createOrUpdateOperationSpec$D);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
        });
    }
    /**
     * Creates or updates a route filter in a specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param routeFilterName The name of the route filter.
     * @param routeFilterParameters Parameters supplied to the create or update route filter operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, routeFilterName, routeFilterParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, routeFilterName, routeFilterParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates tags of a route filter.
     * @param resourceGroupName The name of the resource group.
     * @param routeFilterName The name of the route filter.
     * @param parameters Parameters supplied to update route filter tags.
     * @param options The options parameters.
     */
    updateTags(resourceGroupName, routeFilterName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, routeFilterName, parameters, options }, updateTagsOperationSpec$m);
    }
    /**
     * Gets all route filters in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec$9);
    }
    /**
     * Gets all route filters in a subscription.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$_);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The name of the resource group.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec$9);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$U);
    }
}
// Operation Specifications
const serializer$12 = coreClient.createSerializer(Mappers, /* isXml */ false);
const deleteOperationSpec$D = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/routeFilters/{routeFilterName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        routeFilterName
    ],
    headerParameters: [accept],
    serializer: serializer$12
};
const getOperationSpec$Q = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/routeFilters/{routeFilterName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RouteFilter
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, expand],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        routeFilterName
    ],
    headerParameters: [accept],
    serializer: serializer$12
};
const createOrUpdateOperationSpec$D = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/routeFilters/{routeFilterName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: RouteFilter
        },
        201: {
            bodyMapper: RouteFilter
        },
        202: {
            bodyMapper: RouteFilter
        },
        204: {
            bodyMapper: RouteFilter
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: routeFilterParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        routeFilterName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$12
};
const updateTagsOperationSpec$m = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/routeFilters/{routeFilterName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: RouteFilter
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        routeFilterName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$12
};
const listByResourceGroupOperationSpec$9 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/routeFilters",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RouteFilterListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$12
};
const listOperationSpec$_ = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/routeFilters",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RouteFilterListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$12
};
const listByResourceGroupNextOperationSpec$9 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RouteFilterListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$12
};
const listNextOperationSpec$U = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RouteFilterListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$12
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing RouteFilterRules operations. */
class RouteFilterRulesImpl {
    /**
     * Initialize a new instance of the class RouteFilterRules class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all RouteFilterRules in a route filter.
     * @param resourceGroupName The name of the resource group.
     * @param routeFilterName The name of the route filter.
     * @param options The options parameters.
     */
    listByRouteFilter(resourceGroupName, routeFilterName, options) {
        const iter = this.listByRouteFilterPagingAll(resourceGroupName, routeFilterName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByRouteFilterPagingPage(resourceGroupName, routeFilterName, options);
            }
        };
    }
    listByRouteFilterPagingPage(resourceGroupName, routeFilterName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByRouteFilterPagingPage_1() {
            let result = yield tslib.__await(this._listByRouteFilter(resourceGroupName, routeFilterName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByRouteFilterNext(resourceGroupName, routeFilterName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByRouteFilterPagingAll(resourceGroupName, routeFilterName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByRouteFilterPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByRouteFilterPagingPage(resourceGroupName, routeFilterName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Deletes the specified rule from a route filter.
     * @param resourceGroupName The name of the resource group.
     * @param routeFilterName The name of the route filter.
     * @param ruleName The name of the rule.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, routeFilterName, ruleName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, routeFilterName, ruleName, options }, deleteOperationSpec$E);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Deletes the specified rule from a route filter.
     * @param resourceGroupName The name of the resource group.
     * @param routeFilterName The name of the route filter.
     * @param ruleName The name of the rule.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, routeFilterName, ruleName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, routeFilterName, ruleName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the specified rule from a route filter.
     * @param resourceGroupName The name of the resource group.
     * @param routeFilterName The name of the route filter.
     * @param ruleName The name of the rule.
     * @param options The options parameters.
     */
    get(resourceGroupName, routeFilterName, ruleName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, routeFilterName, ruleName, options }, getOperationSpec$R);
    }
    /**
     * Creates or updates a route in the specified route filter.
     * @param resourceGroupName The name of the resource group.
     * @param routeFilterName The name of the route filter.
     * @param ruleName The name of the route filter rule.
     * @param routeFilterRuleParameters Parameters supplied to the create or update route filter rule
     *                                  operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, routeFilterName, ruleName, routeFilterRuleParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                routeFilterName,
                ruleName,
                routeFilterRuleParameters,
                options
            }, createOrUpdateOperationSpec$E);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
        });
    }
    /**
     * Creates or updates a route in the specified route filter.
     * @param resourceGroupName The name of the resource group.
     * @param routeFilterName The name of the route filter.
     * @param ruleName The name of the route filter rule.
     * @param routeFilterRuleParameters Parameters supplied to the create or update route filter rule
     *                                  operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, routeFilterName, ruleName, routeFilterRuleParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, routeFilterName, ruleName, routeFilterRuleParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets all RouteFilterRules in a route filter.
     * @param resourceGroupName The name of the resource group.
     * @param routeFilterName The name of the route filter.
     * @param options The options parameters.
     */
    _listByRouteFilter(resourceGroupName, routeFilterName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, routeFilterName, options }, listByRouteFilterOperationSpec);
    }
    /**
     * ListByRouteFilterNext
     * @param resourceGroupName The name of the resource group.
     * @param routeFilterName The name of the route filter.
     * @param nextLink The nextLink from the previous successful call to the ListByRouteFilter method.
     * @param options The options parameters.
     */
    _listByRouteFilterNext(resourceGroupName, routeFilterName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, routeFilterName, nextLink, options }, listByRouteFilterNextOperationSpec);
    }
}
// Operation Specifications
const serializer$13 = coreClient.createSerializer(Mappers, /* isXml */ false);
const deleteOperationSpec$E = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/routeFilters/{routeFilterName}/routeFilterRules/{ruleName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        routeFilterName,
        ruleName
    ],
    headerParameters: [accept],
    serializer: serializer$13
};
const getOperationSpec$R = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/routeFilters/{routeFilterName}/routeFilterRules/{ruleName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RouteFilterRule
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        routeFilterName,
        ruleName
    ],
    headerParameters: [accept],
    serializer: serializer$13
};
const createOrUpdateOperationSpec$E = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/routeFilters/{routeFilterName}/routeFilterRules/{ruleName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: RouteFilterRule
        },
        201: {
            bodyMapper: RouteFilterRule
        },
        202: {
            bodyMapper: RouteFilterRule
        },
        204: {
            bodyMapper: RouteFilterRule
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: routeFilterRuleParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        routeFilterName,
        ruleName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$13
};
const listByRouteFilterOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/routeFilters/{routeFilterName}/routeFilterRules",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RouteFilterRuleListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        routeFilterName
    ],
    headerParameters: [accept],
    serializer: serializer$13
};
const listByRouteFilterNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RouteFilterRuleListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        routeFilterName
    ],
    headerParameters: [accept],
    serializer: serializer$13
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing RouteTables operations. */
class RouteTablesImpl {
    /**
     * Initialize a new instance of the class RouteTables class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all route tables in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    list(resourceGroupName, options) {
        const iter = this.listPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, options);
            }
        };
    }
    listPagingPage(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets all route tables in a subscription.
     * @param options The options parameters.
     */
    listAll(options) {
        const iter = this.listAllPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listAllPagingPage(options);
            }
        };
    }
    listAllPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listAllPagingPage_1() {
            let result = yield tslib.__await(this._listAll(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listAllNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listAllPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listAllPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listAllPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Deletes the specified route table.
     * @param resourceGroupName The name of the resource group.
     * @param routeTableName The name of the route table.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, routeTableName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, routeTableName, options }, deleteOperationSpec$F);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Deletes the specified route table.
     * @param resourceGroupName The name of the resource group.
     * @param routeTableName The name of the route table.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, routeTableName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, routeTableName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the specified route table.
     * @param resourceGroupName The name of the resource group.
     * @param routeTableName The name of the route table.
     * @param options The options parameters.
     */
    get(resourceGroupName, routeTableName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, routeTableName, options }, getOperationSpec$S);
    }
    /**
     * Create or updates a route table in a specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param routeTableName The name of the route table.
     * @param parameters Parameters supplied to the create or update route table operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, routeTableName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, routeTableName, parameters, options }, createOrUpdateOperationSpec$F);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
        });
    }
    /**
     * Create or updates a route table in a specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param routeTableName The name of the route table.
     * @param parameters Parameters supplied to the create or update route table operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, routeTableName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, routeTableName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates a route table tags.
     * @param resourceGroupName The name of the resource group.
     * @param routeTableName The name of the route table.
     * @param parameters Parameters supplied to update route table tags.
     * @param options The options parameters.
     */
    updateTags(resourceGroupName, routeTableName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, routeTableName, parameters, options }, updateTagsOperationSpec$n);
    }
    /**
     * Gets all route tables in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    _list(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listOperationSpec$$);
    }
    /**
     * Gets all route tables in a subscription.
     * @param options The options parameters.
     */
    _listAll(options) {
        return this.client.sendOperationRequest({ options }, listAllOperationSpec$g);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listNextOperationSpec$V);
    }
    /**
     * ListAllNext
     * @param nextLink The nextLink from the previous successful call to the ListAll method.
     * @param options The options parameters.
     */
    _listAllNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listAllNextOperationSpec$f);
    }
}
// Operation Specifications
const serializer$14 = coreClient.createSerializer(Mappers, /* isXml */ false);
const deleteOperationSpec$F = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/routeTables/{routeTableName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        routeTableName
    ],
    headerParameters: [accept],
    serializer: serializer$14
};
const getOperationSpec$S = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/routeTables/{routeTableName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RouteTable
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, expand],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        routeTableName
    ],
    headerParameters: [accept],
    serializer: serializer$14
};
const createOrUpdateOperationSpec$F = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/routeTables/{routeTableName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: RouteTable
        },
        201: {
            bodyMapper: RouteTable
        },
        202: {
            bodyMapper: RouteTable
        },
        204: {
            bodyMapper: RouteTable
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters54,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        routeTableName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$14
};
const updateTagsOperationSpec$n = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/routeTables/{routeTableName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: RouteTable
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        routeTableName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$14
};
const listOperationSpec$$ = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/routeTables",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RouteTableListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$14
};
const listAllOperationSpec$g = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/routeTables",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RouteTableListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$14
};
const listNextOperationSpec$V = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RouteTableListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$14
};
const listAllNextOperationSpec$f = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RouteTableListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$14
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Routes operations. */
class RoutesImpl {
    /**
     * Initialize a new instance of the class Routes class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all routes in a route table.
     * @param resourceGroupName The name of the resource group.
     * @param routeTableName The name of the route table.
     * @param options The options parameters.
     */
    list(resourceGroupName, routeTableName, options) {
        const iter = this.listPagingAll(resourceGroupName, routeTableName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, routeTableName, options);
            }
        };
    }
    listPagingPage(resourceGroupName, routeTableName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, routeTableName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, routeTableName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceGroupName, routeTableName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, routeTableName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Deletes the specified route from a route table.
     * @param resourceGroupName The name of the resource group.
     * @param routeTableName The name of the route table.
     * @param routeName The name of the route.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, routeTableName, routeName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, routeTableName, routeName, options }, deleteOperationSpec$G);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Deletes the specified route from a route table.
     * @param resourceGroupName The name of the resource group.
     * @param routeTableName The name of the route table.
     * @param routeName The name of the route.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, routeTableName, routeName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, routeTableName, routeName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the specified route from a route table.
     * @param resourceGroupName The name of the resource group.
     * @param routeTableName The name of the route table.
     * @param routeName The name of the route.
     * @param options The options parameters.
     */
    get(resourceGroupName, routeTableName, routeName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, routeTableName, routeName, options }, getOperationSpec$T);
    }
    /**
     * Creates or updates a route in the specified route table.
     * @param resourceGroupName The name of the resource group.
     * @param routeTableName The name of the route table.
     * @param routeName The name of the route.
     * @param routeParameters Parameters supplied to the create or update route operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, routeTableName, routeName, routeParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                routeTableName,
                routeName,
                routeParameters,
                options
            }, createOrUpdateOperationSpec$G);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
        });
    }
    /**
     * Creates or updates a route in the specified route table.
     * @param resourceGroupName The name of the resource group.
     * @param routeTableName The name of the route table.
     * @param routeName The name of the route.
     * @param routeParameters Parameters supplied to the create or update route operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, routeTableName, routeName, routeParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, routeTableName, routeName, routeParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets all routes in a route table.
     * @param resourceGroupName The name of the resource group.
     * @param routeTableName The name of the route table.
     * @param options The options parameters.
     */
    _list(resourceGroupName, routeTableName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, routeTableName, options }, listOperationSpec$10);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param routeTableName The name of the route table.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, routeTableName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, routeTableName, nextLink, options }, listNextOperationSpec$W);
    }
}
// Operation Specifications
const serializer$15 = coreClient.createSerializer(Mappers, /* isXml */ false);
const deleteOperationSpec$G = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/routeTables/{routeTableName}/routes/{routeName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        routeTableName,
        routeName
    ],
    headerParameters: [accept],
    serializer: serializer$15
};
const getOperationSpec$T = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/routeTables/{routeTableName}/routes/{routeName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Route
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        routeTableName,
        routeName
    ],
    headerParameters: [accept],
    serializer: serializer$15
};
const createOrUpdateOperationSpec$G = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/routeTables/{routeTableName}/routes/{routeName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Route
        },
        201: {
            bodyMapper: Route
        },
        202: {
            bodyMapper: Route
        },
        204: {
            bodyMapper: Route
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: routeParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        routeTableName,
        routeName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$15
};
const listOperationSpec$10 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/routeTables/{routeTableName}/routes",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RouteListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        routeTableName
    ],
    headerParameters: [accept],
    serializer: serializer$15
};
const listNextOperationSpec$W = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RouteListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        routeTableName
    ],
    headerParameters: [accept],
    serializer: serializer$15
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing SecurityPartnerProviders operations. */
class SecurityPartnerProvidersImpl {
    /**
     * Initialize a new instance of the class SecurityPartnerProviders class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all Security Partner Providers in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByResourceGroupPagingPage(resourceGroupName, options);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets all the Security Partner Providers in a subscription.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(options);
            }
        };
    }
    listPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Deletes the specified Security Partner Provider.
     * @param resourceGroupName The name of the resource group.
     * @param securityPartnerProviderName The name of the Security Partner Provider.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, securityPartnerProviderName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, securityPartnerProviderName, options }, deleteOperationSpec$H);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Deletes the specified Security Partner Provider.
     * @param resourceGroupName The name of the resource group.
     * @param securityPartnerProviderName The name of the Security Partner Provider.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, securityPartnerProviderName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, securityPartnerProviderName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the specified Security Partner Provider.
     * @param resourceGroupName The name of the resource group.
     * @param securityPartnerProviderName The name of the Security Partner Provider.
     * @param options The options parameters.
     */
    get(resourceGroupName, securityPartnerProviderName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, securityPartnerProviderName, options }, getOperationSpec$U);
    }
    /**
     * Creates or updates the specified Security Partner Provider.
     * @param resourceGroupName The name of the resource group.
     * @param securityPartnerProviderName The name of the Security Partner Provider.
     * @param parameters Parameters supplied to the create or update Security Partner Provider operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, securityPartnerProviderName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, securityPartnerProviderName, parameters, options }, createOrUpdateOperationSpec$H);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
        });
    }
    /**
     * Creates or updates the specified Security Partner Provider.
     * @param resourceGroupName The name of the resource group.
     * @param securityPartnerProviderName The name of the Security Partner Provider.
     * @param parameters Parameters supplied to the create or update Security Partner Provider operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, securityPartnerProviderName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, securityPartnerProviderName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates tags of a Security Partner Provider resource.
     * @param resourceGroupName The name of the resource group.
     * @param securityPartnerProviderName The name of the Security Partner Provider.
     * @param parameters Parameters supplied to update Security Partner Provider tags.
     * @param options The options parameters.
     */
    updateTags(resourceGroupName, securityPartnerProviderName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, securityPartnerProviderName, parameters, options }, updateTagsOperationSpec$o);
    }
    /**
     * Lists all Security Partner Providers in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec$a);
    }
    /**
     * Gets all the Security Partner Providers in a subscription.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$11);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The name of the resource group.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec$a);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$X);
    }
}
// Operation Specifications
const serializer$16 = coreClient.createSerializer(Mappers, /* isXml */ false);
const deleteOperationSpec$H = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/securityPartnerProviders/{securityPartnerProviderName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        securityPartnerProviderName
    ],
    headerParameters: [accept],
    serializer: serializer$16
};
const getOperationSpec$U = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/securityPartnerProviders/{securityPartnerProviderName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SecurityPartnerProvider
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        securityPartnerProviderName
    ],
    headerParameters: [accept],
    serializer: serializer$16
};
const createOrUpdateOperationSpec$H = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/securityPartnerProviders/{securityPartnerProviderName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: SecurityPartnerProvider
        },
        201: {
            bodyMapper: SecurityPartnerProvider
        },
        202: {
            bodyMapper: SecurityPartnerProvider
        },
        204: {
            bodyMapper: SecurityPartnerProvider
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters55,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        securityPartnerProviderName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$16
};
const updateTagsOperationSpec$o = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/securityPartnerProviders/{securityPartnerProviderName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: SecurityPartnerProvider
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        securityPartnerProviderName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$16
};
const listByResourceGroupOperationSpec$a = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/securityPartnerProviders",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SecurityPartnerProviderListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$16
};
const listOperationSpec$11 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/securityPartnerProviders",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SecurityPartnerProviderListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$16
};
const listByResourceGroupNextOperationSpec$a = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SecurityPartnerProviderListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$16
};
const listNextOperationSpec$X = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SecurityPartnerProviderListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$16
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing BgpServiceCommunities operations. */
class BgpServiceCommunitiesImpl {
    /**
     * Initialize a new instance of the class BgpServiceCommunities class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all the available bgp service communities.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(options);
            }
        };
    }
    listPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets all the available bgp service communities.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$12);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$Y);
    }
}
// Operation Specifications
const serializer$17 = coreClient.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$12 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/bgpServiceCommunities",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: BgpServiceCommunityListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$17
};
const listNextOperationSpec$Y = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: BgpServiceCommunityListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$17
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ServiceEndpointPolicies operations. */
class ServiceEndpointPoliciesImpl {
    /**
     * Initialize a new instance of the class ServiceEndpointPolicies class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all the service endpoint policies in a subscription.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(options);
            }
        };
    }
    listPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets all service endpoint Policies in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByResourceGroupPagingPage(resourceGroupName, options);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Deletes the specified service endpoint policy.
     * @param resourceGroupName The name of the resource group.
     * @param serviceEndpointPolicyName The name of the service endpoint policy.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, serviceEndpointPolicyName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, serviceEndpointPolicyName, options }, deleteOperationSpec$I);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Deletes the specified service endpoint policy.
     * @param resourceGroupName The name of the resource group.
     * @param serviceEndpointPolicyName The name of the service endpoint policy.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, serviceEndpointPolicyName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, serviceEndpointPolicyName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the specified service Endpoint Policies in a specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param serviceEndpointPolicyName The name of the service endpoint policy.
     * @param options The options parameters.
     */
    get(resourceGroupName, serviceEndpointPolicyName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceEndpointPolicyName, options }, getOperationSpec$V);
    }
    /**
     * Creates or updates a service Endpoint Policies.
     * @param resourceGroupName The name of the resource group.
     * @param serviceEndpointPolicyName The name of the service endpoint policy.
     * @param parameters Parameters supplied to the create or update service endpoint policy operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, serviceEndpointPolicyName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, serviceEndpointPolicyName, parameters, options }, createOrUpdateOperationSpec$I);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
        });
    }
    /**
     * Creates or updates a service Endpoint Policies.
     * @param resourceGroupName The name of the resource group.
     * @param serviceEndpointPolicyName The name of the service endpoint policy.
     * @param parameters Parameters supplied to the create or update service endpoint policy operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, serviceEndpointPolicyName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, serviceEndpointPolicyName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates tags of a service endpoint policy.
     * @param resourceGroupName The name of the resource group.
     * @param serviceEndpointPolicyName The name of the service endpoint policy.
     * @param parameters Parameters supplied to update service endpoint policy tags.
     * @param options The options parameters.
     */
    updateTags(resourceGroupName, serviceEndpointPolicyName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceEndpointPolicyName, parameters, options }, updateTagsOperationSpec$p);
    }
    /**
     * Gets all the service endpoint policies in a subscription.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$13);
    }
    /**
     * Gets all service endpoint Policies in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec$b);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$Z);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The name of the resource group.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec$b);
    }
}
// Operation Specifications
const serializer$18 = coreClient.createSerializer(Mappers, /* isXml */ false);
const deleteOperationSpec$I = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/serviceEndpointPolicies/{serviceEndpointPolicyName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        serviceEndpointPolicyName
    ],
    headerParameters: [accept],
    serializer: serializer$18
};
const getOperationSpec$V = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/serviceEndpointPolicies/{serviceEndpointPolicyName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ServiceEndpointPolicy
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, expand],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        serviceEndpointPolicyName
    ],
    headerParameters: [accept],
    serializer: serializer$18
};
const createOrUpdateOperationSpec$I = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/serviceEndpointPolicies/{serviceEndpointPolicyName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ServiceEndpointPolicy
        },
        201: {
            bodyMapper: ServiceEndpointPolicy
        },
        202: {
            bodyMapper: ServiceEndpointPolicy
        },
        204: {
            bodyMapper: ServiceEndpointPolicy
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters56,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        serviceEndpointPolicyName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$18
};
const updateTagsOperationSpec$p = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/serviceEndpointPolicies/{serviceEndpointPolicyName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: ServiceEndpointPolicy
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        serviceEndpointPolicyName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$18
};
const listOperationSpec$13 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/ServiceEndpointPolicies",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ServiceEndpointPolicyListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$18
};
const listByResourceGroupOperationSpec$b = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/serviceEndpointPolicies",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ServiceEndpointPolicyListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$18
};
const listNextOperationSpec$Z = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ServiceEndpointPolicyListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$18
};
const listByResourceGroupNextOperationSpec$b = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ServiceEndpointPolicyListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$18
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ServiceEndpointPolicyDefinitions operations. */
class ServiceEndpointPolicyDefinitionsImpl {
    /**
     * Initialize a new instance of the class ServiceEndpointPolicyDefinitions class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all service endpoint policy definitions in a service end point policy.
     * @param resourceGroupName The name of the resource group.
     * @param serviceEndpointPolicyName The name of the service endpoint policy name.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, serviceEndpointPolicyName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, serviceEndpointPolicyName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByResourceGroupPagingPage(resourceGroupName, serviceEndpointPolicyName, options);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, serviceEndpointPolicyName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, serviceEndpointPolicyName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, serviceEndpointPolicyName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, serviceEndpointPolicyName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, serviceEndpointPolicyName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Deletes the specified ServiceEndpoint policy definitions.
     * @param resourceGroupName The name of the resource group.
     * @param serviceEndpointPolicyName The name of the Service Endpoint Policy.
     * @param serviceEndpointPolicyDefinitionName The name of the service endpoint policy definition.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, serviceEndpointPolicyName, serviceEndpointPolicyDefinitionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                serviceEndpointPolicyName,
                serviceEndpointPolicyDefinitionName,
                options
            }, deleteOperationSpec$J);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Deletes the specified ServiceEndpoint policy definitions.
     * @param resourceGroupName The name of the resource group.
     * @param serviceEndpointPolicyName The name of the Service Endpoint Policy.
     * @param serviceEndpointPolicyDefinitionName The name of the service endpoint policy definition.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, serviceEndpointPolicyName, serviceEndpointPolicyDefinitionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, serviceEndpointPolicyName, serviceEndpointPolicyDefinitionName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Get the specified service endpoint policy definitions from service endpoint policy.
     * @param resourceGroupName The name of the resource group.
     * @param serviceEndpointPolicyName The name of the service endpoint policy name.
     * @param serviceEndpointPolicyDefinitionName The name of the service endpoint policy definition name.
     * @param options The options parameters.
     */
    get(resourceGroupName, serviceEndpointPolicyName, serviceEndpointPolicyDefinitionName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            serviceEndpointPolicyName,
            serviceEndpointPolicyDefinitionName,
            options
        }, getOperationSpec$W);
    }
    /**
     * Creates or updates a service endpoint policy definition in the specified service endpoint policy.
     * @param resourceGroupName The name of the resource group.
     * @param serviceEndpointPolicyName The name of the service endpoint policy.
     * @param serviceEndpointPolicyDefinitionName The name of the service endpoint policy definition name.
     * @param serviceEndpointPolicyDefinitions Parameters supplied to the create or update service endpoint
     *                                         policy operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, serviceEndpointPolicyName, serviceEndpointPolicyDefinitionName, serviceEndpointPolicyDefinitions, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                serviceEndpointPolicyName,
                serviceEndpointPolicyDefinitionName,
                serviceEndpointPolicyDefinitions,
                options
            }, createOrUpdateOperationSpec$J);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
        });
    }
    /**
     * Creates or updates a service endpoint policy definition in the specified service endpoint policy.
     * @param resourceGroupName The name of the resource group.
     * @param serviceEndpointPolicyName The name of the service endpoint policy.
     * @param serviceEndpointPolicyDefinitionName The name of the service endpoint policy definition name.
     * @param serviceEndpointPolicyDefinitions Parameters supplied to the create or update service endpoint
     *                                         policy operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, serviceEndpointPolicyName, serviceEndpointPolicyDefinitionName, serviceEndpointPolicyDefinitions, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, serviceEndpointPolicyName, serviceEndpointPolicyDefinitionName, serviceEndpointPolicyDefinitions, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets all service endpoint policy definitions in a service end point policy.
     * @param resourceGroupName The name of the resource group.
     * @param serviceEndpointPolicyName The name of the service endpoint policy name.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, serviceEndpointPolicyName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceEndpointPolicyName, options }, listByResourceGroupOperationSpec$c);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The name of the resource group.
     * @param serviceEndpointPolicyName The name of the service endpoint policy name.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, serviceEndpointPolicyName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceEndpointPolicyName, nextLink, options }, listByResourceGroupNextOperationSpec$c);
    }
}
// Operation Specifications
const serializer$19 = coreClient.createSerializer(Mappers, /* isXml */ false);
const deleteOperationSpec$J = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/serviceEndpointPolicies/{serviceEndpointPolicyName}/serviceEndpointPolicyDefinitions/{serviceEndpointPolicyDefinitionName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        serviceEndpointPolicyName,
        serviceEndpointPolicyDefinitionName
    ],
    headerParameters: [accept],
    serializer: serializer$19
};
const getOperationSpec$W = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/serviceEndpointPolicies/{serviceEndpointPolicyName}/serviceEndpointPolicyDefinitions/{serviceEndpointPolicyDefinitionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ServiceEndpointPolicyDefinition
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        serviceEndpointPolicyName,
        serviceEndpointPolicyDefinitionName
    ],
    headerParameters: [accept],
    serializer: serializer$19
};
const createOrUpdateOperationSpec$J = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/serviceEndpointPolicies/{serviceEndpointPolicyName}/serviceEndpointPolicyDefinitions/{serviceEndpointPolicyDefinitionName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ServiceEndpointPolicyDefinition
        },
        201: {
            bodyMapper: ServiceEndpointPolicyDefinition
        },
        202: {
            bodyMapper: ServiceEndpointPolicyDefinition
        },
        204: {
            bodyMapper: ServiceEndpointPolicyDefinition
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: serviceEndpointPolicyDefinitions,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        serviceEndpointPolicyName,
        serviceEndpointPolicyDefinitionName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$19
};
const listByResourceGroupOperationSpec$c = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/serviceEndpointPolicies/{serviceEndpointPolicyName}/serviceEndpointPolicyDefinitions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ServiceEndpointPolicyDefinitionListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        serviceEndpointPolicyName
    ],
    headerParameters: [accept],
    serializer: serializer$19
};
const listByResourceGroupNextOperationSpec$c = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ServiceEndpointPolicyDefinitionListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        serviceEndpointPolicyName
    ],
    headerParameters: [accept],
    serializer: serializer$19
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing ServiceTags operations. */
class ServiceTagsImpl {
    /**
     * Initialize a new instance of the class ServiceTags class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a list of service tag information resources.
     * @param location The location that will be used as a reference for version (not as a filter based on
     *                 location, you will get the list of service tags with prefix details across all regions but limited
     *                 to the cloud that your subscription belongs to).
     * @param options The options parameters.
     */
    list(location, options) {
        return this.client.sendOperationRequest({ location, options }, listOperationSpec$14);
    }
}
// Operation Specifications
const serializer$1a = coreClient.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$14 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/locations/{location}/serviceTags",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ServiceTagsListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        location
    ],
    headerParameters: [accept],
    serializer: serializer$1a
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ServiceTagInformationOperations operations. */
class ServiceTagInformationOperationsImpl {
    /**
     * Initialize a new instance of the class ServiceTagInformationOperations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a list of service tag information resources with pagination.
     * @param location The location that will be used as a reference for cloud (not as a filter based on
     *                 location, you will get the list of service tags with prefix details across all regions but limited
     *                 to the cloud that your subscription belongs to).
     * @param options The options parameters.
     */
    list(location, options) {
        const iter = this.listPagingAll(location, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(location, options);
            }
        };
    }
    listPagingPage(location, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(location, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(location, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(location, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(location, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets a list of service tag information resources with pagination.
     * @param location The location that will be used as a reference for cloud (not as a filter based on
     *                 location, you will get the list of service tags with prefix details across all regions but limited
     *                 to the cloud that your subscription belongs to).
     * @param options The options parameters.
     */
    _list(location, options) {
        return this.client.sendOperationRequest({ location, options }, listOperationSpec$15);
    }
    /**
     * ListNext
     * @param location The location that will be used as a reference for cloud (not as a filter based on
     *                 location, you will get the list of service tags with prefix details across all regions but limited
     *                 to the cloud that your subscription belongs to).
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(location, nextLink, options) {
        return this.client.sendOperationRequest({ location, nextLink, options }, listNextOperationSpec$_);
    }
}
// Operation Specifications
const serializer$1b = coreClient.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$15 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/locations/{location}/serviceTagDetails",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ServiceTagInformationListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [
        apiVersion,
        noAddressPrefixes,
        tagName
    ],
    urlParameters: [
        $host,
        subscriptionId,
        location
    ],
    headerParameters: [accept],
    serializer: serializer$1b
};
const listNextOperationSpec$_ = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ServiceTagInformationListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [
        apiVersion,
        noAddressPrefixes,
        tagName
    ],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
        location
    ],
    headerParameters: [accept],
    serializer: serializer$1b
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Usages operations. */
class UsagesImpl {
    /**
     * Initialize a new instance of the class Usages class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List network usages for a subscription.
     * @param location The location where resource usage is queried.
     * @param options The options parameters.
     */
    list(location, options) {
        const iter = this.listPagingAll(location, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(location, options);
            }
        };
    }
    listPagingPage(location, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(location, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(location, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(location, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(location, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List network usages for a subscription.
     * @param location The location where resource usage is queried.
     * @param options The options parameters.
     */
    _list(location, options) {
        return this.client.sendOperationRequest({ location, options }, listOperationSpec$16);
    }
    /**
     * ListNext
     * @param location The location where resource usage is queried.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(location, nextLink, options) {
        return this.client.sendOperationRequest({ location, nextLink, options }, listNextOperationSpec$$);
    }
}
// Operation Specifications
const serializer$1c = coreClient.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$16 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/locations/{location}/usages",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: UsagesListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        location1
    ],
    headerParameters: [accept],
    serializer: serializer$1c
};
const listNextOperationSpec$$ = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: UsagesListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
        location1
    ],
    headerParameters: [accept],
    serializer: serializer$1c
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing VirtualNetworks operations. */
class VirtualNetworksImpl {
    /**
     * Initialize a new instance of the class VirtualNetworks class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all virtual networks in a subscription.
     * @param options The options parameters.
     */
    listAll(options) {
        const iter = this.listAllPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listAllPagingPage(options);
            }
        };
    }
    listAllPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listAllPagingPage_1() {
            let result = yield tslib.__await(this._listAll(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listAllNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listAllPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listAllPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listAllPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets all virtual networks in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    list(resourceGroupName, options) {
        const iter = this.listPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, options);
            }
        };
    }
    listPagingPage(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Lists usage stats.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkName The name of the virtual network.
     * @param options The options parameters.
     */
    listUsage(resourceGroupName, virtualNetworkName, options) {
        const iter = this.listUsagePagingAll(resourceGroupName, virtualNetworkName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listUsagePagingPage(resourceGroupName, virtualNetworkName, options);
            }
        };
    }
    listUsagePagingPage(resourceGroupName, virtualNetworkName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listUsagePagingPage_1() {
            let result = yield tslib.__await(this._listUsage(resourceGroupName, virtualNetworkName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listUsageNext(resourceGroupName, virtualNetworkName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listUsagePagingAll(resourceGroupName, virtualNetworkName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listUsagePagingAll_1() {
            var e_3, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listUsagePagingPage(resourceGroupName, virtualNetworkName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_3) throw e_3.error; }
            }
        });
    }
    /**
     * Deletes the specified virtual network.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkName The name of the virtual network.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, virtualNetworkName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, virtualNetworkName, options }, deleteOperationSpec$K);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Deletes the specified virtual network.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkName The name of the virtual network.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, virtualNetworkName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, virtualNetworkName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the specified virtual network by resource group.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkName The name of the virtual network.
     * @param options The options parameters.
     */
    get(resourceGroupName, virtualNetworkName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, virtualNetworkName, options }, getOperationSpec$X);
    }
    /**
     * Creates or updates a virtual network in the specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkName The name of the virtual network.
     * @param parameters Parameters supplied to the create or update virtual network operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, virtualNetworkName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, virtualNetworkName, parameters, options }, createOrUpdateOperationSpec$K);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
        });
    }
    /**
     * Creates or updates a virtual network in the specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkName The name of the virtual network.
     * @param parameters Parameters supplied to the create or update virtual network operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, virtualNetworkName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, virtualNetworkName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates a virtual network tags.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkName The name of the virtual network.
     * @param parameters Parameters supplied to update virtual network tags.
     * @param options The options parameters.
     */
    updateTags(resourceGroupName, virtualNetworkName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, virtualNetworkName, parameters, options }, updateTagsOperationSpec$q);
    }
    /**
     * Gets all virtual networks in a subscription.
     * @param options The options parameters.
     */
    _listAll(options) {
        return this.client.sendOperationRequest({ options }, listAllOperationSpec$h);
    }
    /**
     * Gets all virtual networks in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    _list(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listOperationSpec$17);
    }
    /**
     * Checks whether a private IP address is available for use.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkName The name of the virtual network.
     * @param ipAddress The private IP address to be verified.
     * @param options The options parameters.
     */
    checkIPAddressAvailability(resourceGroupName, virtualNetworkName, ipAddress, options) {
        return this.client.sendOperationRequest({ resourceGroupName, virtualNetworkName, ipAddress, options }, checkIPAddressAvailabilityOperationSpec);
    }
    /**
     * Lists usage stats.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkName The name of the virtual network.
     * @param options The options parameters.
     */
    _listUsage(resourceGroupName, virtualNetworkName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, virtualNetworkName, options }, listUsageOperationSpec);
    }
    /**
     * ListAllNext
     * @param nextLink The nextLink from the previous successful call to the ListAll method.
     * @param options The options parameters.
     */
    _listAllNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listAllNextOperationSpec$g);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listNextOperationSpec$10);
    }
    /**
     * ListUsageNext
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkName The name of the virtual network.
     * @param nextLink The nextLink from the previous successful call to the ListUsage method.
     * @param options The options parameters.
     */
    _listUsageNext(resourceGroupName, virtualNetworkName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, virtualNetworkName, nextLink, options }, listUsageNextOperationSpec);
    }
}
// Operation Specifications
const serializer$1d = coreClient.createSerializer(Mappers, /* isXml */ false);
const deleteOperationSpec$K = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworks/{virtualNetworkName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualNetworkName
    ],
    headerParameters: [accept],
    serializer: serializer$1d
};
const getOperationSpec$X = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworks/{virtualNetworkName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualNetwork
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, expand],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualNetworkName
    ],
    headerParameters: [accept],
    serializer: serializer$1d
};
const createOrUpdateOperationSpec$K = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworks/{virtualNetworkName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: VirtualNetwork
        },
        201: {
            bodyMapper: VirtualNetwork
        },
        202: {
            bodyMapper: VirtualNetwork
        },
        204: {
            bodyMapper: VirtualNetwork
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters57,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualNetworkName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1d
};
const updateTagsOperationSpec$q = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworks/{virtualNetworkName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: VirtualNetwork
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualNetworkName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1d
};
const listAllOperationSpec$h = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/virtualNetworks",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualNetworkListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$1d
};
const listOperationSpec$17 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworks",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualNetworkListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$1d
};
const checkIPAddressAvailabilityOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworks/{virtualNetworkName}/CheckIPAddressAvailability",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: IPAddressAvailabilityResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, ipAddress],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualNetworkName
    ],
    headerParameters: [accept],
    serializer: serializer$1d
};
const listUsageOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworks/{virtualNetworkName}/usages",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualNetworkListUsageResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualNetworkName
    ],
    headerParameters: [accept],
    serializer: serializer$1d
};
const listAllNextOperationSpec$g = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualNetworkListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$1d
};
const listNextOperationSpec$10 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualNetworkListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$1d
};
const listUsageNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualNetworkListUsageResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        virtualNetworkName
    ],
    headerParameters: [accept],
    serializer: serializer$1d
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Subnets operations. */
class SubnetsImpl {
    /**
     * Initialize a new instance of the class Subnets class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all subnets in a virtual network.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkName The name of the virtual network.
     * @param options The options parameters.
     */
    list(resourceGroupName, virtualNetworkName, options) {
        const iter = this.listPagingAll(resourceGroupName, virtualNetworkName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, virtualNetworkName, options);
            }
        };
    }
    listPagingPage(resourceGroupName, virtualNetworkName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, virtualNetworkName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, virtualNetworkName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceGroupName, virtualNetworkName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, virtualNetworkName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Deletes the specified subnet.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkName The name of the virtual network.
     * @param subnetName The name of the subnet.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, virtualNetworkName, subnetName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, virtualNetworkName, subnetName, options }, deleteOperationSpec$L);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Deletes the specified subnet.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkName The name of the virtual network.
     * @param subnetName The name of the subnet.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, virtualNetworkName, subnetName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, virtualNetworkName, subnetName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the specified subnet by virtual network and resource group.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkName The name of the virtual network.
     * @param subnetName The name of the subnet.
     * @param options The options parameters.
     */
    get(resourceGroupName, virtualNetworkName, subnetName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, virtualNetworkName, subnetName, options }, getOperationSpec$Y);
    }
    /**
     * Creates or updates a subnet in the specified virtual network.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkName The name of the virtual network.
     * @param subnetName The name of the subnet.
     * @param subnetParameters Parameters supplied to the create or update subnet operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, virtualNetworkName, subnetName, subnetParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                virtualNetworkName,
                subnetName,
                subnetParameters,
                options
            }, createOrUpdateOperationSpec$L);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
        });
    }
    /**
     * Creates or updates a subnet in the specified virtual network.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkName The name of the virtual network.
     * @param subnetName The name of the subnet.
     * @param subnetParameters Parameters supplied to the create or update subnet operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, virtualNetworkName, subnetName, subnetParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, virtualNetworkName, subnetName, subnetParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Prepares a subnet by applying network intent policies.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkName The name of the virtual network.
     * @param subnetName The name of the subnet.
     * @param prepareNetworkPoliciesRequestParameters Parameters supplied to prepare subnet by applying
     *                                                network intent policies.
     * @param options The options parameters.
     */
    beginPrepareNetworkPolicies(resourceGroupName, virtualNetworkName, subnetName, prepareNetworkPoliciesRequestParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                virtualNetworkName,
                subnetName,
                prepareNetworkPoliciesRequestParameters,
                options
            }, prepareNetworkPoliciesOperationSpec);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Prepares a subnet by applying network intent policies.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkName The name of the virtual network.
     * @param subnetName The name of the subnet.
     * @param prepareNetworkPoliciesRequestParameters Parameters supplied to prepare subnet by applying
     *                                                network intent policies.
     * @param options The options parameters.
     */
    beginPrepareNetworkPoliciesAndWait(resourceGroupName, virtualNetworkName, subnetName, prepareNetworkPoliciesRequestParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginPrepareNetworkPolicies(resourceGroupName, virtualNetworkName, subnetName, prepareNetworkPoliciesRequestParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Unprepares a subnet by removing network intent policies.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkName The name of the virtual network.
     * @param subnetName The name of the subnet.
     * @param unprepareNetworkPoliciesRequestParameters Parameters supplied to unprepare subnet to remove
     *                                                  network intent policies.
     * @param options The options parameters.
     */
    beginUnprepareNetworkPolicies(resourceGroupName, virtualNetworkName, subnetName, unprepareNetworkPoliciesRequestParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                virtualNetworkName,
                subnetName,
                unprepareNetworkPoliciesRequestParameters,
                options
            }, unprepareNetworkPoliciesOperationSpec);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Unprepares a subnet by removing network intent policies.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkName The name of the virtual network.
     * @param subnetName The name of the subnet.
     * @param unprepareNetworkPoliciesRequestParameters Parameters supplied to unprepare subnet to remove
     *                                                  network intent policies.
     * @param options The options parameters.
     */
    beginUnprepareNetworkPoliciesAndWait(resourceGroupName, virtualNetworkName, subnetName, unprepareNetworkPoliciesRequestParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUnprepareNetworkPolicies(resourceGroupName, virtualNetworkName, subnetName, unprepareNetworkPoliciesRequestParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets all subnets in a virtual network.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkName The name of the virtual network.
     * @param options The options parameters.
     */
    _list(resourceGroupName, virtualNetworkName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, virtualNetworkName, options }, listOperationSpec$18);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkName The name of the virtual network.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, virtualNetworkName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, virtualNetworkName, nextLink, options }, listNextOperationSpec$11);
    }
}
// Operation Specifications
const serializer$1e = coreClient.createSerializer(Mappers, /* isXml */ false);
const deleteOperationSpec$L = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworks/{virtualNetworkName}/subnets/{subnetName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualNetworkName,
        subnetName
    ],
    headerParameters: [accept],
    serializer: serializer$1e
};
const getOperationSpec$Y = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworks/{virtualNetworkName}/subnets/{subnetName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Subnet
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, expand],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualNetworkName,
        subnetName
    ],
    headerParameters: [accept],
    serializer: serializer$1e
};
const createOrUpdateOperationSpec$L = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworks/{virtualNetworkName}/subnets/{subnetName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Subnet
        },
        201: {
            bodyMapper: Subnet
        },
        202: {
            bodyMapper: Subnet
        },
        204: {
            bodyMapper: Subnet
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: subnetParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualNetworkName,
        subnetName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1e
};
const prepareNetworkPoliciesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworks/{virtualNetworkName}/subnets/{subnetName}/PrepareNetworkPolicies",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: prepareNetworkPoliciesRequestParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualNetworkName,
        subnetName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1e
};
const unprepareNetworkPoliciesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworks/{virtualNetworkName}/subnets/{subnetName}/UnprepareNetworkPolicies",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: unprepareNetworkPoliciesRequestParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualNetworkName,
        subnetName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1e
};
const listOperationSpec$18 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworks/{virtualNetworkName}/subnets",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SubnetListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualNetworkName
    ],
    headerParameters: [accept],
    serializer: serializer$1e
};
const listNextOperationSpec$11 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SubnetListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        virtualNetworkName
    ],
    headerParameters: [accept],
    serializer: serializer$1e
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing ResourceNavigationLinks operations. */
class ResourceNavigationLinksImpl {
    /**
     * Initialize a new instance of the class ResourceNavigationLinks class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a list of resource navigation links for a subnet.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkName The name of the virtual network.
     * @param subnetName The name of the subnet.
     * @param options The options parameters.
     */
    list(resourceGroupName, virtualNetworkName, subnetName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, virtualNetworkName, subnetName, options }, listOperationSpec$19);
    }
}
// Operation Specifications
const serializer$1f = coreClient.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$19 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworks/{virtualNetworkName}/subnets/{subnetName}/ResourceNavigationLinks",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ResourceNavigationLinksListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualNetworkName,
        subnetName
    ],
    headerParameters: [accept],
    serializer: serializer$1f
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing ServiceAssociationLinks operations. */
class ServiceAssociationLinksImpl {
    /**
     * Initialize a new instance of the class ServiceAssociationLinks class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a list of service association links for a subnet.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkName The name of the virtual network.
     * @param subnetName The name of the subnet.
     * @param options The options parameters.
     */
    list(resourceGroupName, virtualNetworkName, subnetName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, virtualNetworkName, subnetName, options }, listOperationSpec$1a);
    }
}
// Operation Specifications
const serializer$1g = coreClient.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$1a = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworks/{virtualNetworkName}/subnets/{subnetName}/ServiceAssociationLinks",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ServiceAssociationLinksListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualNetworkName,
        subnetName
    ],
    headerParameters: [accept],
    serializer: serializer$1g
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing VirtualNetworkPeerings operations. */
class VirtualNetworkPeeringsImpl {
    /**
     * Initialize a new instance of the class VirtualNetworkPeerings class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all virtual network peerings in a virtual network.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkName The name of the virtual network.
     * @param options The options parameters.
     */
    list(resourceGroupName, virtualNetworkName, options) {
        const iter = this.listPagingAll(resourceGroupName, virtualNetworkName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, virtualNetworkName, options);
            }
        };
    }
    listPagingPage(resourceGroupName, virtualNetworkName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, virtualNetworkName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, virtualNetworkName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceGroupName, virtualNetworkName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, virtualNetworkName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Deletes the specified virtual network peering.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkName The name of the virtual network.
     * @param virtualNetworkPeeringName The name of the virtual network peering.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, virtualNetworkName, virtualNetworkPeeringName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                virtualNetworkName,
                virtualNetworkPeeringName,
                options
            }, deleteOperationSpec$M);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Deletes the specified virtual network peering.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkName The name of the virtual network.
     * @param virtualNetworkPeeringName The name of the virtual network peering.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, virtualNetworkName, virtualNetworkPeeringName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, virtualNetworkName, virtualNetworkPeeringName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the specified virtual network peering.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkName The name of the virtual network.
     * @param virtualNetworkPeeringName The name of the virtual network peering.
     * @param options The options parameters.
     */
    get(resourceGroupName, virtualNetworkName, virtualNetworkPeeringName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            virtualNetworkName,
            virtualNetworkPeeringName,
            options
        }, getOperationSpec$Z);
    }
    /**
     * Creates or updates a peering in the specified virtual network.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkName The name of the virtual network.
     * @param virtualNetworkPeeringName The name of the peering.
     * @param virtualNetworkPeeringParameters Parameters supplied to the create or update virtual network
     *                                        peering operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, virtualNetworkName, virtualNetworkPeeringName, virtualNetworkPeeringParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                virtualNetworkName,
                virtualNetworkPeeringName,
                virtualNetworkPeeringParameters,
                options
            }, createOrUpdateOperationSpec$M);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
        });
    }
    /**
     * Creates or updates a peering in the specified virtual network.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkName The name of the virtual network.
     * @param virtualNetworkPeeringName The name of the peering.
     * @param virtualNetworkPeeringParameters Parameters supplied to the create or update virtual network
     *                                        peering operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, virtualNetworkName, virtualNetworkPeeringName, virtualNetworkPeeringParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, virtualNetworkName, virtualNetworkPeeringName, virtualNetworkPeeringParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets all virtual network peerings in a virtual network.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkName The name of the virtual network.
     * @param options The options parameters.
     */
    _list(resourceGroupName, virtualNetworkName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, virtualNetworkName, options }, listOperationSpec$1b);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkName The name of the virtual network.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, virtualNetworkName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, virtualNetworkName, nextLink, options }, listNextOperationSpec$12);
    }
}
// Operation Specifications
const serializer$1h = coreClient.createSerializer(Mappers, /* isXml */ false);
const deleteOperationSpec$M = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworks/{virtualNetworkName}/virtualNetworkPeerings/{virtualNetworkPeeringName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualNetworkName,
        virtualNetworkPeeringName
    ],
    headerParameters: [accept],
    serializer: serializer$1h
};
const getOperationSpec$Z = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworks/{virtualNetworkName}/virtualNetworkPeerings/{virtualNetworkPeeringName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualNetworkPeering
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualNetworkName,
        virtualNetworkPeeringName
    ],
    headerParameters: [accept],
    serializer: serializer$1h
};
const createOrUpdateOperationSpec$M = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworks/{virtualNetworkName}/virtualNetworkPeerings/{virtualNetworkPeeringName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: VirtualNetworkPeering
        },
        201: {
            bodyMapper: VirtualNetworkPeering
        },
        202: {
            bodyMapper: VirtualNetworkPeering
        },
        204: {
            bodyMapper: VirtualNetworkPeering
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: virtualNetworkPeeringParameters,
    queryParameters: [apiVersion, syncRemoteAddressSpace],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualNetworkName,
        virtualNetworkPeeringName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1h
};
const listOperationSpec$1b = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworks/{virtualNetworkName}/virtualNetworkPeerings",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualNetworkPeeringListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualNetworkName
    ],
    headerParameters: [accept],
    serializer: serializer$1h
};
const listNextOperationSpec$12 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualNetworkPeeringListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        virtualNetworkName
    ],
    headerParameters: [accept],
    serializer: serializer$1h
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing VirtualNetworkGateways operations. */
class VirtualNetworkGatewaysImpl {
    /**
     * Initialize a new instance of the class VirtualNetworkGateways class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all virtual network gateways by resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    list(resourceGroupName, options) {
        const iter = this.listPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, options);
            }
        };
    }
    listPagingPage(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets all the connections in a virtual network gateway.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkGatewayName The name of the virtual network gateway.
     * @param options The options parameters.
     */
    listConnections(resourceGroupName, virtualNetworkGatewayName, options) {
        const iter = this.listConnectionsPagingAll(resourceGroupName, virtualNetworkGatewayName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listConnectionsPagingPage(resourceGroupName, virtualNetworkGatewayName, options);
            }
        };
    }
    listConnectionsPagingPage(resourceGroupName, virtualNetworkGatewayName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listConnectionsPagingPage_1() {
            let result = yield tslib.__await(this._listConnections(resourceGroupName, virtualNetworkGatewayName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listConnectionsNext(resourceGroupName, virtualNetworkGatewayName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listConnectionsPagingAll(resourceGroupName, virtualNetworkGatewayName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listConnectionsPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listConnectionsPagingPage(resourceGroupName, virtualNetworkGatewayName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Creates or updates a virtual network gateway in the specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkGatewayName The name of the virtual network gateway.
     * @param parameters Parameters supplied to create or update virtual network gateway operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, virtualNetworkGatewayName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, virtualNetworkGatewayName, parameters, options }, createOrUpdateOperationSpec$N);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
        });
    }
    /**
     * Creates or updates a virtual network gateway in the specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkGatewayName The name of the virtual network gateway.
     * @param parameters Parameters supplied to create or update virtual network gateway operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, virtualNetworkGatewayName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, virtualNetworkGatewayName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the specified virtual network gateway by resource group.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkGatewayName The name of the virtual network gateway.
     * @param options The options parameters.
     */
    get(resourceGroupName, virtualNetworkGatewayName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, virtualNetworkGatewayName, options }, getOperationSpec$_);
    }
    /**
     * Deletes the specified virtual network gateway.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkGatewayName The name of the virtual network gateway.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, virtualNetworkGatewayName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, virtualNetworkGatewayName, options }, deleteOperationSpec$N);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Deletes the specified virtual network gateway.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkGatewayName The name of the virtual network gateway.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, virtualNetworkGatewayName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, virtualNetworkGatewayName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates a virtual network gateway tags.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkGatewayName The name of the virtual network gateway.
     * @param parameters Parameters supplied to update virtual network gateway tags.
     * @param options The options parameters.
     */
    beginUpdateTags(resourceGroupName, virtualNetworkGatewayName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, virtualNetworkGatewayName, parameters, options }, updateTagsOperationSpec$r);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
        });
    }
    /**
     * Updates a virtual network gateway tags.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkGatewayName The name of the virtual network gateway.
     * @param parameters Parameters supplied to update virtual network gateway tags.
     * @param options The options parameters.
     */
    beginUpdateTagsAndWait(resourceGroupName, virtualNetworkGatewayName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdateTags(resourceGroupName, virtualNetworkGatewayName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets all virtual network gateways by resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    _list(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listOperationSpec$1c);
    }
    /**
     * Gets all the connections in a virtual network gateway.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkGatewayName The name of the virtual network gateway.
     * @param options The options parameters.
     */
    _listConnections(resourceGroupName, virtualNetworkGatewayName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, virtualNetworkGatewayName, options }, listConnectionsOperationSpec);
    }
    /**
     * Resets the primary of the virtual network gateway in the specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkGatewayName The name of the virtual network gateway.
     * @param options The options parameters.
     */
    beginReset(resourceGroupName, virtualNetworkGatewayName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, virtualNetworkGatewayName, options }, resetOperationSpec);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Resets the primary of the virtual network gateway in the specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkGatewayName The name of the virtual network gateway.
     * @param options The options parameters.
     */
    beginResetAndWait(resourceGroupName, virtualNetworkGatewayName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginReset(resourceGroupName, virtualNetworkGatewayName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Resets the VPN client shared key of the virtual network gateway in the specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkGatewayName The name of the virtual network gateway.
     * @param options The options parameters.
     */
    beginResetVpnClientSharedKey(resourceGroupName, virtualNetworkGatewayName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, virtualNetworkGatewayName, options }, resetVpnClientSharedKeyOperationSpec);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Resets the VPN client shared key of the virtual network gateway in the specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkGatewayName The name of the virtual network gateway.
     * @param options The options parameters.
     */
    beginResetVpnClientSharedKeyAndWait(resourceGroupName, virtualNetworkGatewayName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginResetVpnClientSharedKey(resourceGroupName, virtualNetworkGatewayName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Generates VPN client package for P2S client of the virtual network gateway in the specified resource
     * group.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkGatewayName The name of the virtual network gateway.
     * @param parameters Parameters supplied to the generate virtual network gateway VPN client package
     *                   operation.
     * @param options The options parameters.
     */
    beginGeneratevpnclientpackage(resourceGroupName, virtualNetworkGatewayName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, virtualNetworkGatewayName, parameters, options }, generatevpnclientpackageOperationSpec);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Generates VPN client package for P2S client of the virtual network gateway in the specified resource
     * group.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkGatewayName The name of the virtual network gateway.
     * @param parameters Parameters supplied to the generate virtual network gateway VPN client package
     *                   operation.
     * @param options The options parameters.
     */
    beginGeneratevpnclientpackageAndWait(resourceGroupName, virtualNetworkGatewayName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginGeneratevpnclientpackage(resourceGroupName, virtualNetworkGatewayName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Generates VPN profile for P2S client of the virtual network gateway in the specified resource group.
     * Used for IKEV2 and radius based authentication.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkGatewayName The name of the virtual network gateway.
     * @param parameters Parameters supplied to the generate virtual network gateway VPN client package
     *                   operation.
     * @param options The options parameters.
     */
    beginGenerateVpnProfile(resourceGroupName, virtualNetworkGatewayName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, virtualNetworkGatewayName, parameters, options }, generateVpnProfileOperationSpec);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Generates VPN profile for P2S client of the virtual network gateway in the specified resource group.
     * Used for IKEV2 and radius based authentication.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkGatewayName The name of the virtual network gateway.
     * @param parameters Parameters supplied to the generate virtual network gateway VPN client package
     *                   operation.
     * @param options The options parameters.
     */
    beginGenerateVpnProfileAndWait(resourceGroupName, virtualNetworkGatewayName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginGenerateVpnProfile(resourceGroupName, virtualNetworkGatewayName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets pre-generated VPN profile for P2S client of the virtual network gateway in the specified
     * resource group. The profile needs to be generated first using generateVpnProfile.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkGatewayName The name of the virtual network gateway.
     * @param options The options parameters.
     */
    beginGetVpnProfilePackageUrl(resourceGroupName, virtualNetworkGatewayName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, virtualNetworkGatewayName, options }, getVpnProfilePackageUrlOperationSpec);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Gets pre-generated VPN profile for P2S client of the virtual network gateway in the specified
     * resource group. The profile needs to be generated first using generateVpnProfile.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkGatewayName The name of the virtual network gateway.
     * @param options The options parameters.
     */
    beginGetVpnProfilePackageUrlAndWait(resourceGroupName, virtualNetworkGatewayName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginGetVpnProfilePackageUrl(resourceGroupName, virtualNetworkGatewayName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * The GetBgpPeerStatus operation retrieves the status of all BGP peers.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkGatewayName The name of the virtual network gateway.
     * @param options The options parameters.
     */
    beginGetBgpPeerStatus(resourceGroupName, virtualNetworkGatewayName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, virtualNetworkGatewayName, options }, getBgpPeerStatusOperationSpec);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * The GetBgpPeerStatus operation retrieves the status of all BGP peers.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkGatewayName The name of the virtual network gateway.
     * @param options The options parameters.
     */
    beginGetBgpPeerStatusAndWait(resourceGroupName, virtualNetworkGatewayName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginGetBgpPeerStatus(resourceGroupName, virtualNetworkGatewayName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets a xml format representation for supported vpn devices.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkGatewayName The name of the virtual network gateway.
     * @param options The options parameters.
     */
    supportedVpnDevices(resourceGroupName, virtualNetworkGatewayName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, virtualNetworkGatewayName, options }, supportedVpnDevicesOperationSpec);
    }
    /**
     * This operation retrieves a list of routes the virtual network gateway has learned, including routes
     * learned from BGP peers.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkGatewayName The name of the virtual network gateway.
     * @param options The options parameters.
     */
    beginGetLearnedRoutes(resourceGroupName, virtualNetworkGatewayName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, virtualNetworkGatewayName, options }, getLearnedRoutesOperationSpec);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * This operation retrieves a list of routes the virtual network gateway has learned, including routes
     * learned from BGP peers.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkGatewayName The name of the virtual network gateway.
     * @param options The options parameters.
     */
    beginGetLearnedRoutesAndWait(resourceGroupName, virtualNetworkGatewayName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginGetLearnedRoutes(resourceGroupName, virtualNetworkGatewayName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * This operation retrieves a list of routes the virtual network gateway is advertising to the
     * specified peer.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkGatewayName The name of the virtual network gateway.
     * @param peer The IP address of the peer.
     * @param options The options parameters.
     */
    beginGetAdvertisedRoutes(resourceGroupName, virtualNetworkGatewayName, peer, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, virtualNetworkGatewayName, peer, options }, getAdvertisedRoutesOperationSpec);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * This operation retrieves a list of routes the virtual network gateway is advertising to the
     * specified peer.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkGatewayName The name of the virtual network gateway.
     * @param peer The IP address of the peer.
     * @param options The options parameters.
     */
    beginGetAdvertisedRoutesAndWait(resourceGroupName, virtualNetworkGatewayName, peer, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginGetAdvertisedRoutes(resourceGroupName, virtualNetworkGatewayName, peer, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * The Set VpnclientIpsecParameters operation sets the vpnclient ipsec policy for P2S client of virtual
     * network gateway in the specified resource group through Network resource provider.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkGatewayName The name of the virtual network gateway.
     * @param vpnclientIpsecParams Parameters supplied to the Begin Set vpnclient ipsec parameters of
     *                             Virtual Network Gateway P2S client operation through Network resource provider.
     * @param options The options parameters.
     */
    beginSetVpnclientIpsecParameters(resourceGroupName, virtualNetworkGatewayName, vpnclientIpsecParams, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                virtualNetworkGatewayName,
                vpnclientIpsecParams,
                options
            }, setVpnclientIpsecParametersOperationSpec);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * The Set VpnclientIpsecParameters operation sets the vpnclient ipsec policy for P2S client of virtual
     * network gateway in the specified resource group through Network resource provider.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkGatewayName The name of the virtual network gateway.
     * @param vpnclientIpsecParams Parameters supplied to the Begin Set vpnclient ipsec parameters of
     *                             Virtual Network Gateway P2S client operation through Network resource provider.
     * @param options The options parameters.
     */
    beginSetVpnclientIpsecParametersAndWait(resourceGroupName, virtualNetworkGatewayName, vpnclientIpsecParams, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginSetVpnclientIpsecParameters(resourceGroupName, virtualNetworkGatewayName, vpnclientIpsecParams, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * The Get VpnclientIpsecParameters operation retrieves information about the vpnclient ipsec policy
     * for P2S client of virtual network gateway in the specified resource group through Network resource
     * provider.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkGatewayName The virtual network gateway name.
     * @param options The options parameters.
     */
    beginGetVpnclientIpsecParameters(resourceGroupName, virtualNetworkGatewayName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, virtualNetworkGatewayName, options }, getVpnclientIpsecParametersOperationSpec);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * The Get VpnclientIpsecParameters operation retrieves information about the vpnclient ipsec policy
     * for P2S client of virtual network gateway in the specified resource group through Network resource
     * provider.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkGatewayName The virtual network gateway name.
     * @param options The options parameters.
     */
    beginGetVpnclientIpsecParametersAndWait(resourceGroupName, virtualNetworkGatewayName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginGetVpnclientIpsecParameters(resourceGroupName, virtualNetworkGatewayName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets a xml format representation for vpn device configuration script.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkGatewayConnectionName The name of the virtual network gateway connection for
     *                                            which the configuration script is generated.
     * @param parameters Parameters supplied to the generate vpn device script operation.
     * @param options The options parameters.
     */
    vpnDeviceConfigurationScript(resourceGroupName, virtualNetworkGatewayConnectionName, parameters, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            virtualNetworkGatewayConnectionName,
            parameters,
            options
        }, vpnDeviceConfigurationScriptOperationSpec);
    }
    /**
     * Starts packet capture on virtual network gateway in the specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkGatewayName The name of the virtual network gateway.
     * @param options The options parameters.
     */
    beginStartPacketCapture(resourceGroupName, virtualNetworkGatewayName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, virtualNetworkGatewayName, options }, startPacketCaptureOperationSpec);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Starts packet capture on virtual network gateway in the specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkGatewayName The name of the virtual network gateway.
     * @param options The options parameters.
     */
    beginStartPacketCaptureAndWait(resourceGroupName, virtualNetworkGatewayName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginStartPacketCapture(resourceGroupName, virtualNetworkGatewayName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Stops packet capture on virtual network gateway in the specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkGatewayName The name of the virtual network gateway.
     * @param parameters Virtual network gateway packet capture parameters supplied to stop packet capture
     *                   on gateway.
     * @param options The options parameters.
     */
    beginStopPacketCapture(resourceGroupName, virtualNetworkGatewayName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, virtualNetworkGatewayName, parameters, options }, stopPacketCaptureOperationSpec);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Stops packet capture on virtual network gateway in the specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkGatewayName The name of the virtual network gateway.
     * @param parameters Virtual network gateway packet capture parameters supplied to stop packet capture
     *                   on gateway.
     * @param options The options parameters.
     */
    beginStopPacketCaptureAndWait(resourceGroupName, virtualNetworkGatewayName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginStopPacketCapture(resourceGroupName, virtualNetworkGatewayName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Get VPN client connection health detail per P2S client connection of the virtual network gateway in
     * the specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkGatewayName The name of the virtual network gateway.
     * @param options The options parameters.
     */
    beginGetVpnclientConnectionHealth(resourceGroupName, virtualNetworkGatewayName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, virtualNetworkGatewayName, options }, getVpnclientConnectionHealthOperationSpec);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Get VPN client connection health detail per P2S client connection of the virtual network gateway in
     * the specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkGatewayName The name of the virtual network gateway.
     * @param options The options parameters.
     */
    beginGetVpnclientConnectionHealthAndWait(resourceGroupName, virtualNetworkGatewayName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginGetVpnclientConnectionHealth(resourceGroupName, virtualNetworkGatewayName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Disconnect vpn connections of virtual network gateway in the specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkGatewayName The name of the virtual network gateway.
     * @param request The parameters are supplied to disconnect vpn connections.
     * @param options The options parameters.
     */
    beginDisconnectVirtualNetworkGatewayVpnConnections(resourceGroupName, virtualNetworkGatewayName, request, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, virtualNetworkGatewayName, request, options }, disconnectVirtualNetworkGatewayVpnConnectionsOperationSpec);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Disconnect vpn connections of virtual network gateway in the specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkGatewayName The name of the virtual network gateway.
     * @param request The parameters are supplied to disconnect vpn connections.
     * @param options The options parameters.
     */
    beginDisconnectVirtualNetworkGatewayVpnConnectionsAndWait(resourceGroupName, virtualNetworkGatewayName, request, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDisconnectVirtualNetworkGatewayVpnConnections(resourceGroupName, virtualNetworkGatewayName, request, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listNextOperationSpec$13);
    }
    /**
     * ListConnectionsNext
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkGatewayName The name of the virtual network gateway.
     * @param nextLink The nextLink from the previous successful call to the ListConnections method.
     * @param options The options parameters.
     */
    _listConnectionsNext(resourceGroupName, virtualNetworkGatewayName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, virtualNetworkGatewayName, nextLink, options }, listConnectionsNextOperationSpec);
    }
}
// Operation Specifications
const serializer$1i = coreClient.createSerializer(Mappers, /* isXml */ false);
const createOrUpdateOperationSpec$N = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworkGateways/{virtualNetworkGatewayName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: VirtualNetworkGateway
        },
        201: {
            bodyMapper: VirtualNetworkGateway
        },
        202: {
            bodyMapper: VirtualNetworkGateway
        },
        204: {
            bodyMapper: VirtualNetworkGateway
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters58,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualNetworkGatewayName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1i
};
const getOperationSpec$_ = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworkGateways/{virtualNetworkGatewayName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualNetworkGateway
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualNetworkGatewayName
    ],
    headerParameters: [accept],
    serializer: serializer$1i
};
const deleteOperationSpec$N = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworkGateways/{virtualNetworkGatewayName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualNetworkGatewayName
    ],
    headerParameters: [accept],
    serializer: serializer$1i
};
const updateTagsOperationSpec$r = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworkGateways/{virtualNetworkGatewayName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: VirtualNetworkGateway
        },
        201: {
            bodyMapper: VirtualNetworkGateway
        },
        202: {
            bodyMapper: VirtualNetworkGateway
        },
        204: {
            bodyMapper: VirtualNetworkGateway
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualNetworkGatewayName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1i
};
const listOperationSpec$1c = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworkGateways",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualNetworkGatewayListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$1i
};
const listConnectionsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworkGateways/{virtualNetworkGatewayName}/connections",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualNetworkGatewayListConnectionsResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualNetworkGatewayName
    ],
    headerParameters: [accept],
    serializer: serializer$1i
};
const resetOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworkGateways/{virtualNetworkGatewayName}/reset",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: VirtualNetworkGateway
        },
        201: {
            bodyMapper: VirtualNetworkGateway
        },
        202: {
            bodyMapper: VirtualNetworkGateway
        },
        204: {
            bodyMapper: VirtualNetworkGateway
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, gatewayVip],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualNetworkGatewayName
    ],
    headerParameters: [accept],
    serializer: serializer$1i
};
const resetVpnClientSharedKeyOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworkGateways/{virtualNetworkGatewayName}/resetvpnclientsharedkey",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualNetworkGatewayName
    ],
    headerParameters: [accept],
    serializer: serializer$1i
};
const generatevpnclientpackageOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworkGateways/{virtualNetworkGatewayName}/generatevpnclientpackage",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: { type: { name: "String" } }
        },
        201: {
            bodyMapper: { type: { name: "String" } }
        },
        202: {
            bodyMapper: { type: { name: "String" } }
        },
        204: {
            bodyMapper: { type: { name: "String" } }
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters59,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualNetworkGatewayName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1i
};
const generateVpnProfileOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworkGateways/{virtualNetworkGatewayName}/generatevpnprofile",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: { type: { name: "String" } }
        },
        201: {
            bodyMapper: { type: { name: "String" } }
        },
        202: {
            bodyMapper: { type: { name: "String" } }
        },
        204: {
            bodyMapper: { type: { name: "String" } }
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters59,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualNetworkGatewayName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1i
};
const getVpnProfilePackageUrlOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworkGateways/{virtualNetworkGatewayName}/getvpnprofilepackageurl",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: { type: { name: "String" } }
        },
        201: {
            bodyMapper: { type: { name: "String" } }
        },
        202: {
            bodyMapper: { type: { name: "String" } }
        },
        204: {
            bodyMapper: { type: { name: "String" } }
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualNetworkGatewayName
    ],
    headerParameters: [accept],
    serializer: serializer$1i
};
const getBgpPeerStatusOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworkGateways/{virtualNetworkGatewayName}/getBgpPeerStatus",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: BgpPeerStatusListResult
        },
        201: {
            bodyMapper: BgpPeerStatusListResult
        },
        202: {
            bodyMapper: BgpPeerStatusListResult
        },
        204: {
            bodyMapper: BgpPeerStatusListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, peer],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualNetworkGatewayName
    ],
    headerParameters: [accept],
    serializer: serializer$1i
};
const supportedVpnDevicesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworkGateways/{virtualNetworkGatewayName}/supportedvpndevices",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: { type: { name: "String" } }
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualNetworkGatewayName
    ],
    headerParameters: [accept],
    serializer: serializer$1i
};
const getLearnedRoutesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworkGateways/{virtualNetworkGatewayName}/getLearnedRoutes",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: GatewayRouteListResult
        },
        201: {
            bodyMapper: GatewayRouteListResult
        },
        202: {
            bodyMapper: GatewayRouteListResult
        },
        204: {
            bodyMapper: GatewayRouteListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualNetworkGatewayName
    ],
    headerParameters: [accept],
    serializer: serializer$1i
};
const getAdvertisedRoutesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworkGateways/{virtualNetworkGatewayName}/getAdvertisedRoutes",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: GatewayRouteListResult
        },
        201: {
            bodyMapper: GatewayRouteListResult
        },
        202: {
            bodyMapper: GatewayRouteListResult
        },
        204: {
            bodyMapper: GatewayRouteListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, peer1],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualNetworkGatewayName
    ],
    headerParameters: [accept],
    serializer: serializer$1i
};
const setVpnclientIpsecParametersOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworkGateways/{virtualNetworkGatewayName}/setvpnclientipsecparameters",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: VpnClientIPsecParameters
        },
        201: {
            bodyMapper: VpnClientIPsecParameters
        },
        202: {
            bodyMapper: VpnClientIPsecParameters
        },
        204: {
            bodyMapper: VpnClientIPsecParameters
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: vpnclientIpsecParams,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualNetworkGatewayName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1i
};
const getVpnclientIpsecParametersOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworkGateways/{virtualNetworkGatewayName}/getvpnclientipsecparameters",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: VpnClientIPsecParameters
        },
        201: {
            bodyMapper: VpnClientIPsecParameters
        },
        202: {
            bodyMapper: VpnClientIPsecParameters
        },
        204: {
            bodyMapper: VpnClientIPsecParameters
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualNetworkGatewayName
    ],
    headerParameters: [accept],
    serializer: serializer$1i
};
const vpnDeviceConfigurationScriptOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/connections/{virtualNetworkGatewayConnectionName}/vpndeviceconfigurationscript",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: { type: { name: "String" } }
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters60,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualNetworkGatewayConnectionName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1i
};
const startPacketCaptureOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworkGateways/{virtualNetworkGatewayName}/startPacketCapture",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: { type: { name: "String" } }
        },
        201: {
            bodyMapper: { type: { name: "String" } }
        },
        202: {
            bodyMapper: { type: { name: "String" } }
        },
        204: {
            bodyMapper: { type: { name: "String" } }
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    requestBody: parameters61,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualNetworkGatewayName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1i
};
const stopPacketCaptureOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworkGateways/{virtualNetworkGatewayName}/stopPacketCapture",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: { type: { name: "String" } }
        },
        201: {
            bodyMapper: { type: { name: "String" } }
        },
        202: {
            bodyMapper: { type: { name: "String" } }
        },
        204: {
            bodyMapper: { type: { name: "String" } }
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    requestBody: parameters62,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualNetworkGatewayName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1i
};
const getVpnclientConnectionHealthOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworkGateways/{virtualNetworkGatewayName}/getVpnClientConnectionHealth",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: VpnClientConnectionHealthDetailListResult
        },
        201: {
            bodyMapper: VpnClientConnectionHealthDetailListResult
        },
        202: {
            bodyMapper: VpnClientConnectionHealthDetailListResult
        },
        204: {
            bodyMapper: VpnClientConnectionHealthDetailListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualNetworkGatewayName
    ],
    headerParameters: [accept],
    serializer: serializer$1i
};
const disconnectVirtualNetworkGatewayVpnConnectionsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworkGateways/{virtualNetworkGatewayName}/disconnectVirtualNetworkGatewayVpnConnections",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: request1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualNetworkGatewayName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1i
};
const listNextOperationSpec$13 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualNetworkGatewayListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$1i
};
const listConnectionsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualNetworkGatewayListConnectionsResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        virtualNetworkGatewayName
    ],
    headerParameters: [accept],
    serializer: serializer$1i
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing VirtualNetworkGatewayConnections operations. */
class VirtualNetworkGatewayConnectionsImpl {
    /**
     * Initialize a new instance of the class VirtualNetworkGatewayConnections class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * The List VirtualNetworkGatewayConnections operation retrieves all the virtual network gateways
     * connections created.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    list(resourceGroupName, options) {
        const iter = this.listPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, options);
            }
        };
    }
    listPagingPage(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Creates or updates a virtual network gateway connection in the specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkGatewayConnectionName The name of the virtual network gateway connection.
     * @param parameters Parameters supplied to the create or update virtual network gateway connection
     *                   operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, virtualNetworkGatewayConnectionName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                virtualNetworkGatewayConnectionName,
                parameters,
                options
            }, createOrUpdateOperationSpec$O);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
        });
    }
    /**
     * Creates or updates a virtual network gateway connection in the specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkGatewayConnectionName The name of the virtual network gateway connection.
     * @param parameters Parameters supplied to the create or update virtual network gateway connection
     *                   operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, virtualNetworkGatewayConnectionName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, virtualNetworkGatewayConnectionName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the specified virtual network gateway connection by resource group.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkGatewayConnectionName The name of the virtual network gateway connection.
     * @param options The options parameters.
     */
    get(resourceGroupName, virtualNetworkGatewayConnectionName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, virtualNetworkGatewayConnectionName, options }, getOperationSpec$$);
    }
    /**
     * Deletes the specified virtual network Gateway connection.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkGatewayConnectionName The name of the virtual network gateway connection.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, virtualNetworkGatewayConnectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, virtualNetworkGatewayConnectionName, options }, deleteOperationSpec$O);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Deletes the specified virtual network Gateway connection.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkGatewayConnectionName The name of the virtual network gateway connection.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, virtualNetworkGatewayConnectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, virtualNetworkGatewayConnectionName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates a virtual network gateway connection tags.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkGatewayConnectionName The name of the virtual network gateway connection.
     * @param parameters Parameters supplied to update virtual network gateway connection tags.
     * @param options The options parameters.
     */
    beginUpdateTags(resourceGroupName, virtualNetworkGatewayConnectionName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                virtualNetworkGatewayConnectionName,
                parameters,
                options
            }, updateTagsOperationSpec$s);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
        });
    }
    /**
     * Updates a virtual network gateway connection tags.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkGatewayConnectionName The name of the virtual network gateway connection.
     * @param parameters Parameters supplied to update virtual network gateway connection tags.
     * @param options The options parameters.
     */
    beginUpdateTagsAndWait(resourceGroupName, virtualNetworkGatewayConnectionName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdateTags(resourceGroupName, virtualNetworkGatewayConnectionName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * The Put VirtualNetworkGatewayConnectionSharedKey operation sets the virtual network gateway
     * connection shared key for passed virtual network gateway connection in the specified resource group
     * through Network resource provider.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkGatewayConnectionName The virtual network gateway connection name.
     * @param parameters Parameters supplied to the Begin Set Virtual Network Gateway connection Shared key
     *                   operation throughNetwork resource provider.
     * @param options The options parameters.
     */
    beginSetSharedKey(resourceGroupName, virtualNetworkGatewayConnectionName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                virtualNetworkGatewayConnectionName,
                parameters,
                options
            }, setSharedKeyOperationSpec);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
        });
    }
    /**
     * The Put VirtualNetworkGatewayConnectionSharedKey operation sets the virtual network gateway
     * connection shared key for passed virtual network gateway connection in the specified resource group
     * through Network resource provider.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkGatewayConnectionName The virtual network gateway connection name.
     * @param parameters Parameters supplied to the Begin Set Virtual Network Gateway connection Shared key
     *                   operation throughNetwork resource provider.
     * @param options The options parameters.
     */
    beginSetSharedKeyAndWait(resourceGroupName, virtualNetworkGatewayConnectionName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginSetSharedKey(resourceGroupName, virtualNetworkGatewayConnectionName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * The Get VirtualNetworkGatewayConnectionSharedKey operation retrieves information about the specified
     * virtual network gateway connection shared key through Network resource provider.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkGatewayConnectionName The virtual network gateway connection shared key name.
     * @param options The options parameters.
     */
    getSharedKey(resourceGroupName, virtualNetworkGatewayConnectionName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, virtualNetworkGatewayConnectionName, options }, getSharedKeyOperationSpec);
    }
    /**
     * The List VirtualNetworkGatewayConnections operation retrieves all the virtual network gateways
     * connections created.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    _list(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listOperationSpec$1d);
    }
    /**
     * The VirtualNetworkGatewayConnectionResetSharedKey operation resets the virtual network gateway
     * connection shared key for passed virtual network gateway connection in the specified resource group
     * through Network resource provider.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkGatewayConnectionName The virtual network gateway connection reset shared key
     *                                            Name.
     * @param parameters Parameters supplied to the begin reset virtual network gateway connection shared
     *                   key operation through network resource provider.
     * @param options The options parameters.
     */
    beginResetSharedKey(resourceGroupName, virtualNetworkGatewayConnectionName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                virtualNetworkGatewayConnectionName,
                parameters,
                options
            }, resetSharedKeyOperationSpec);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * The VirtualNetworkGatewayConnectionResetSharedKey operation resets the virtual network gateway
     * connection shared key for passed virtual network gateway connection in the specified resource group
     * through Network resource provider.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkGatewayConnectionName The virtual network gateway connection reset shared key
     *                                            Name.
     * @param parameters Parameters supplied to the begin reset virtual network gateway connection shared
     *                   key operation through network resource provider.
     * @param options The options parameters.
     */
    beginResetSharedKeyAndWait(resourceGroupName, virtualNetworkGatewayConnectionName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginResetSharedKey(resourceGroupName, virtualNetworkGatewayConnectionName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Starts packet capture on virtual network gateway connection in the specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkGatewayConnectionName The name of the virtual network gateway connection.
     * @param options The options parameters.
     */
    beginStartPacketCapture(resourceGroupName, virtualNetworkGatewayConnectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, virtualNetworkGatewayConnectionName, options }, startPacketCaptureOperationSpec$1);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Starts packet capture on virtual network gateway connection in the specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkGatewayConnectionName The name of the virtual network gateway connection.
     * @param options The options parameters.
     */
    beginStartPacketCaptureAndWait(resourceGroupName, virtualNetworkGatewayConnectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginStartPacketCapture(resourceGroupName, virtualNetworkGatewayConnectionName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Stops packet capture on virtual network gateway connection in the specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkGatewayConnectionName The name of the virtual network gateway Connection.
     * @param parameters Virtual network gateway packet capture parameters supplied to stop packet capture
     *                   on gateway connection.
     * @param options The options parameters.
     */
    beginStopPacketCapture(resourceGroupName, virtualNetworkGatewayConnectionName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                virtualNetworkGatewayConnectionName,
                parameters,
                options
            }, stopPacketCaptureOperationSpec$1);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Stops packet capture on virtual network gateway connection in the specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkGatewayConnectionName The name of the virtual network gateway Connection.
     * @param parameters Virtual network gateway packet capture parameters supplied to stop packet capture
     *                   on gateway connection.
     * @param options The options parameters.
     */
    beginStopPacketCaptureAndWait(resourceGroupName, virtualNetworkGatewayConnectionName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginStopPacketCapture(resourceGroupName, virtualNetworkGatewayConnectionName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Lists IKE Security Associations for the virtual network gateway connection in the specified resource
     * group.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkGatewayConnectionName The name of the virtual network gateway Connection.
     * @param options The options parameters.
     */
    beginGetIkeSas(resourceGroupName, virtualNetworkGatewayConnectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, virtualNetworkGatewayConnectionName, options }, getIkeSasOperationSpec);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Lists IKE Security Associations for the virtual network gateway connection in the specified resource
     * group.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkGatewayConnectionName The name of the virtual network gateway Connection.
     * @param options The options parameters.
     */
    beginGetIkeSasAndWait(resourceGroupName, virtualNetworkGatewayConnectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginGetIkeSas(resourceGroupName, virtualNetworkGatewayConnectionName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Resets the virtual network gateway connection specified.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkGatewayConnectionName The name of the virtual network gateway Connection.
     * @param options The options parameters.
     */
    beginResetConnection(resourceGroupName, virtualNetworkGatewayConnectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, virtualNetworkGatewayConnectionName, options }, resetConnectionOperationSpec);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Resets the virtual network gateway connection specified.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkGatewayConnectionName The name of the virtual network gateway Connection.
     * @param options The options parameters.
     */
    beginResetConnectionAndWait(resourceGroupName, virtualNetworkGatewayConnectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginResetConnection(resourceGroupName, virtualNetworkGatewayConnectionName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listNextOperationSpec$14);
    }
}
// Operation Specifications
const serializer$1j = coreClient.createSerializer(Mappers, /* isXml */ false);
const createOrUpdateOperationSpec$O = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/connections/{virtualNetworkGatewayConnectionName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: VirtualNetworkGatewayConnection
        },
        201: {
            bodyMapper: VirtualNetworkGatewayConnection
        },
        202: {
            bodyMapper: VirtualNetworkGatewayConnection
        },
        204: {
            bodyMapper: VirtualNetworkGatewayConnection
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters63,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualNetworkGatewayConnectionName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1j
};
const getOperationSpec$$ = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/connections/{virtualNetworkGatewayConnectionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualNetworkGatewayConnection
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualNetworkGatewayConnectionName
    ],
    headerParameters: [accept],
    serializer: serializer$1j
};
const deleteOperationSpec$O = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/connections/{virtualNetworkGatewayConnectionName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualNetworkGatewayConnectionName
    ],
    headerParameters: [accept],
    serializer: serializer$1j
};
const updateTagsOperationSpec$s = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/connections/{virtualNetworkGatewayConnectionName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: VirtualNetworkGatewayConnection
        },
        201: {
            bodyMapper: VirtualNetworkGatewayConnection
        },
        202: {
            bodyMapper: VirtualNetworkGatewayConnection
        },
        204: {
            bodyMapper: VirtualNetworkGatewayConnection
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualNetworkGatewayConnectionName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1j
};
const setSharedKeyOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/connections/{virtualNetworkGatewayConnectionName}/sharedkey",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ConnectionSharedKey
        },
        201: {
            bodyMapper: ConnectionSharedKey
        },
        202: {
            bodyMapper: ConnectionSharedKey
        },
        204: {
            bodyMapper: ConnectionSharedKey
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters64,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualNetworkGatewayConnectionName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1j
};
const getSharedKeyOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/connections/{virtualNetworkGatewayConnectionName}/sharedkey",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ConnectionSharedKey
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualNetworkGatewayConnectionName
    ],
    headerParameters: [accept],
    serializer: serializer$1j
};
const listOperationSpec$1d = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/connections",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualNetworkGatewayConnectionListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$1j
};
const resetSharedKeyOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/connections/{virtualNetworkGatewayConnectionName}/sharedkey/reset",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: ConnectionResetSharedKey
        },
        201: {
            bodyMapper: ConnectionResetSharedKey
        },
        202: {
            bodyMapper: ConnectionResetSharedKey
        },
        204: {
            bodyMapper: ConnectionResetSharedKey
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters65,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualNetworkGatewayConnectionName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1j
};
const startPacketCaptureOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/connections/{virtualNetworkGatewayConnectionName}/startPacketCapture",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: { type: { name: "String" } }
        },
        201: {
            bodyMapper: { type: { name: "String" } }
        },
        202: {
            bodyMapper: { type: { name: "String" } }
        },
        204: {
            bodyMapper: { type: { name: "String" } }
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    requestBody: parameters61,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualNetworkGatewayConnectionName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1j
};
const stopPacketCaptureOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/connections/{virtualNetworkGatewayConnectionName}/stopPacketCapture",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: { type: { name: "String" } }
        },
        201: {
            bodyMapper: { type: { name: "String" } }
        },
        202: {
            bodyMapper: { type: { name: "String" } }
        },
        204: {
            bodyMapper: { type: { name: "String" } }
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    requestBody: parameters62,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualNetworkGatewayConnectionName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1j
};
const getIkeSasOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/connections/{virtualNetworkGatewayConnectionName}/getikesas",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: { type: { name: "String" } }
        },
        201: {
            bodyMapper: { type: { name: "String" } }
        },
        202: {
            bodyMapper: { type: { name: "String" } }
        },
        204: {
            bodyMapper: { type: { name: "String" } }
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualNetworkGatewayConnectionName
    ],
    headerParameters: [accept],
    serializer: serializer$1j
};
const resetConnectionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/connections/{virtualNetworkGatewayConnectionName}/resetconnection",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualNetworkGatewayConnectionName
    ],
    headerParameters: [accept],
    serializer: serializer$1j
};
const listNextOperationSpec$14 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualNetworkGatewayConnectionListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$1j
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing LocalNetworkGateways operations. */
class LocalNetworkGatewaysImpl {
    /**
     * Initialize a new instance of the class LocalNetworkGateways class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all the local network gateways in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    list(resourceGroupName, options) {
        const iter = this.listPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, options);
            }
        };
    }
    listPagingPage(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Creates or updates a local network gateway in the specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param localNetworkGatewayName The name of the local network gateway.
     * @param parameters Parameters supplied to the create or update local network gateway operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, localNetworkGatewayName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, localNetworkGatewayName, parameters, options }, createOrUpdateOperationSpec$P);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
        });
    }
    /**
     * Creates or updates a local network gateway in the specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param localNetworkGatewayName The name of the local network gateway.
     * @param parameters Parameters supplied to the create or update local network gateway operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, localNetworkGatewayName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, localNetworkGatewayName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the specified local network gateway in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param localNetworkGatewayName The name of the local network gateway.
     * @param options The options parameters.
     */
    get(resourceGroupName, localNetworkGatewayName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, localNetworkGatewayName, options }, getOperationSpec$10);
    }
    /**
     * Deletes the specified local network gateway.
     * @param resourceGroupName The name of the resource group.
     * @param localNetworkGatewayName The name of the local network gateway.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, localNetworkGatewayName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, localNetworkGatewayName, options }, deleteOperationSpec$P);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Deletes the specified local network gateway.
     * @param resourceGroupName The name of the resource group.
     * @param localNetworkGatewayName The name of the local network gateway.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, localNetworkGatewayName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, localNetworkGatewayName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates a local network gateway tags.
     * @param resourceGroupName The name of the resource group.
     * @param localNetworkGatewayName The name of the local network gateway.
     * @param parameters Parameters supplied to update local network gateway tags.
     * @param options The options parameters.
     */
    updateTags(resourceGroupName, localNetworkGatewayName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, localNetworkGatewayName, parameters, options }, updateTagsOperationSpec$t);
    }
    /**
     * Gets all the local network gateways in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    _list(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listOperationSpec$1e);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listNextOperationSpec$15);
    }
}
// Operation Specifications
const serializer$1k = coreClient.createSerializer(Mappers, /* isXml */ false);
const createOrUpdateOperationSpec$P = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/localNetworkGateways/{localNetworkGatewayName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: LocalNetworkGateway
        },
        201: {
            bodyMapper: LocalNetworkGateway
        },
        202: {
            bodyMapper: LocalNetworkGateway
        },
        204: {
            bodyMapper: LocalNetworkGateway
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters66,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        localNetworkGatewayName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1k
};
const getOperationSpec$10 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/localNetworkGateways/{localNetworkGatewayName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: LocalNetworkGateway
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        localNetworkGatewayName
    ],
    headerParameters: [accept],
    serializer: serializer$1k
};
const deleteOperationSpec$P = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/localNetworkGateways/{localNetworkGatewayName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        localNetworkGatewayName
    ],
    headerParameters: [accept],
    serializer: serializer$1k
};
const updateTagsOperationSpec$t = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/localNetworkGateways/{localNetworkGatewayName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: LocalNetworkGateway
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        localNetworkGatewayName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1k
};
const listOperationSpec$1e = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/localNetworkGateways",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: LocalNetworkGatewayListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$1k
};
const listNextOperationSpec$15 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: LocalNetworkGatewayListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$1k
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing VirtualNetworkGatewayNatRules operations. */
class VirtualNetworkGatewayNatRulesImpl {
    /**
     * Initialize a new instance of the class VirtualNetworkGatewayNatRules class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Retrieves all nat rules for a particular virtual network gateway.
     * @param resourceGroupName The resource group name of the virtual network gateway.
     * @param virtualNetworkGatewayName The name of the gateway.
     * @param options The options parameters.
     */
    listByVirtualNetworkGateway(resourceGroupName, virtualNetworkGatewayName, options) {
        const iter = this.listByVirtualNetworkGatewayPagingAll(resourceGroupName, virtualNetworkGatewayName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByVirtualNetworkGatewayPagingPage(resourceGroupName, virtualNetworkGatewayName, options);
            }
        };
    }
    listByVirtualNetworkGatewayPagingPage(resourceGroupName, virtualNetworkGatewayName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByVirtualNetworkGatewayPagingPage_1() {
            let result = yield tslib.__await(this._listByVirtualNetworkGateway(resourceGroupName, virtualNetworkGatewayName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByVirtualNetworkGatewayNext(resourceGroupName, virtualNetworkGatewayName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByVirtualNetworkGatewayPagingAll(resourceGroupName, virtualNetworkGatewayName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByVirtualNetworkGatewayPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByVirtualNetworkGatewayPagingPage(resourceGroupName, virtualNetworkGatewayName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Retrieves the details of a nat rule.
     * @param resourceGroupName The resource group name of the Virtual Network Gateway.
     * @param virtualNetworkGatewayName The name of the gateway.
     * @param natRuleName The name of the nat rule.
     * @param options The options parameters.
     */
    get(resourceGroupName, virtualNetworkGatewayName, natRuleName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, virtualNetworkGatewayName, natRuleName, options }, getOperationSpec$11);
    }
    /**
     * Creates a nat rule to a scalable virtual network gateway if it doesn't exist else updates the
     * existing nat rules.
     * @param resourceGroupName The resource group name of the Virtual Network Gateway.
     * @param virtualNetworkGatewayName The name of the gateway.
     * @param natRuleName The name of the nat rule.
     * @param natRuleParameters Parameters supplied to create or Update a Nat Rule.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, virtualNetworkGatewayName, natRuleName, natRuleParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                virtualNetworkGatewayName,
                natRuleName,
                natRuleParameters,
                options
            }, createOrUpdateOperationSpec$Q);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
        });
    }
    /**
     * Creates a nat rule to a scalable virtual network gateway if it doesn't exist else updates the
     * existing nat rules.
     * @param resourceGroupName The resource group name of the Virtual Network Gateway.
     * @param virtualNetworkGatewayName The name of the gateway.
     * @param natRuleName The name of the nat rule.
     * @param natRuleParameters Parameters supplied to create or Update a Nat Rule.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, virtualNetworkGatewayName, natRuleName, natRuleParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, virtualNetworkGatewayName, natRuleName, natRuleParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes a nat rule.
     * @param resourceGroupName The resource group name of the Virtual Network Gateway.
     * @param virtualNetworkGatewayName The name of the gateway.
     * @param natRuleName The name of the nat rule.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, virtualNetworkGatewayName, natRuleName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, virtualNetworkGatewayName, natRuleName, options }, deleteOperationSpec$Q);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Deletes a nat rule.
     * @param resourceGroupName The resource group name of the Virtual Network Gateway.
     * @param virtualNetworkGatewayName The name of the gateway.
     * @param natRuleName The name of the nat rule.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, virtualNetworkGatewayName, natRuleName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, virtualNetworkGatewayName, natRuleName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Retrieves all nat rules for a particular virtual network gateway.
     * @param resourceGroupName The resource group name of the virtual network gateway.
     * @param virtualNetworkGatewayName The name of the gateway.
     * @param options The options parameters.
     */
    _listByVirtualNetworkGateway(resourceGroupName, virtualNetworkGatewayName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, virtualNetworkGatewayName, options }, listByVirtualNetworkGatewayOperationSpec);
    }
    /**
     * ListByVirtualNetworkGatewayNext
     * @param resourceGroupName The resource group name of the virtual network gateway.
     * @param virtualNetworkGatewayName The name of the gateway.
     * @param nextLink The nextLink from the previous successful call to the ListByVirtualNetworkGateway
     *                 method.
     * @param options The options parameters.
     */
    _listByVirtualNetworkGatewayNext(resourceGroupName, virtualNetworkGatewayName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, virtualNetworkGatewayName, nextLink, options }, listByVirtualNetworkGatewayNextOperationSpec);
    }
}
// Operation Specifications
const serializer$1l = coreClient.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$11 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworkGateways/{virtualNetworkGatewayName}/natRules/{natRuleName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualNetworkGatewayNatRule
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualNetworkGatewayName,
        natRuleName
    ],
    headerParameters: [accept],
    serializer: serializer$1l
};
const createOrUpdateOperationSpec$Q = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworkGateways/{virtualNetworkGatewayName}/natRules/{natRuleName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: VirtualNetworkGatewayNatRule
        },
        201: {
            bodyMapper: VirtualNetworkGatewayNatRule
        },
        202: {
            bodyMapper: VirtualNetworkGatewayNatRule
        },
        204: {
            bodyMapper: VirtualNetworkGatewayNatRule
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: natRuleParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualNetworkGatewayName,
        natRuleName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1l
};
const deleteOperationSpec$Q = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworkGateways/{virtualNetworkGatewayName}/natRules/{natRuleName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualNetworkGatewayName,
        natRuleName
    ],
    headerParameters: [accept],
    serializer: serializer$1l
};
const listByVirtualNetworkGatewayOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworkGateways/{virtualNetworkGatewayName}/natRules",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListVirtualNetworkGatewayNatRulesResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualNetworkGatewayName
    ],
    headerParameters: [accept],
    serializer: serializer$1l
};
const listByVirtualNetworkGatewayNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListVirtualNetworkGatewayNatRulesResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        virtualNetworkGatewayName
    ],
    headerParameters: [accept],
    serializer: serializer$1l
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing VirtualNetworkTaps operations. */
class VirtualNetworkTapsImpl {
    /**
     * Initialize a new instance of the class VirtualNetworkTaps class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all the VirtualNetworkTaps in a subscription.
     * @param options The options parameters.
     */
    listAll(options) {
        const iter = this.listAllPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listAllPagingPage(options);
            }
        };
    }
    listAllPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listAllPagingPage_1() {
            let result = yield tslib.__await(this._listAll(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listAllNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listAllPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listAllPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listAllPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets all the VirtualNetworkTaps in a subscription.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByResourceGroupPagingPage(resourceGroupName, options);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Deletes the specified virtual network tap.
     * @param resourceGroupName The name of the resource group.
     * @param tapName The name of the virtual network tap.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, tapName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, tapName, options }, deleteOperationSpec$R);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Deletes the specified virtual network tap.
     * @param resourceGroupName The name of the resource group.
     * @param tapName The name of the virtual network tap.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, tapName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, tapName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets information about the specified virtual network tap.
     * @param resourceGroupName The name of the resource group.
     * @param tapName The name of virtual network tap.
     * @param options The options parameters.
     */
    get(resourceGroupName, tapName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, tapName, options }, getOperationSpec$12);
    }
    /**
     * Creates or updates a Virtual Network Tap.
     * @param resourceGroupName The name of the resource group.
     * @param tapName The name of the virtual network tap.
     * @param parameters Parameters supplied to the create or update virtual network tap operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, tapName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, tapName, parameters, options }, createOrUpdateOperationSpec$R);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
        });
    }
    /**
     * Creates or updates a Virtual Network Tap.
     * @param resourceGroupName The name of the resource group.
     * @param tapName The name of the virtual network tap.
     * @param parameters Parameters supplied to the create or update virtual network tap operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, tapName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, tapName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates an VirtualNetworkTap tags.
     * @param resourceGroupName The name of the resource group.
     * @param tapName The name of the tap.
     * @param tapParameters Parameters supplied to update VirtualNetworkTap tags.
     * @param options The options parameters.
     */
    updateTags(resourceGroupName, tapName, tapParameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, tapName, tapParameters, options }, updateTagsOperationSpec$u);
    }
    /**
     * Gets all the VirtualNetworkTaps in a subscription.
     * @param options The options parameters.
     */
    _listAll(options) {
        return this.client.sendOperationRequest({ options }, listAllOperationSpec$i);
    }
    /**
     * Gets all the VirtualNetworkTaps in a subscription.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec$d);
    }
    /**
     * ListAllNext
     * @param nextLink The nextLink from the previous successful call to the ListAll method.
     * @param options The options parameters.
     */
    _listAllNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listAllNextOperationSpec$h);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The name of the resource group.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec$d);
    }
}
// Operation Specifications
const serializer$1m = coreClient.createSerializer(Mappers, /* isXml */ false);
const deleteOperationSpec$R = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworkTaps/{tapName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        tapName
    ],
    headerParameters: [accept],
    serializer: serializer$1m
};
const getOperationSpec$12 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworkTaps/{tapName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualNetworkTap
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        tapName
    ],
    headerParameters: [accept],
    serializer: serializer$1m
};
const createOrUpdateOperationSpec$R = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworkTaps/{tapName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: VirtualNetworkTap
        },
        201: {
            bodyMapper: VirtualNetworkTap
        },
        202: {
            bodyMapper: VirtualNetworkTap
        },
        204: {
            bodyMapper: VirtualNetworkTap
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters67,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        tapName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1m
};
const updateTagsOperationSpec$u = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworkTaps/{tapName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: VirtualNetworkTap
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: tapParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        tapName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1m
};
const listAllOperationSpec$i = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/virtualNetworkTaps",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualNetworkTapListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$1m
};
const listByResourceGroupOperationSpec$d = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworkTaps",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualNetworkTapListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$1m
};
const listAllNextOperationSpec$h = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualNetworkTapListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$1m
};
const listByResourceGroupNextOperationSpec$d = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualNetworkTapListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$1m
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing VirtualRouters operations. */
class VirtualRoutersImpl {
    /**
     * Initialize a new instance of the class VirtualRouters class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all Virtual Routers in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByResourceGroupPagingPage(resourceGroupName, options);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets all the Virtual Routers in a subscription.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(options);
            }
        };
    }
    listPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Deletes the specified Virtual Router.
     * @param resourceGroupName The name of the resource group.
     * @param virtualRouterName The name of the Virtual Router.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, virtualRouterName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, virtualRouterName, options }, deleteOperationSpec$S);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Deletes the specified Virtual Router.
     * @param resourceGroupName The name of the resource group.
     * @param virtualRouterName The name of the Virtual Router.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, virtualRouterName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, virtualRouterName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the specified Virtual Router.
     * @param resourceGroupName The name of the resource group.
     * @param virtualRouterName The name of the Virtual Router.
     * @param options The options parameters.
     */
    get(resourceGroupName, virtualRouterName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, virtualRouterName, options }, getOperationSpec$13);
    }
    /**
     * Creates or updates the specified Virtual Router.
     * @param resourceGroupName The name of the resource group.
     * @param virtualRouterName The name of the Virtual Router.
     * @param parameters Parameters supplied to the create or update Virtual Router.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, virtualRouterName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, virtualRouterName, parameters, options }, createOrUpdateOperationSpec$S);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
        });
    }
    /**
     * Creates or updates the specified Virtual Router.
     * @param resourceGroupName The name of the resource group.
     * @param virtualRouterName The name of the Virtual Router.
     * @param parameters Parameters supplied to the create or update Virtual Router.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, virtualRouterName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, virtualRouterName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Lists all Virtual Routers in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec$e);
    }
    /**
     * Gets all the Virtual Routers in a subscription.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$1f);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The name of the resource group.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec$e);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$16);
    }
}
// Operation Specifications
const serializer$1n = coreClient.createSerializer(Mappers, /* isXml */ false);
const deleteOperationSpec$S = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualRouters/{virtualRouterName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualRouterName
    ],
    headerParameters: [accept],
    serializer: serializer$1n
};
const getOperationSpec$13 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualRouters/{virtualRouterName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualRouter
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [apiVersion, expand],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualRouterName
    ],
    headerParameters: [accept],
    serializer: serializer$1n
};
const createOrUpdateOperationSpec$S = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualRouters/{virtualRouterName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: VirtualRouter
        },
        201: {
            bodyMapper: VirtualRouter
        },
        202: {
            bodyMapper: VirtualRouter
        },
        204: {
            bodyMapper: VirtualRouter
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    requestBody: parameters68,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualRouterName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1n
};
const listByResourceGroupOperationSpec$e = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualRouters",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualRouterListResult
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$1n
};
const listOperationSpec$1f = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/virtualRouters",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualRouterListResult
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$1n
};
const listByResourceGroupNextOperationSpec$e = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualRouterListResult
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$1n
};
const listNextOperationSpec$16 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualRouterListResult
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$1n
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing VirtualRouterPeerings operations. */
class VirtualRouterPeeringsImpl {
    /**
     * Initialize a new instance of the class VirtualRouterPeerings class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all Virtual Router Peerings in a Virtual Router resource.
     * @param resourceGroupName The name of the resource group.
     * @param virtualRouterName The name of the Virtual Router.
     * @param options The options parameters.
     */
    list(resourceGroupName, virtualRouterName, options) {
        const iter = this.listPagingAll(resourceGroupName, virtualRouterName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, virtualRouterName, options);
            }
        };
    }
    listPagingPage(resourceGroupName, virtualRouterName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, virtualRouterName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, virtualRouterName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceGroupName, virtualRouterName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, virtualRouterName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Deletes the specified peering from a Virtual Router.
     * @param resourceGroupName The name of the resource group.
     * @param virtualRouterName The name of the Virtual Router.
     * @param peeringName The name of the peering.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, virtualRouterName, peeringName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, virtualRouterName, peeringName, options }, deleteOperationSpec$T);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Deletes the specified peering from a Virtual Router.
     * @param resourceGroupName The name of the resource group.
     * @param virtualRouterName The name of the Virtual Router.
     * @param peeringName The name of the peering.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, virtualRouterName, peeringName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, virtualRouterName, peeringName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the specified Virtual Router Peering.
     * @param resourceGroupName The name of the resource group.
     * @param virtualRouterName The name of the Virtual Router.
     * @param peeringName The name of the Virtual Router Peering.
     * @param options The options parameters.
     */
    get(resourceGroupName, virtualRouterName, peeringName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, virtualRouterName, peeringName, options }, getOperationSpec$14);
    }
    /**
     * Creates or updates the specified Virtual Router Peering.
     * @param resourceGroupName The name of the resource group.
     * @param virtualRouterName The name of the Virtual Router.
     * @param peeringName The name of the Virtual Router Peering.
     * @param parameters Parameters supplied to the create or update Virtual Router Peering operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, virtualRouterName, peeringName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                virtualRouterName,
                peeringName,
                parameters,
                options
            }, createOrUpdateOperationSpec$T);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
        });
    }
    /**
     * Creates or updates the specified Virtual Router Peering.
     * @param resourceGroupName The name of the resource group.
     * @param virtualRouterName The name of the Virtual Router.
     * @param peeringName The name of the Virtual Router Peering.
     * @param parameters Parameters supplied to the create or update Virtual Router Peering operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, virtualRouterName, peeringName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, virtualRouterName, peeringName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Lists all Virtual Router Peerings in a Virtual Router resource.
     * @param resourceGroupName The name of the resource group.
     * @param virtualRouterName The name of the Virtual Router.
     * @param options The options parameters.
     */
    _list(resourceGroupName, virtualRouterName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, virtualRouterName, options }, listOperationSpec$1g);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param virtualRouterName The name of the Virtual Router.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, virtualRouterName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, virtualRouterName, nextLink, options }, listNextOperationSpec$17);
    }
}
// Operation Specifications
const serializer$1o = coreClient.createSerializer(Mappers, /* isXml */ false);
const deleteOperationSpec$T = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualRouters/{virtualRouterName}/peerings/{peeringName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        peeringName,
        virtualRouterName
    ],
    headerParameters: [accept],
    serializer: serializer$1o
};
const getOperationSpec$14 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualRouters/{virtualRouterName}/peerings/{peeringName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualRouterPeering
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        peeringName,
        virtualRouterName
    ],
    headerParameters: [accept],
    serializer: serializer$1o
};
const createOrUpdateOperationSpec$T = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualRouters/{virtualRouterName}/peerings/{peeringName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: VirtualRouterPeering
        },
        201: {
            bodyMapper: VirtualRouterPeering
        },
        202: {
            bodyMapper: VirtualRouterPeering
        },
        204: {
            bodyMapper: VirtualRouterPeering
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    requestBody: parameters69,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        peeringName,
        virtualRouterName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1o
};
const listOperationSpec$1g = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualRouters/{virtualRouterName}/peerings",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualRouterPeeringListResult
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualRouterName
    ],
    headerParameters: [accept],
    serializer: serializer$1o
};
const listNextOperationSpec$17 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualRouterPeeringListResult
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        virtualRouterName
    ],
    headerParameters: [accept],
    serializer: serializer$1o
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing VirtualWans operations. */
class VirtualWansImpl {
    /**
     * Initialize a new instance of the class VirtualWans class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all the VirtualWANs in a resource group.
     * @param resourceGroupName The resource group name of the VirtualWan.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByResourceGroupPagingPage(resourceGroupName, options);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all the VirtualWANs in a subscription.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(options);
            }
        };
    }
    listPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Retrieves the details of a VirtualWAN.
     * @param resourceGroupName The resource group name of the VirtualWan.
     * @param virtualWANName The name of the VirtualWAN being retrieved.
     * @param options The options parameters.
     */
    get(resourceGroupName, virtualWANName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, virtualWANName, options }, getOperationSpec$15);
    }
    /**
     * Creates a VirtualWAN resource if it doesn't exist else updates the existing VirtualWAN.
     * @param resourceGroupName The resource group name of the VirtualWan.
     * @param virtualWANName The name of the VirtualWAN being created or updated.
     * @param wANParameters Parameters supplied to create or update VirtualWAN.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, virtualWANName, wANParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, virtualWANName, wANParameters, options }, createOrUpdateOperationSpec$U);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
        });
    }
    /**
     * Creates a VirtualWAN resource if it doesn't exist else updates the existing VirtualWAN.
     * @param resourceGroupName The resource group name of the VirtualWan.
     * @param virtualWANName The name of the VirtualWAN being created or updated.
     * @param wANParameters Parameters supplied to create or update VirtualWAN.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, virtualWANName, wANParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, virtualWANName, wANParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates a VirtualWAN tags.
     * @param resourceGroupName The resource group name of the VirtualWan.
     * @param virtualWANName The name of the VirtualWAN being updated.
     * @param wANParameters Parameters supplied to Update VirtualWAN tags.
     * @param options The options parameters.
     */
    updateTags(resourceGroupName, virtualWANName, wANParameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, virtualWANName, wANParameters, options }, updateTagsOperationSpec$v);
    }
    /**
     * Deletes a VirtualWAN.
     * @param resourceGroupName The resource group name of the VirtualWan.
     * @param virtualWANName The name of the VirtualWAN being deleted.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, virtualWANName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, virtualWANName, options }, deleteOperationSpec$U);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Deletes a VirtualWAN.
     * @param resourceGroupName The resource group name of the VirtualWan.
     * @param virtualWANName The name of the VirtualWAN being deleted.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, virtualWANName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, virtualWANName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Lists all the VirtualWANs in a resource group.
     * @param resourceGroupName The resource group name of the VirtualWan.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec$f);
    }
    /**
     * Lists all the VirtualWANs in a subscription.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$1h);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The resource group name of the VirtualWan.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec$f);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$18);
    }
}
// Operation Specifications
const serializer$1p = coreClient.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$15 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualWans/{VirtualWANName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualWAN
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualWANName1
    ],
    headerParameters: [accept],
    serializer: serializer$1p
};
const createOrUpdateOperationSpec$U = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualWans/{VirtualWANName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: VirtualWAN
        },
        201: {
            bodyMapper: VirtualWAN
        },
        202: {
            bodyMapper: VirtualWAN
        },
        204: {
            bodyMapper: VirtualWAN
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: wANParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualWANName1
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1p
};
const updateTagsOperationSpec$v = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualWans/{VirtualWANName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: VirtualWAN
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: wANParameters1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualWANName1
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1p
};
const deleteOperationSpec$U = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualWans/{VirtualWANName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualWANName1
    ],
    headerParameters: [accept],
    serializer: serializer$1p
};
const listByResourceGroupOperationSpec$f = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualWans",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListVirtualWANsResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$1p
};
const listOperationSpec$1h = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/virtualWans",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListVirtualWANsResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$1p
};
const listByResourceGroupNextOperationSpec$f = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListVirtualWANsResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$1p
};
const listNextOperationSpec$18 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListVirtualWANsResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$1p
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing VpnSites operations. */
class VpnSitesImpl {
    /**
     * Initialize a new instance of the class VpnSites class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all the vpnSites in a resource group.
     * @param resourceGroupName The resource group name of the VpnSite.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByResourceGroupPagingPage(resourceGroupName, options);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all the VpnSites in a subscription.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(options);
            }
        };
    }
    listPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Retrieves the details of a VPN site.
     * @param resourceGroupName The resource group name of the VpnSite.
     * @param vpnSiteName The name of the VpnSite being retrieved.
     * @param options The options parameters.
     */
    get(resourceGroupName, vpnSiteName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, vpnSiteName, options }, getOperationSpec$16);
    }
    /**
     * Creates a VpnSite resource if it doesn't exist else updates the existing VpnSite.
     * @param resourceGroupName The resource group name of the VpnSite.
     * @param vpnSiteName The name of the VpnSite being created or updated.
     * @param vpnSiteParameters Parameters supplied to create or update VpnSite.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, vpnSiteName, vpnSiteParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, vpnSiteName, vpnSiteParameters, options }, createOrUpdateOperationSpec$V);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
        });
    }
    /**
     * Creates a VpnSite resource if it doesn't exist else updates the existing VpnSite.
     * @param resourceGroupName The resource group name of the VpnSite.
     * @param vpnSiteName The name of the VpnSite being created or updated.
     * @param vpnSiteParameters Parameters supplied to create or update VpnSite.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, vpnSiteName, vpnSiteParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, vpnSiteName, vpnSiteParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates VpnSite tags.
     * @param resourceGroupName The resource group name of the VpnSite.
     * @param vpnSiteName The name of the VpnSite being updated.
     * @param vpnSiteParameters Parameters supplied to update VpnSite tags.
     * @param options The options parameters.
     */
    updateTags(resourceGroupName, vpnSiteName, vpnSiteParameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, vpnSiteName, vpnSiteParameters, options }, updateTagsOperationSpec$w);
    }
    /**
     * Deletes a VpnSite.
     * @param resourceGroupName The resource group name of the VpnSite.
     * @param vpnSiteName The name of the VpnSite being deleted.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, vpnSiteName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, vpnSiteName, options }, deleteOperationSpec$V);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Deletes a VpnSite.
     * @param resourceGroupName The resource group name of the VpnSite.
     * @param vpnSiteName The name of the VpnSite being deleted.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, vpnSiteName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, vpnSiteName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Lists all the vpnSites in a resource group.
     * @param resourceGroupName The resource group name of the VpnSite.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec$g);
    }
    /**
     * Lists all the VpnSites in a subscription.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$1i);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The resource group name of the VpnSite.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec$g);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$19);
    }
}
// Operation Specifications
const serializer$1q = coreClient.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$16 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/vpnSites/{vpnSiteName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VpnSite
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        vpnSiteName
    ],
    headerParameters: [accept],
    serializer: serializer$1q
};
const createOrUpdateOperationSpec$V = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/vpnSites/{vpnSiteName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: VpnSite
        },
        201: {
            bodyMapper: VpnSite
        },
        202: {
            bodyMapper: VpnSite
        },
        204: {
            bodyMapper: VpnSite
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: vpnSiteParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        vpnSiteName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1q
};
const updateTagsOperationSpec$w = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/vpnSites/{vpnSiteName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: VpnSite
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: vpnSiteParameters1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        vpnSiteName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1q
};
const deleteOperationSpec$V = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/vpnSites/{vpnSiteName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        vpnSiteName
    ],
    headerParameters: [accept],
    serializer: serializer$1q
};
const listByResourceGroupOperationSpec$g = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/vpnSites",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListVpnSitesResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$1q
};
const listOperationSpec$1i = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/vpnSites",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListVpnSitesResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$1q
};
const listByResourceGroupNextOperationSpec$g = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListVpnSitesResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$1q
};
const listNextOperationSpec$19 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListVpnSitesResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$1q
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing VpnSiteLinks operations. */
class VpnSiteLinksImpl {
    /**
     * Initialize a new instance of the class VpnSiteLinks class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all the vpnSiteLinks in a resource group for a vpn site.
     * @param resourceGroupName The resource group name of the VpnSite.
     * @param vpnSiteName The name of the VpnSite.
     * @param options The options parameters.
     */
    listByVpnSite(resourceGroupName, vpnSiteName, options) {
        const iter = this.listByVpnSitePagingAll(resourceGroupName, vpnSiteName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByVpnSitePagingPage(resourceGroupName, vpnSiteName, options);
            }
        };
    }
    listByVpnSitePagingPage(resourceGroupName, vpnSiteName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByVpnSitePagingPage_1() {
            let result = yield tslib.__await(this._listByVpnSite(resourceGroupName, vpnSiteName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByVpnSiteNext(resourceGroupName, vpnSiteName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByVpnSitePagingAll(resourceGroupName, vpnSiteName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByVpnSitePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByVpnSitePagingPage(resourceGroupName, vpnSiteName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Retrieves the details of a VPN site link.
     * @param resourceGroupName The resource group name of the VpnSite.
     * @param vpnSiteName The name of the VpnSite.
     * @param vpnSiteLinkName The name of the VpnSiteLink being retrieved.
     * @param options The options parameters.
     */
    get(resourceGroupName, vpnSiteName, vpnSiteLinkName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, vpnSiteName, vpnSiteLinkName, options }, getOperationSpec$17);
    }
    /**
     * Lists all the vpnSiteLinks in a resource group for a vpn site.
     * @param resourceGroupName The resource group name of the VpnSite.
     * @param vpnSiteName The name of the VpnSite.
     * @param options The options parameters.
     */
    _listByVpnSite(resourceGroupName, vpnSiteName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, vpnSiteName, options }, listByVpnSiteOperationSpec);
    }
    /**
     * ListByVpnSiteNext
     * @param resourceGroupName The resource group name of the VpnSite.
     * @param vpnSiteName The name of the VpnSite.
     * @param nextLink The nextLink from the previous successful call to the ListByVpnSite method.
     * @param options The options parameters.
     */
    _listByVpnSiteNext(resourceGroupName, vpnSiteName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, vpnSiteName, nextLink, options }, listByVpnSiteNextOperationSpec);
    }
}
// Operation Specifications
const serializer$1r = coreClient.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$17 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/vpnSites/{vpnSiteName}/vpnSiteLinks/{vpnSiteLinkName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VpnSiteLink
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        vpnSiteName,
        vpnSiteLinkName
    ],
    headerParameters: [accept],
    serializer: serializer$1r
};
const listByVpnSiteOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/vpnSites/{vpnSiteName}/vpnSiteLinks",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListVpnSiteLinksResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        vpnSiteName
    ],
    headerParameters: [accept],
    serializer: serializer$1r
};
const listByVpnSiteNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListVpnSiteLinksResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        vpnSiteName
    ],
    headerParameters: [accept],
    serializer: serializer$1r
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing VpnSitesConfiguration operations. */
class VpnSitesConfigurationImpl {
    /**
     * Initialize a new instance of the class VpnSitesConfiguration class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gives the sas-url to download the configurations for vpn-sites in a resource group.
     * @param resourceGroupName The resource group name.
     * @param virtualWANName The name of the VirtualWAN for which configuration of all vpn-sites is needed.
     * @param request Parameters supplied to download vpn-sites configuration.
     * @param options The options parameters.
     */
    beginDownload(resourceGroupName, virtualWANName, request, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, virtualWANName, request, options }, downloadOperationSpec);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Gives the sas-url to download the configurations for vpn-sites in a resource group.
     * @param resourceGroupName The resource group name.
     * @param virtualWANName The name of the VirtualWAN for which configuration of all vpn-sites is needed.
     * @param request Parameters supplied to download vpn-sites configuration.
     * @param options The options parameters.
     */
    beginDownloadAndWait(resourceGroupName, virtualWANName, request, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDownload(resourceGroupName, virtualWANName, request, options);
            return poller.pollUntilDone();
        });
    }
}
// Operation Specifications
const serializer$1s = coreClient.createSerializer(Mappers, /* isXml */ false);
const downloadOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualWans/{virtualWANName}/vpnConfiguration",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: request2,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualWANName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1s
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing VpnServerConfigurations operations. */
class VpnServerConfigurationsImpl {
    /**
     * Initialize a new instance of the class VpnServerConfigurations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all the vpnServerConfigurations in a resource group.
     * @param resourceGroupName The resource group name of the VpnServerConfiguration.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByResourceGroupPagingPage(resourceGroupName, options);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all the VpnServerConfigurations in a subscription.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(options);
            }
        };
    }
    listPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Retrieves the details of a VpnServerConfiguration.
     * @param resourceGroupName The resource group name of the VpnServerConfiguration.
     * @param vpnServerConfigurationName The name of the VpnServerConfiguration being retrieved.
     * @param options The options parameters.
     */
    get(resourceGroupName, vpnServerConfigurationName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, vpnServerConfigurationName, options }, getOperationSpec$18);
    }
    /**
     * Creates a VpnServerConfiguration resource if it doesn't exist else updates the existing
     * VpnServerConfiguration.
     * @param resourceGroupName The resource group name of the VpnServerConfiguration.
     * @param vpnServerConfigurationName The name of the VpnServerConfiguration being created or updated.
     * @param vpnServerConfigurationParameters Parameters supplied to create or update
     *                                         VpnServerConfiguration.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, vpnServerConfigurationName, vpnServerConfigurationParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                vpnServerConfigurationName,
                vpnServerConfigurationParameters,
                options
            }, createOrUpdateOperationSpec$W);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
        });
    }
    /**
     * Creates a VpnServerConfiguration resource if it doesn't exist else updates the existing
     * VpnServerConfiguration.
     * @param resourceGroupName The resource group name of the VpnServerConfiguration.
     * @param vpnServerConfigurationName The name of the VpnServerConfiguration being created or updated.
     * @param vpnServerConfigurationParameters Parameters supplied to create or update
     *                                         VpnServerConfiguration.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, vpnServerConfigurationName, vpnServerConfigurationParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, vpnServerConfigurationName, vpnServerConfigurationParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates VpnServerConfiguration tags.
     * @param resourceGroupName The resource group name of the VpnServerConfiguration.
     * @param vpnServerConfigurationName The name of the VpnServerConfiguration being updated.
     * @param vpnServerConfigurationParameters Parameters supplied to update VpnServerConfiguration tags.
     * @param options The options parameters.
     */
    updateTags(resourceGroupName, vpnServerConfigurationName, vpnServerConfigurationParameters, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            vpnServerConfigurationName,
            vpnServerConfigurationParameters,
            options
        }, updateTagsOperationSpec$x);
    }
    /**
     * Deletes a VpnServerConfiguration.
     * @param resourceGroupName The resource group name of the VpnServerConfiguration.
     * @param vpnServerConfigurationName The name of the VpnServerConfiguration being deleted.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, vpnServerConfigurationName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, vpnServerConfigurationName, options }, deleteOperationSpec$W);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Deletes a VpnServerConfiguration.
     * @param resourceGroupName The resource group name of the VpnServerConfiguration.
     * @param vpnServerConfigurationName The name of the VpnServerConfiguration being deleted.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, vpnServerConfigurationName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, vpnServerConfigurationName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Lists all the vpnServerConfigurations in a resource group.
     * @param resourceGroupName The resource group name of the VpnServerConfiguration.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec$h);
    }
    /**
     * Lists all the VpnServerConfigurations in a subscription.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$1j);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The resource group name of the VpnServerConfiguration.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec$h);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$1a);
    }
}
// Operation Specifications
const serializer$1t = coreClient.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$18 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/vpnServerConfigurations/{vpnServerConfigurationName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VpnServerConfiguration
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        vpnServerConfigurationName
    ],
    headerParameters: [accept],
    serializer: serializer$1t
};
const createOrUpdateOperationSpec$W = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/vpnServerConfigurations/{vpnServerConfigurationName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: VpnServerConfiguration
        },
        201: {
            bodyMapper: VpnServerConfiguration
        },
        202: {
            bodyMapper: VpnServerConfiguration
        },
        204: {
            bodyMapper: VpnServerConfiguration
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: vpnServerConfigurationParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        vpnServerConfigurationName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1t
};
const updateTagsOperationSpec$x = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/vpnServerConfigurations/{vpnServerConfigurationName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: VpnServerConfiguration
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: vpnServerConfigurationParameters1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        vpnServerConfigurationName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1t
};
const deleteOperationSpec$W = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/vpnServerConfigurations/{vpnServerConfigurationName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        vpnServerConfigurationName
    ],
    headerParameters: [accept],
    serializer: serializer$1t
};
const listByResourceGroupOperationSpec$h = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/vpnServerConfigurations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListVpnServerConfigurationsResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$1t
};
const listOperationSpec$1j = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/vpnServerConfigurations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListVpnServerConfigurationsResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$1t
};
const listByResourceGroupNextOperationSpec$h = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListVpnServerConfigurationsResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$1t
};
const listNextOperationSpec$1a = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListVpnServerConfigurationsResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$1t
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing VirtualHubs operations. */
class VirtualHubsImpl {
    /**
     * Initialize a new instance of the class VirtualHubs class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all the VirtualHubs in a resource group.
     * @param resourceGroupName The resource group name of the VirtualHub.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByResourceGroupPagingPage(resourceGroupName, options);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all the VirtualHubs in a subscription.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(options);
            }
        };
    }
    listPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Retrieves the details of a VirtualHub.
     * @param resourceGroupName The resource group name of the VirtualHub.
     * @param virtualHubName The name of the VirtualHub.
     * @param options The options parameters.
     */
    get(resourceGroupName, virtualHubName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, virtualHubName, options }, getOperationSpec$19);
    }
    /**
     * Creates a VirtualHub resource if it doesn't exist else updates the existing VirtualHub.
     * @param resourceGroupName The resource group name of the VirtualHub.
     * @param virtualHubName The name of the VirtualHub.
     * @param virtualHubParameters Parameters supplied to create or update VirtualHub.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, virtualHubName, virtualHubParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, virtualHubName, virtualHubParameters, options }, createOrUpdateOperationSpec$X);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
        });
    }
    /**
     * Creates a VirtualHub resource if it doesn't exist else updates the existing VirtualHub.
     * @param resourceGroupName The resource group name of the VirtualHub.
     * @param virtualHubName The name of the VirtualHub.
     * @param virtualHubParameters Parameters supplied to create or update VirtualHub.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, virtualHubName, virtualHubParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, virtualHubName, virtualHubParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates VirtualHub tags.
     * @param resourceGroupName The resource group name of the VirtualHub.
     * @param virtualHubName The name of the VirtualHub.
     * @param virtualHubParameters Parameters supplied to update VirtualHub tags.
     * @param options The options parameters.
     */
    updateTags(resourceGroupName, virtualHubName, virtualHubParameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, virtualHubName, virtualHubParameters, options }, updateTagsOperationSpec$y);
    }
    /**
     * Deletes a VirtualHub.
     * @param resourceGroupName The resource group name of the VirtualHub.
     * @param virtualHubName The name of the VirtualHub.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, virtualHubName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, virtualHubName, options }, deleteOperationSpec$X);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Deletes a VirtualHub.
     * @param resourceGroupName The resource group name of the VirtualHub.
     * @param virtualHubName The name of the VirtualHub.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, virtualHubName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, virtualHubName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Lists all the VirtualHubs in a resource group.
     * @param resourceGroupName The resource group name of the VirtualHub.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec$i);
    }
    /**
     * Lists all the VirtualHubs in a subscription.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$1k);
    }
    /**
     * Gets the effective routes configured for the Virtual Hub resource or the specified resource .
     * @param resourceGroupName The resource group name of the VirtualHub.
     * @param virtualHubName The name of the VirtualHub.
     * @param options The options parameters.
     */
    beginGetEffectiveVirtualHubRoutes(resourceGroupName, virtualHubName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, virtualHubName, options }, getEffectiveVirtualHubRoutesOperationSpec);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Gets the effective routes configured for the Virtual Hub resource or the specified resource .
     * @param resourceGroupName The resource group name of the VirtualHub.
     * @param virtualHubName The name of the VirtualHub.
     * @param options The options parameters.
     */
    beginGetEffectiveVirtualHubRoutesAndWait(resourceGroupName, virtualHubName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginGetEffectiveVirtualHubRoutes(resourceGroupName, virtualHubName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The resource group name of the VirtualHub.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec$i);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$1b);
    }
}
// Operation Specifications
const serializer$1u = coreClient.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$19 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualHubs/{virtualHubName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualHub
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualHubName
    ],
    headerParameters: [accept],
    serializer: serializer$1u
};
const createOrUpdateOperationSpec$X = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualHubs/{virtualHubName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: VirtualHub
        },
        201: {
            bodyMapper: VirtualHub
        },
        202: {
            bodyMapper: VirtualHub
        },
        204: {
            bodyMapper: VirtualHub
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: virtualHubParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualHubName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1u
};
const updateTagsOperationSpec$y = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualHubs/{virtualHubName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: VirtualHub
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: virtualHubParameters1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualHubName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1u
};
const deleteOperationSpec$X = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualHubs/{virtualHubName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualHubName
    ],
    headerParameters: [accept],
    serializer: serializer$1u
};
const listByResourceGroupOperationSpec$i = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualHubs",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListVirtualHubsResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$1u
};
const listOperationSpec$1k = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/virtualHubs",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListVirtualHubsResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$1u
};
const getEffectiveVirtualHubRoutesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualHubs/{virtualHubName}/effectiveRoutes",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: effectiveRoutesParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualHubName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1u
};
const listByResourceGroupNextOperationSpec$i = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListVirtualHubsResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$1u
};
const listNextOperationSpec$1b = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListVirtualHubsResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$1u
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing HubVirtualNetworkConnections operations. */
class HubVirtualNetworkConnectionsImpl {
    /**
     * Initialize a new instance of the class HubVirtualNetworkConnections class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Retrieves the details of all HubVirtualNetworkConnections.
     * @param resourceGroupName The resource group name of the VirtualHub.
     * @param virtualHubName The name of the VirtualHub.
     * @param options The options parameters.
     */
    list(resourceGroupName, virtualHubName, options) {
        const iter = this.listPagingAll(resourceGroupName, virtualHubName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, virtualHubName, options);
            }
        };
    }
    listPagingPage(resourceGroupName, virtualHubName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, virtualHubName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, virtualHubName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceGroupName, virtualHubName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, virtualHubName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Creates a hub virtual network connection if it doesn't exist else updates the existing one.
     * @param resourceGroupName The resource group name of the HubVirtualNetworkConnection.
     * @param virtualHubName The name of the VirtualHub.
     * @param connectionName The name of the HubVirtualNetworkConnection.
     * @param hubVirtualNetworkConnectionParameters Parameters supplied to create or update a hub virtual
     *                                              network connection.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, virtualHubName, connectionName, hubVirtualNetworkConnectionParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                virtualHubName,
                connectionName,
                hubVirtualNetworkConnectionParameters,
                options
            }, createOrUpdateOperationSpec$Y);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
        });
    }
    /**
     * Creates a hub virtual network connection if it doesn't exist else updates the existing one.
     * @param resourceGroupName The resource group name of the HubVirtualNetworkConnection.
     * @param virtualHubName The name of the VirtualHub.
     * @param connectionName The name of the HubVirtualNetworkConnection.
     * @param hubVirtualNetworkConnectionParameters Parameters supplied to create or update a hub virtual
     *                                              network connection.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, virtualHubName, connectionName, hubVirtualNetworkConnectionParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, virtualHubName, connectionName, hubVirtualNetworkConnectionParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes a HubVirtualNetworkConnection.
     * @param resourceGroupName The resource group name of the VirtualHub.
     * @param virtualHubName The name of the VirtualHub.
     * @param connectionName The name of the HubVirtualNetworkConnection.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, virtualHubName, connectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, virtualHubName, connectionName, options }, deleteOperationSpec$Y);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Deletes a HubVirtualNetworkConnection.
     * @param resourceGroupName The resource group name of the VirtualHub.
     * @param virtualHubName The name of the VirtualHub.
     * @param connectionName The name of the HubVirtualNetworkConnection.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, virtualHubName, connectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, virtualHubName, connectionName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Retrieves the details of a HubVirtualNetworkConnection.
     * @param resourceGroupName The resource group name of the VirtualHub.
     * @param virtualHubName The name of the VirtualHub.
     * @param connectionName The name of the vpn connection.
     * @param options The options parameters.
     */
    get(resourceGroupName, virtualHubName, connectionName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, virtualHubName, connectionName, options }, getOperationSpec$1a);
    }
    /**
     * Retrieves the details of all HubVirtualNetworkConnections.
     * @param resourceGroupName The resource group name of the VirtualHub.
     * @param virtualHubName The name of the VirtualHub.
     * @param options The options parameters.
     */
    _list(resourceGroupName, virtualHubName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, virtualHubName, options }, listOperationSpec$1l);
    }
    /**
     * ListNext
     * @param resourceGroupName The resource group name of the VirtualHub.
     * @param virtualHubName The name of the VirtualHub.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, virtualHubName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, virtualHubName, nextLink, options }, listNextOperationSpec$1c);
    }
}
// Operation Specifications
const serializer$1v = coreClient.createSerializer(Mappers, /* isXml */ false);
const createOrUpdateOperationSpec$Y = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualHubs/{virtualHubName}/hubVirtualNetworkConnections/{connectionName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: HubVirtualNetworkConnection
        },
        201: {
            bodyMapper: HubVirtualNetworkConnection
        },
        202: {
            bodyMapper: HubVirtualNetworkConnection
        },
        204: {
            bodyMapper: HubVirtualNetworkConnection
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: hubVirtualNetworkConnectionParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        connectionName,
        virtualHubName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1v
};
const deleteOperationSpec$Y = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualHubs/{virtualHubName}/hubVirtualNetworkConnections/{connectionName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        connectionName,
        virtualHubName
    ],
    headerParameters: [accept],
    serializer: serializer$1v
};
const getOperationSpec$1a = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualHubs/{virtualHubName}/hubVirtualNetworkConnections/{connectionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: HubVirtualNetworkConnection
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        connectionName,
        virtualHubName
    ],
    headerParameters: [accept],
    serializer: serializer$1v
};
const listOperationSpec$1l = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualHubs/{virtualHubName}/hubVirtualNetworkConnections",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListHubVirtualNetworkConnectionsResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualHubName
    ],
    headerParameters: [accept],
    serializer: serializer$1v
};
const listNextOperationSpec$1c = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListHubVirtualNetworkConnectionsResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        virtualHubName
    ],
    headerParameters: [accept],
    serializer: serializer$1v
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing VpnGateways operations. */
class VpnGatewaysImpl {
    /**
     * Initialize a new instance of the class VpnGateways class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all the VpnGateways in a resource group.
     * @param resourceGroupName The resource group name of the VpnGateway.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByResourceGroupPagingPage(resourceGroupName, options);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all the VpnGateways in a subscription.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(options);
            }
        };
    }
    listPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Retrieves the details of a virtual wan vpn gateway.
     * @param resourceGroupName The resource group name of the VpnGateway.
     * @param gatewayName The name of the gateway.
     * @param options The options parameters.
     */
    get(resourceGroupName, gatewayName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, gatewayName, options }, getOperationSpec$1b);
    }
    /**
     * Creates a virtual wan vpn gateway if it doesn't exist else updates the existing gateway.
     * @param resourceGroupName The resource group name of the VpnGateway.
     * @param gatewayName The name of the gateway.
     * @param vpnGatewayParameters Parameters supplied to create or Update a virtual wan vpn gateway.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, gatewayName, vpnGatewayParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, gatewayName, vpnGatewayParameters, options }, createOrUpdateOperationSpec$Z);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
        });
    }
    /**
     * Creates a virtual wan vpn gateway if it doesn't exist else updates the existing gateway.
     * @param resourceGroupName The resource group name of the VpnGateway.
     * @param gatewayName The name of the gateway.
     * @param vpnGatewayParameters Parameters supplied to create or Update a virtual wan vpn gateway.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, gatewayName, vpnGatewayParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, gatewayName, vpnGatewayParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates virtual wan vpn gateway tags.
     * @param resourceGroupName The resource group name of the VpnGateway.
     * @param gatewayName The name of the gateway.
     * @param vpnGatewayParameters Parameters supplied to update a virtual wan vpn gateway tags.
     * @param options The options parameters.
     */
    beginUpdateTags(resourceGroupName, gatewayName, vpnGatewayParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, gatewayName, vpnGatewayParameters, options }, updateTagsOperationSpec$z);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
        });
    }
    /**
     * Updates virtual wan vpn gateway tags.
     * @param resourceGroupName The resource group name of the VpnGateway.
     * @param gatewayName The name of the gateway.
     * @param vpnGatewayParameters Parameters supplied to update a virtual wan vpn gateway tags.
     * @param options The options parameters.
     */
    beginUpdateTagsAndWait(resourceGroupName, gatewayName, vpnGatewayParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdateTags(resourceGroupName, gatewayName, vpnGatewayParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes a virtual wan vpn gateway.
     * @param resourceGroupName The resource group name of the VpnGateway.
     * @param gatewayName The name of the gateway.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, gatewayName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, gatewayName, options }, deleteOperationSpec$Z);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Deletes a virtual wan vpn gateway.
     * @param resourceGroupName The resource group name of the VpnGateway.
     * @param gatewayName The name of the gateway.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, gatewayName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, gatewayName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Resets the primary of the vpn gateway in the specified resource group.
     * @param resourceGroupName The resource group name of the VpnGateway.
     * @param gatewayName The name of the gateway.
     * @param options The options parameters.
     */
    beginReset(resourceGroupName, gatewayName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, gatewayName, options }, resetOperationSpec$1);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Resets the primary of the vpn gateway in the specified resource group.
     * @param resourceGroupName The resource group name of the VpnGateway.
     * @param gatewayName The name of the gateway.
     * @param options The options parameters.
     */
    beginResetAndWait(resourceGroupName, gatewayName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginReset(resourceGroupName, gatewayName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Starts packet capture on vpn gateway in the specified resource group.
     * @param resourceGroupName The resource group name of the VpnGateway.
     * @param gatewayName The name of the gateway.
     * @param options The options parameters.
     */
    beginStartPacketCapture(resourceGroupName, gatewayName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, gatewayName, options }, startPacketCaptureOperationSpec$2);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Starts packet capture on vpn gateway in the specified resource group.
     * @param resourceGroupName The resource group name of the VpnGateway.
     * @param gatewayName The name of the gateway.
     * @param options The options parameters.
     */
    beginStartPacketCaptureAndWait(resourceGroupName, gatewayName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginStartPacketCapture(resourceGroupName, gatewayName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Stops packet capture on vpn gateway in the specified resource group.
     * @param resourceGroupName The resource group name of the VpnGateway.
     * @param gatewayName The name of the gateway.
     * @param options The options parameters.
     */
    beginStopPacketCapture(resourceGroupName, gatewayName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, gatewayName, options }, stopPacketCaptureOperationSpec$2);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Stops packet capture on vpn gateway in the specified resource group.
     * @param resourceGroupName The resource group name of the VpnGateway.
     * @param gatewayName The name of the gateway.
     * @param options The options parameters.
     */
    beginStopPacketCaptureAndWait(resourceGroupName, gatewayName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginStopPacketCapture(resourceGroupName, gatewayName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Lists all the VpnGateways in a resource group.
     * @param resourceGroupName The resource group name of the VpnGateway.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec$j);
    }
    /**
     * Lists all the VpnGateways in a subscription.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$1m);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The resource group name of the VpnGateway.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec$j);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$1d);
    }
}
// Operation Specifications
const serializer$1w = coreClient.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$1b = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/vpnGateways/{gatewayName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VpnGateway
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        gatewayName
    ],
    headerParameters: [accept],
    serializer: serializer$1w
};
const createOrUpdateOperationSpec$Z = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/vpnGateways/{gatewayName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: VpnGateway
        },
        201: {
            bodyMapper: VpnGateway
        },
        202: {
            bodyMapper: VpnGateway
        },
        204: {
            bodyMapper: VpnGateway
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: vpnGatewayParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        gatewayName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1w
};
const updateTagsOperationSpec$z = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/vpnGateways/{gatewayName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: VpnGateway
        },
        201: {
            bodyMapper: VpnGateway
        },
        202: {
            bodyMapper: VpnGateway
        },
        204: {
            bodyMapper: VpnGateway
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: vpnGatewayParameters1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        gatewayName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1w
};
const deleteOperationSpec$Z = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/vpnGateways/{gatewayName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        gatewayName
    ],
    headerParameters: [accept],
    serializer: serializer$1w
};
const resetOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/vpnGateways/{gatewayName}/reset",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: VpnGateway
        },
        201: {
            bodyMapper: VpnGateway
        },
        202: {
            bodyMapper: VpnGateway
        },
        204: {
            bodyMapper: VpnGateway
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        gatewayName
    ],
    headerParameters: [accept],
    serializer: serializer$1w
};
const startPacketCaptureOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/vpnGateways/{gatewayName}/startpacketcapture",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: { type: { name: "String" } }
        },
        201: {
            bodyMapper: { type: { name: "String" } }
        },
        202: {
            bodyMapper: { type: { name: "String" } }
        },
        204: {
            bodyMapper: { type: { name: "String" } }
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters70,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        gatewayName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1w
};
const stopPacketCaptureOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/vpnGateways/{gatewayName}/stoppacketcapture",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: { type: { name: "String" } }
        },
        201: {
            bodyMapper: { type: { name: "String" } }
        },
        202: {
            bodyMapper: { type: { name: "String" } }
        },
        204: {
            bodyMapper: { type: { name: "String" } }
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters71,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        gatewayName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1w
};
const listByResourceGroupOperationSpec$j = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/vpnGateways",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListVpnGatewaysResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$1w
};
const listOperationSpec$1m = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/vpnGateways",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListVpnGatewaysResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$1w
};
const listByResourceGroupNextOperationSpec$j = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListVpnGatewaysResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$1w
};
const listNextOperationSpec$1d = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListVpnGatewaysResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$1w
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing VpnLinkConnections operations. */
class VpnLinkConnectionsImpl {
    /**
     * Initialize a new instance of the class VpnLinkConnections class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Retrieves all vpn site link connections for a particular virtual wan vpn gateway vpn connection.
     * @param resourceGroupName The resource group name of the vpn gateway.
     * @param gatewayName The name of the gateway.
     * @param connectionName The name of the vpn connection.
     * @param options The options parameters.
     */
    listByVpnConnection(resourceGroupName, gatewayName, connectionName, options) {
        const iter = this.listByVpnConnectionPagingAll(resourceGroupName, gatewayName, connectionName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByVpnConnectionPagingPage(resourceGroupName, gatewayName, connectionName, options);
            }
        };
    }
    listByVpnConnectionPagingPage(resourceGroupName, gatewayName, connectionName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByVpnConnectionPagingPage_1() {
            let result = yield tslib.__await(this._listByVpnConnection(resourceGroupName, gatewayName, connectionName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByVpnConnectionNext(resourceGroupName, gatewayName, connectionName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByVpnConnectionPagingAll(resourceGroupName, gatewayName, connectionName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByVpnConnectionPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByVpnConnectionPagingPage(resourceGroupName, gatewayName, connectionName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Resets the VpnLink connection specified.
     * @param resourceGroupName The name of the resource group.
     * @param gatewayName The name of the gateway.
     * @param connectionName The name of the vpn connection.
     * @param linkConnectionName The name of the vpn link connection.
     * @param options The options parameters.
     */
    beginResetConnection(resourceGroupName, gatewayName, connectionName, linkConnectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                gatewayName,
                connectionName,
                linkConnectionName,
                options
            }, resetConnectionOperationSpec$1);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Resets the VpnLink connection specified.
     * @param resourceGroupName The name of the resource group.
     * @param gatewayName The name of the gateway.
     * @param connectionName The name of the vpn connection.
     * @param linkConnectionName The name of the vpn link connection.
     * @param options The options parameters.
     */
    beginResetConnectionAndWait(resourceGroupName, gatewayName, connectionName, linkConnectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginResetConnection(resourceGroupName, gatewayName, connectionName, linkConnectionName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Lists IKE Security Associations for Vpn Site Link Connection in the specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param gatewayName The name of the gateway.
     * @param connectionName The name of the vpn connection.
     * @param linkConnectionName The name of the vpn link connection.
     * @param options The options parameters.
     */
    beginGetIkeSas(resourceGroupName, gatewayName, connectionName, linkConnectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                gatewayName,
                connectionName,
                linkConnectionName,
                options
            }, getIkeSasOperationSpec$1);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Lists IKE Security Associations for Vpn Site Link Connection in the specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param gatewayName The name of the gateway.
     * @param connectionName The name of the vpn connection.
     * @param linkConnectionName The name of the vpn link connection.
     * @param options The options parameters.
     */
    beginGetIkeSasAndWait(resourceGroupName, gatewayName, connectionName, linkConnectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginGetIkeSas(resourceGroupName, gatewayName, connectionName, linkConnectionName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Retrieves all vpn site link connections for a particular virtual wan vpn gateway vpn connection.
     * @param resourceGroupName The resource group name of the vpn gateway.
     * @param gatewayName The name of the gateway.
     * @param connectionName The name of the vpn connection.
     * @param options The options parameters.
     */
    _listByVpnConnection(resourceGroupName, gatewayName, connectionName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, gatewayName, connectionName, options }, listByVpnConnectionOperationSpec);
    }
    /**
     * ListByVpnConnectionNext
     * @param resourceGroupName The resource group name of the vpn gateway.
     * @param gatewayName The name of the gateway.
     * @param connectionName The name of the vpn connection.
     * @param nextLink The nextLink from the previous successful call to the ListByVpnConnection method.
     * @param options The options parameters.
     */
    _listByVpnConnectionNext(resourceGroupName, gatewayName, connectionName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, gatewayName, connectionName, nextLink, options }, listByVpnConnectionNextOperationSpec);
    }
}
// Operation Specifications
const serializer$1x = coreClient.createSerializer(Mappers, /* isXml */ false);
const resetConnectionOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/vpnGateways/{gatewayName}/vpnConnections/{connectionName}/vpnLinkConnections/{linkConnectionName}/resetconnection",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        connectionName,
        gatewayName,
        linkConnectionName
    ],
    headerParameters: [accept],
    serializer: serializer$1x
};
const getIkeSasOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/vpnGateways/{gatewayName}/vpnConnections/{connectionName}/vpnLinkConnections/{linkConnectionName}/getikesas",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: { type: { name: "String" } }
        },
        201: {
            bodyMapper: { type: { name: "String" } }
        },
        202: {
            bodyMapper: { type: { name: "String" } }
        },
        204: {
            bodyMapper: { type: { name: "String" } }
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        connectionName,
        gatewayName,
        linkConnectionName
    ],
    headerParameters: [accept],
    serializer: serializer$1x
};
const listByVpnConnectionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/vpnGateways/{gatewayName}/vpnConnections/{connectionName}/vpnLinkConnections",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListVpnSiteLinkConnectionsResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        connectionName,
        gatewayName
    ],
    headerParameters: [accept],
    serializer: serializer$1x
};
const listByVpnConnectionNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListVpnSiteLinkConnectionsResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        connectionName,
        gatewayName
    ],
    headerParameters: [accept],
    serializer: serializer$1x
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing VpnConnections operations. */
class VpnConnectionsImpl {
    /**
     * Initialize a new instance of the class VpnConnections class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Retrieves all vpn connections for a particular virtual wan vpn gateway.
     * @param resourceGroupName The resource group name of the VpnGateway.
     * @param gatewayName The name of the gateway.
     * @param options The options parameters.
     */
    listByVpnGateway(resourceGroupName, gatewayName, options) {
        const iter = this.listByVpnGatewayPagingAll(resourceGroupName, gatewayName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByVpnGatewayPagingPage(resourceGroupName, gatewayName, options);
            }
        };
    }
    listByVpnGatewayPagingPage(resourceGroupName, gatewayName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByVpnGatewayPagingPage_1() {
            let result = yield tslib.__await(this._listByVpnGateway(resourceGroupName, gatewayName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByVpnGatewayNext(resourceGroupName, gatewayName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByVpnGatewayPagingAll(resourceGroupName, gatewayName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByVpnGatewayPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByVpnGatewayPagingPage(resourceGroupName, gatewayName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Retrieves the details of a vpn connection.
     * @param resourceGroupName The resource group name of the VpnGateway.
     * @param gatewayName The name of the gateway.
     * @param connectionName The name of the vpn connection.
     * @param options The options parameters.
     */
    get(resourceGroupName, gatewayName, connectionName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, gatewayName, connectionName, options }, getOperationSpec$1c);
    }
    /**
     * Creates a vpn connection to a scalable vpn gateway if it doesn't exist else updates the existing
     * connection.
     * @param resourceGroupName The resource group name of the VpnGateway.
     * @param gatewayName The name of the gateway.
     * @param connectionName The name of the connection.
     * @param vpnConnectionParameters Parameters supplied to create or Update a VPN Connection.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, gatewayName, connectionName, vpnConnectionParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                gatewayName,
                connectionName,
                vpnConnectionParameters,
                options
            }, createOrUpdateOperationSpec$_);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
        });
    }
    /**
     * Creates a vpn connection to a scalable vpn gateway if it doesn't exist else updates the existing
     * connection.
     * @param resourceGroupName The resource group name of the VpnGateway.
     * @param gatewayName The name of the gateway.
     * @param connectionName The name of the connection.
     * @param vpnConnectionParameters Parameters supplied to create or Update a VPN Connection.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, gatewayName, connectionName, vpnConnectionParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, gatewayName, connectionName, vpnConnectionParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes a vpn connection.
     * @param resourceGroupName The resource group name of the VpnGateway.
     * @param gatewayName The name of the gateway.
     * @param connectionName The name of the connection.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, gatewayName, connectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, gatewayName, connectionName, options }, deleteOperationSpec$_);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Deletes a vpn connection.
     * @param resourceGroupName The resource group name of the VpnGateway.
     * @param gatewayName The name of the gateway.
     * @param connectionName The name of the connection.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, gatewayName, connectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, gatewayName, connectionName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Starts packet capture on Vpn connection in the specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param gatewayName The name of the gateway.
     * @param vpnConnectionName The name of the vpn connection.
     * @param options The options parameters.
     */
    beginStartPacketCapture(resourceGroupName, gatewayName, vpnConnectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, gatewayName, vpnConnectionName, options }, startPacketCaptureOperationSpec$3);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Starts packet capture on Vpn connection in the specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param gatewayName The name of the gateway.
     * @param vpnConnectionName The name of the vpn connection.
     * @param options The options parameters.
     */
    beginStartPacketCaptureAndWait(resourceGroupName, gatewayName, vpnConnectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginStartPacketCapture(resourceGroupName, gatewayName, vpnConnectionName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Stops packet capture on Vpn connection in the specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param gatewayName The name of the gateway.
     * @param vpnConnectionName The name of the vpn connection.
     * @param options The options parameters.
     */
    beginStopPacketCapture(resourceGroupName, gatewayName, vpnConnectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, gatewayName, vpnConnectionName, options }, stopPacketCaptureOperationSpec$3);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Stops packet capture on Vpn connection in the specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param gatewayName The name of the gateway.
     * @param vpnConnectionName The name of the vpn connection.
     * @param options The options parameters.
     */
    beginStopPacketCaptureAndWait(resourceGroupName, gatewayName, vpnConnectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginStopPacketCapture(resourceGroupName, gatewayName, vpnConnectionName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Retrieves all vpn connections for a particular virtual wan vpn gateway.
     * @param resourceGroupName The resource group name of the VpnGateway.
     * @param gatewayName The name of the gateway.
     * @param options The options parameters.
     */
    _listByVpnGateway(resourceGroupName, gatewayName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, gatewayName, options }, listByVpnGatewayOperationSpec);
    }
    /**
     * ListByVpnGatewayNext
     * @param resourceGroupName The resource group name of the VpnGateway.
     * @param gatewayName The name of the gateway.
     * @param nextLink The nextLink from the previous successful call to the ListByVpnGateway method.
     * @param options The options parameters.
     */
    _listByVpnGatewayNext(resourceGroupName, gatewayName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, gatewayName, nextLink, options }, listByVpnGatewayNextOperationSpec);
    }
}
// Operation Specifications
const serializer$1y = coreClient.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$1c = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/vpnGateways/{gatewayName}/vpnConnections/{connectionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VpnConnection
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        connectionName,
        gatewayName
    ],
    headerParameters: [accept],
    serializer: serializer$1y
};
const createOrUpdateOperationSpec$_ = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/vpnGateways/{gatewayName}/vpnConnections/{connectionName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: VpnConnection
        },
        201: {
            bodyMapper: VpnConnection
        },
        202: {
            bodyMapper: VpnConnection
        },
        204: {
            bodyMapper: VpnConnection
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: vpnConnectionParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        connectionName,
        gatewayName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1y
};
const deleteOperationSpec$_ = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/vpnGateways/{gatewayName}/vpnConnections/{connectionName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        connectionName,
        gatewayName
    ],
    headerParameters: [accept],
    serializer: serializer$1y
};
const startPacketCaptureOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/vpnGateways/{gatewayName}/vpnConnections/{vpnConnectionName}/startpacketcapture",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: { type: { name: "String" } }
        },
        201: {
            bodyMapper: { type: { name: "String" } }
        },
        202: {
            bodyMapper: { type: { name: "String" } }
        },
        204: {
            bodyMapper: { type: { name: "String" } }
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters72,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        gatewayName,
        vpnConnectionName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1y
};
const stopPacketCaptureOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/vpnGateways/{gatewayName}/vpnConnections/{vpnConnectionName}/stoppacketcapture",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: { type: { name: "String" } }
        },
        201: {
            bodyMapper: { type: { name: "String" } }
        },
        202: {
            bodyMapper: { type: { name: "String" } }
        },
        204: {
            bodyMapper: { type: { name: "String" } }
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters73,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        gatewayName,
        vpnConnectionName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1y
};
const listByVpnGatewayOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/vpnGateways/{gatewayName}/vpnConnections",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListVpnConnectionsResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        gatewayName
    ],
    headerParameters: [accept],
    serializer: serializer$1y
};
const listByVpnGatewayNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListVpnConnectionsResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        gatewayName
    ],
    headerParameters: [accept],
    serializer: serializer$1y
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing VpnSiteLinkConnections operations. */
class VpnSiteLinkConnectionsImpl {
    /**
     * Initialize a new instance of the class VpnSiteLinkConnections class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Retrieves the details of a vpn site link connection.
     * @param resourceGroupName The resource group name of the VpnGateway.
     * @param gatewayName The name of the gateway.
     * @param connectionName The name of the vpn connection.
     * @param linkConnectionName The name of the vpn connection.
     * @param options The options parameters.
     */
    get(resourceGroupName, gatewayName, connectionName, linkConnectionName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            gatewayName,
            connectionName,
            linkConnectionName,
            options
        }, getOperationSpec$1d);
    }
}
// Operation Specifications
const serializer$1z = coreClient.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$1d = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/vpnGateways/{gatewayName}/vpnConnections/{connectionName}/vpnLinkConnections/{linkConnectionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VpnSiteLinkConnection
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        connectionName,
        gatewayName,
        linkConnectionName
    ],
    headerParameters: [accept],
    serializer: serializer$1z
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing NatRules operations. */
class NatRulesImpl {
    /**
     * Initialize a new instance of the class NatRules class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Retrieves all nat rules for a particular virtual wan vpn gateway.
     * @param resourceGroupName The resource group name of the VpnGateway.
     * @param gatewayName The name of the gateway.
     * @param options The options parameters.
     */
    listByVpnGateway(resourceGroupName, gatewayName, options) {
        const iter = this.listByVpnGatewayPagingAll(resourceGroupName, gatewayName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByVpnGatewayPagingPage(resourceGroupName, gatewayName, options);
            }
        };
    }
    listByVpnGatewayPagingPage(resourceGroupName, gatewayName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByVpnGatewayPagingPage_1() {
            let result = yield tslib.__await(this._listByVpnGateway(resourceGroupName, gatewayName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByVpnGatewayNext(resourceGroupName, gatewayName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByVpnGatewayPagingAll(resourceGroupName, gatewayName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByVpnGatewayPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByVpnGatewayPagingPage(resourceGroupName, gatewayName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Retrieves the details of a nat ruleGet.
     * @param resourceGroupName The resource group name of the VpnGateway.
     * @param gatewayName The name of the gateway.
     * @param natRuleName The name of the nat rule.
     * @param options The options parameters.
     */
    get(resourceGroupName, gatewayName, natRuleName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, gatewayName, natRuleName, options }, getOperationSpec$1e);
    }
    /**
     * Creates a nat rule to a scalable vpn gateway if it doesn't exist else updates the existing nat
     * rules.
     * @param resourceGroupName The resource group name of the VpnGateway.
     * @param gatewayName The name of the gateway.
     * @param natRuleName The name of the nat rule.
     * @param natRuleParameters Parameters supplied to create or Update a Nat Rule.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, gatewayName, natRuleName, natRuleParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                gatewayName,
                natRuleName,
                natRuleParameters,
                options
            }, createOrUpdateOperationSpec$$);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
        });
    }
    /**
     * Creates a nat rule to a scalable vpn gateway if it doesn't exist else updates the existing nat
     * rules.
     * @param resourceGroupName The resource group name of the VpnGateway.
     * @param gatewayName The name of the gateway.
     * @param natRuleName The name of the nat rule.
     * @param natRuleParameters Parameters supplied to create or Update a Nat Rule.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, gatewayName, natRuleName, natRuleParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, gatewayName, natRuleName, natRuleParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes a nat rule.
     * @param resourceGroupName The resource group name of the VpnGateway.
     * @param gatewayName The name of the gateway.
     * @param natRuleName The name of the nat rule.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, gatewayName, natRuleName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, gatewayName, natRuleName, options }, deleteOperationSpec$$);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Deletes a nat rule.
     * @param resourceGroupName The resource group name of the VpnGateway.
     * @param gatewayName The name of the gateway.
     * @param natRuleName The name of the nat rule.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, gatewayName, natRuleName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, gatewayName, natRuleName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Retrieves all nat rules for a particular virtual wan vpn gateway.
     * @param resourceGroupName The resource group name of the VpnGateway.
     * @param gatewayName The name of the gateway.
     * @param options The options parameters.
     */
    _listByVpnGateway(resourceGroupName, gatewayName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, gatewayName, options }, listByVpnGatewayOperationSpec$1);
    }
    /**
     * ListByVpnGatewayNext
     * @param resourceGroupName The resource group name of the VpnGateway.
     * @param gatewayName The name of the gateway.
     * @param nextLink The nextLink from the previous successful call to the ListByVpnGateway method.
     * @param options The options parameters.
     */
    _listByVpnGatewayNext(resourceGroupName, gatewayName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, gatewayName, nextLink, options }, listByVpnGatewayNextOperationSpec$1);
    }
}
// Operation Specifications
const serializer$1A = coreClient.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$1e = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/vpnGateways/{gatewayName}/natRules/{natRuleName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VpnGatewayNatRule
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        natRuleName,
        gatewayName
    ],
    headerParameters: [accept],
    serializer: serializer$1A
};
const createOrUpdateOperationSpec$$ = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/vpnGateways/{gatewayName}/natRules/{natRuleName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: VpnGatewayNatRule
        },
        201: {
            bodyMapper: VpnGatewayNatRule
        },
        202: {
            bodyMapper: VpnGatewayNatRule
        },
        204: {
            bodyMapper: VpnGatewayNatRule
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: natRuleParameters1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        natRuleName,
        gatewayName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1A
};
const deleteOperationSpec$$ = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/vpnGateways/{gatewayName}/natRules/{natRuleName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        natRuleName,
        gatewayName
    ],
    headerParameters: [accept],
    serializer: serializer$1A
};
const listByVpnGatewayOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/vpnGateways/{gatewayName}/natRules",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListVpnGatewayNatRulesResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        gatewayName
    ],
    headerParameters: [accept],
    serializer: serializer$1A
};
const listByVpnGatewayNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListVpnGatewayNatRulesResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        gatewayName
    ],
    headerParameters: [accept],
    serializer: serializer$1A
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing P2SVpnGateways operations. */
class P2SVpnGatewaysImpl {
    /**
     * Initialize a new instance of the class P2SVpnGateways class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all the P2SVpnGateways in a resource group.
     * @param resourceGroupName The resource group name of the P2SVpnGateway.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByResourceGroupPagingPage(resourceGroupName, options);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all the P2SVpnGateways in a subscription.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(options);
            }
        };
    }
    listPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Retrieves the details of a virtual wan p2s vpn gateway.
     * @param resourceGroupName The resource group name of the P2SVpnGateway.
     * @param gatewayName The name of the gateway.
     * @param options The options parameters.
     */
    get(resourceGroupName, gatewayName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, gatewayName, options }, getOperationSpec$1f);
    }
    /**
     * Creates a virtual wan p2s vpn gateway if it doesn't exist else updates the existing gateway.
     * @param resourceGroupName The resource group name of the P2SVpnGateway.
     * @param gatewayName The name of the gateway.
     * @param p2SVpnGatewayParameters Parameters supplied to create or Update a virtual wan p2s vpn
     *                                gateway.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, gatewayName, p2SVpnGatewayParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, gatewayName, p2SVpnGatewayParameters, options }, createOrUpdateOperationSpec$10);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
        });
    }
    /**
     * Creates a virtual wan p2s vpn gateway if it doesn't exist else updates the existing gateway.
     * @param resourceGroupName The resource group name of the P2SVpnGateway.
     * @param gatewayName The name of the gateway.
     * @param p2SVpnGatewayParameters Parameters supplied to create or Update a virtual wan p2s vpn
     *                                gateway.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, gatewayName, p2SVpnGatewayParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, gatewayName, p2SVpnGatewayParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates virtual wan p2s vpn gateway tags.
     * @param resourceGroupName The resource group name of the P2SVpnGateway.
     * @param gatewayName The name of the gateway.
     * @param p2SVpnGatewayParameters Parameters supplied to update a virtual wan p2s vpn gateway tags.
     * @param options The options parameters.
     */
    beginUpdateTags(resourceGroupName, gatewayName, p2SVpnGatewayParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, gatewayName, p2SVpnGatewayParameters, options }, updateTagsOperationSpec$A);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
        });
    }
    /**
     * Updates virtual wan p2s vpn gateway tags.
     * @param resourceGroupName The resource group name of the P2SVpnGateway.
     * @param gatewayName The name of the gateway.
     * @param p2SVpnGatewayParameters Parameters supplied to update a virtual wan p2s vpn gateway tags.
     * @param options The options parameters.
     */
    beginUpdateTagsAndWait(resourceGroupName, gatewayName, p2SVpnGatewayParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdateTags(resourceGroupName, gatewayName, p2SVpnGatewayParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes a virtual wan p2s vpn gateway.
     * @param resourceGroupName The resource group name of the P2SVpnGateway.
     * @param gatewayName The name of the gateway.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, gatewayName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, gatewayName, options }, deleteOperationSpec$10);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Deletes a virtual wan p2s vpn gateway.
     * @param resourceGroupName The resource group name of the P2SVpnGateway.
     * @param gatewayName The name of the gateway.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, gatewayName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, gatewayName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Lists all the P2SVpnGateways in a resource group.
     * @param resourceGroupName The resource group name of the P2SVpnGateway.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec$k);
    }
    /**
     * Lists all the P2SVpnGateways in a subscription.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$1n);
    }
    /**
     * Resets the primary of the p2s vpn gateway in the specified resource group.
     * @param resourceGroupName The resource group name of the P2SVpnGateway.
     * @param gatewayName The name of the gateway.
     * @param options The options parameters.
     */
    beginReset(resourceGroupName, gatewayName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, gatewayName, options }, resetOperationSpec$2);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Resets the primary of the p2s vpn gateway in the specified resource group.
     * @param resourceGroupName The resource group name of the P2SVpnGateway.
     * @param gatewayName The name of the gateway.
     * @param options The options parameters.
     */
    beginResetAndWait(resourceGroupName, gatewayName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginReset(resourceGroupName, gatewayName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Generates VPN profile for P2S client of the P2SVpnGateway in the specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param gatewayName The name of the P2SVpnGateway.
     * @param parameters Parameters supplied to the generate P2SVpnGateway VPN client package operation.
     * @param options The options parameters.
     */
    beginGenerateVpnProfile(resourceGroupName, gatewayName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, gatewayName, parameters, options }, generateVpnProfileOperationSpec$1);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Generates VPN profile for P2S client of the P2SVpnGateway in the specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param gatewayName The name of the P2SVpnGateway.
     * @param parameters Parameters supplied to the generate P2SVpnGateway VPN client package operation.
     * @param options The options parameters.
     */
    beginGenerateVpnProfileAndWait(resourceGroupName, gatewayName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginGenerateVpnProfile(resourceGroupName, gatewayName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the connection health of P2S clients of the virtual wan P2SVpnGateway in the specified resource
     * group.
     * @param resourceGroupName The name of the resource group.
     * @param gatewayName The name of the P2SVpnGateway.
     * @param options The options parameters.
     */
    beginGetP2SVpnConnectionHealth(resourceGroupName, gatewayName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, gatewayName, options }, getP2SVpnConnectionHealthOperationSpec);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Gets the connection health of P2S clients of the virtual wan P2SVpnGateway in the specified resource
     * group.
     * @param resourceGroupName The name of the resource group.
     * @param gatewayName The name of the P2SVpnGateway.
     * @param options The options parameters.
     */
    beginGetP2SVpnConnectionHealthAndWait(resourceGroupName, gatewayName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginGetP2SVpnConnectionHealth(resourceGroupName, gatewayName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the sas url to get the connection health detail of P2S clients of the virtual wan P2SVpnGateway
     * in the specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param gatewayName The name of the P2SVpnGateway.
     * @param request Request parameters supplied to get p2s vpn connections detailed health.
     * @param options The options parameters.
     */
    beginGetP2SVpnConnectionHealthDetailed(resourceGroupName, gatewayName, request, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, gatewayName, request, options }, getP2SVpnConnectionHealthDetailedOperationSpec);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Gets the sas url to get the connection health detail of P2S clients of the virtual wan P2SVpnGateway
     * in the specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param gatewayName The name of the P2SVpnGateway.
     * @param request Request parameters supplied to get p2s vpn connections detailed health.
     * @param options The options parameters.
     */
    beginGetP2SVpnConnectionHealthDetailedAndWait(resourceGroupName, gatewayName, request, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginGetP2SVpnConnectionHealthDetailed(resourceGroupName, gatewayName, request, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Disconnect P2S vpn connections of the virtual wan P2SVpnGateway in the specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param p2SVpnGatewayName The name of the P2S Vpn Gateway.
     * @param request The parameters are supplied to disconnect p2s vpn connections.
     * @param options The options parameters.
     */
    beginDisconnectP2SVpnConnections(resourceGroupName, p2SVpnGatewayName, request, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, p2SVpnGatewayName, request, options }, disconnectP2SVpnConnectionsOperationSpec);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Disconnect P2S vpn connections of the virtual wan P2SVpnGateway in the specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param p2SVpnGatewayName The name of the P2S Vpn Gateway.
     * @param request The parameters are supplied to disconnect p2s vpn connections.
     * @param options The options parameters.
     */
    beginDisconnectP2SVpnConnectionsAndWait(resourceGroupName, p2SVpnGatewayName, request, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDisconnectP2SVpnConnections(resourceGroupName, p2SVpnGatewayName, request, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The resource group name of the P2SVpnGateway.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec$k);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$1e);
    }
}
// Operation Specifications
const serializer$1B = coreClient.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$1f = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/p2svpnGateways/{gatewayName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: P2SVpnGateway
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        gatewayName
    ],
    headerParameters: [accept],
    serializer: serializer$1B
};
const createOrUpdateOperationSpec$10 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/p2svpnGateways/{gatewayName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: P2SVpnGateway
        },
        201: {
            bodyMapper: P2SVpnGateway
        },
        202: {
            bodyMapper: P2SVpnGateway
        },
        204: {
            bodyMapper: P2SVpnGateway
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: p2SVpnGatewayParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        gatewayName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1B
};
const updateTagsOperationSpec$A = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/p2svpnGateways/{gatewayName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: P2SVpnGateway
        },
        201: {
            bodyMapper: P2SVpnGateway
        },
        202: {
            bodyMapper: P2SVpnGateway
        },
        204: {
            bodyMapper: P2SVpnGateway
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: p2SVpnGatewayParameters1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        gatewayName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1B
};
const deleteOperationSpec$10 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/p2svpnGateways/{gatewayName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        gatewayName
    ],
    headerParameters: [accept],
    serializer: serializer$1B
};
const listByResourceGroupOperationSpec$k = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/p2svpnGateways",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListP2SVpnGatewaysResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$1B
};
const listOperationSpec$1n = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/p2svpnGateways",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListP2SVpnGatewaysResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$1B
};
const resetOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/p2svpnGateways/{gatewayName}/reset",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: P2SVpnGateway
        },
        201: {
            bodyMapper: P2SVpnGateway
        },
        202: {
            bodyMapper: P2SVpnGateway
        },
        204: {
            bodyMapper: P2SVpnGateway
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        gatewayName
    ],
    headerParameters: [accept],
    serializer: serializer$1B
};
const generateVpnProfileOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/p2svpnGateways/{gatewayName}/generatevpnprofile",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: VpnProfileResponse
        },
        201: {
            bodyMapper: VpnProfileResponse
        },
        202: {
            bodyMapper: VpnProfileResponse
        },
        204: {
            bodyMapper: VpnProfileResponse
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters74,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        gatewayName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1B
};
const getP2SVpnConnectionHealthOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/p2svpnGateways/{gatewayName}/getP2sVpnConnectionHealth",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: P2SVpnGateway
        },
        201: {
            bodyMapper: P2SVpnGateway
        },
        202: {
            bodyMapper: P2SVpnGateway
        },
        204: {
            bodyMapper: P2SVpnGateway
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        gatewayName
    ],
    headerParameters: [accept],
    serializer: serializer$1B
};
const getP2SVpnConnectionHealthDetailedOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/p2svpnGateways/{gatewayName}/getP2sVpnConnectionHealthDetailed",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: P2SVpnConnectionHealth
        },
        201: {
            bodyMapper: P2SVpnConnectionHealth
        },
        202: {
            bodyMapper: P2SVpnConnectionHealth
        },
        204: {
            bodyMapper: P2SVpnConnectionHealth
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: request3,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        gatewayName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1B
};
const disconnectP2SVpnConnectionsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/p2svpnGateways/{p2sVpnGatewayName}/disconnectP2sVpnConnections",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: request1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        p2SVpnGatewayName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1B
};
const listByResourceGroupNextOperationSpec$k = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListP2SVpnGatewaysResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$1B
};
const listNextOperationSpec$1e = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListP2SVpnGatewaysResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$1B
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing VpnServerConfigurationsAssociatedWithVirtualWan operations. */
class VpnServerConfigurationsAssociatedWithVirtualWanImpl {
    /**
     * Initialize a new instance of the class VpnServerConfigurationsAssociatedWithVirtualWan class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gives the list of VpnServerConfigurations associated with Virtual Wan in a resource group.
     * @param resourceGroupName The resource group name.
     * @param virtualWANName The name of the VirtualWAN whose associated VpnServerConfigurations is needed.
     * @param options The options parameters.
     */
    beginList(resourceGroupName, virtualWANName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, virtualWANName, options }, listOperationSpec$1o);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Gives the list of VpnServerConfigurations associated with Virtual Wan in a resource group.
     * @param resourceGroupName The resource group name.
     * @param virtualWANName The name of the VirtualWAN whose associated VpnServerConfigurations is needed.
     * @param options The options parameters.
     */
    beginListAndWait(resourceGroupName, virtualWANName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginList(resourceGroupName, virtualWANName, options);
            return poller.pollUntilDone();
        });
    }
}
// Operation Specifications
const serializer$1C = coreClient.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$1o = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualWans/{virtualWANName}/vpnServerConfigurations",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: VpnServerConfigurationsResponse
        },
        201: {
            bodyMapper: VpnServerConfigurationsResponse
        },
        202: {
            bodyMapper: VpnServerConfigurationsResponse
        },
        204: {
            bodyMapper: VpnServerConfigurationsResponse
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualWANName
    ],
    headerParameters: [accept],
    serializer: serializer$1C
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing VirtualHubRouteTableV2S operations. */
class VirtualHubRouteTableV2SImpl {
    /**
     * Initialize a new instance of the class VirtualHubRouteTableV2S class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Retrieves the details of all VirtualHubRouteTableV2s.
     * @param resourceGroupName The resource group name of the VirtualHub.
     * @param virtualHubName The name of the VirtualHub.
     * @param options The options parameters.
     */
    list(resourceGroupName, virtualHubName, options) {
        const iter = this.listPagingAll(resourceGroupName, virtualHubName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, virtualHubName, options);
            }
        };
    }
    listPagingPage(resourceGroupName, virtualHubName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, virtualHubName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, virtualHubName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceGroupName, virtualHubName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, virtualHubName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Retrieves the details of a VirtualHubRouteTableV2.
     * @param resourceGroupName The resource group name of the VirtualHubRouteTableV2.
     * @param virtualHubName The name of the VirtualHub.
     * @param routeTableName The name of the VirtualHubRouteTableV2.
     * @param options The options parameters.
     */
    get(resourceGroupName, virtualHubName, routeTableName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, virtualHubName, routeTableName, options }, getOperationSpec$1g);
    }
    /**
     * Creates a VirtualHubRouteTableV2 resource if it doesn't exist else updates the existing
     * VirtualHubRouteTableV2.
     * @param resourceGroupName The resource group name of the VirtualHub.
     * @param virtualHubName The name of the VirtualHub.
     * @param routeTableName The name of the VirtualHubRouteTableV2.
     * @param virtualHubRouteTableV2Parameters Parameters supplied to create or update
     *                                         VirtualHubRouteTableV2.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, virtualHubName, routeTableName, virtualHubRouteTableV2Parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                virtualHubName,
                routeTableName,
                virtualHubRouteTableV2Parameters,
                options
            }, createOrUpdateOperationSpec$11);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
        });
    }
    /**
     * Creates a VirtualHubRouteTableV2 resource if it doesn't exist else updates the existing
     * VirtualHubRouteTableV2.
     * @param resourceGroupName The resource group name of the VirtualHub.
     * @param virtualHubName The name of the VirtualHub.
     * @param routeTableName The name of the VirtualHubRouteTableV2.
     * @param virtualHubRouteTableV2Parameters Parameters supplied to create or update
     *                                         VirtualHubRouteTableV2.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, virtualHubName, routeTableName, virtualHubRouteTableV2Parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, virtualHubName, routeTableName, virtualHubRouteTableV2Parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes a VirtualHubRouteTableV2.
     * @param resourceGroupName The resource group name of the VirtualHubRouteTableV2.
     * @param virtualHubName The name of the VirtualHub.
     * @param routeTableName The name of the VirtualHubRouteTableV2.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, virtualHubName, routeTableName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, virtualHubName, routeTableName, options }, deleteOperationSpec$11);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Deletes a VirtualHubRouteTableV2.
     * @param resourceGroupName The resource group name of the VirtualHubRouteTableV2.
     * @param virtualHubName The name of the VirtualHub.
     * @param routeTableName The name of the VirtualHubRouteTableV2.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, virtualHubName, routeTableName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, virtualHubName, routeTableName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Retrieves the details of all VirtualHubRouteTableV2s.
     * @param resourceGroupName The resource group name of the VirtualHub.
     * @param virtualHubName The name of the VirtualHub.
     * @param options The options parameters.
     */
    _list(resourceGroupName, virtualHubName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, virtualHubName, options }, listOperationSpec$1p);
    }
    /**
     * ListNext
     * @param resourceGroupName The resource group name of the VirtualHub.
     * @param virtualHubName The name of the VirtualHub.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, virtualHubName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, virtualHubName, nextLink, options }, listNextOperationSpec$1f);
    }
}
// Operation Specifications
const serializer$1D = coreClient.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$1g = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualHubs/{virtualHubName}/routeTables/{routeTableName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualHubRouteTableV2
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        routeTableName,
        virtualHubName
    ],
    headerParameters: [accept],
    serializer: serializer$1D
};
const createOrUpdateOperationSpec$11 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualHubs/{virtualHubName}/routeTables/{routeTableName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: VirtualHubRouteTableV2
        },
        201: {
            bodyMapper: VirtualHubRouteTableV2
        },
        202: {
            bodyMapper: VirtualHubRouteTableV2
        },
        204: {
            bodyMapper: VirtualHubRouteTableV2
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    requestBody: virtualHubRouteTableV2Parameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        routeTableName,
        virtualHubName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1D
};
const deleteOperationSpec$11 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualHubs/{virtualHubName}/routeTables/{routeTableName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        routeTableName,
        virtualHubName
    ],
    headerParameters: [accept],
    serializer: serializer$1D
};
const listOperationSpec$1p = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualHubs/{virtualHubName}/routeTables",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListVirtualHubRouteTableV2SResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualHubName
    ],
    headerParameters: [accept],
    serializer: serializer$1D
};
const listNextOperationSpec$1f = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListVirtualHubRouteTableV2SResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        virtualHubName
    ],
    headerParameters: [accept],
    serializer: serializer$1D
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing ExpressRouteGateways operations. */
class ExpressRouteGatewaysImpl {
    /**
     * Initialize a new instance of the class ExpressRouteGateways class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists ExpressRoute gateways under a given subscription.
     * @param options The options parameters.
     */
    listBySubscription(options) {
        return this.client.sendOperationRequest({ options }, listBySubscriptionOperationSpec$3);
    }
    /**
     * Lists ExpressRoute gateways in a given resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec$l);
    }
    /**
     * Creates or updates a ExpressRoute gateway in a specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param expressRouteGatewayName The name of the ExpressRoute gateway.
     * @param putExpressRouteGatewayParameters Parameters required in an ExpressRoute gateway PUT
     *                                         operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, expressRouteGatewayName, putExpressRouteGatewayParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                expressRouteGatewayName,
                putExpressRouteGatewayParameters,
                options
            }, createOrUpdateOperationSpec$12);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
        });
    }
    /**
     * Creates or updates a ExpressRoute gateway in a specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param expressRouteGatewayName The name of the ExpressRoute gateway.
     * @param putExpressRouteGatewayParameters Parameters required in an ExpressRoute gateway PUT
     *                                         operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, expressRouteGatewayName, putExpressRouteGatewayParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, expressRouteGatewayName, putExpressRouteGatewayParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates express route gateway tags.
     * @param resourceGroupName The resource group name of the ExpressRouteGateway.
     * @param expressRouteGatewayName The name of the gateway.
     * @param expressRouteGatewayParameters Parameters supplied to update a virtual wan express route
     *                                      gateway tags.
     * @param options The options parameters.
     */
    beginUpdateTags(resourceGroupName, expressRouteGatewayName, expressRouteGatewayParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                expressRouteGatewayName,
                expressRouteGatewayParameters,
                options
            }, updateTagsOperationSpec$B);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
        });
    }
    /**
     * Updates express route gateway tags.
     * @param resourceGroupName The resource group name of the ExpressRouteGateway.
     * @param expressRouteGatewayName The name of the gateway.
     * @param expressRouteGatewayParameters Parameters supplied to update a virtual wan express route
     *                                      gateway tags.
     * @param options The options parameters.
     */
    beginUpdateTagsAndWait(resourceGroupName, expressRouteGatewayName, expressRouteGatewayParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdateTags(resourceGroupName, expressRouteGatewayName, expressRouteGatewayParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Fetches the details of a ExpressRoute gateway in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param expressRouteGatewayName The name of the ExpressRoute gateway.
     * @param options The options parameters.
     */
    get(resourceGroupName, expressRouteGatewayName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, expressRouteGatewayName, options }, getOperationSpec$1h);
    }
    /**
     * Deletes the specified ExpressRoute gateway in a resource group. An ExpressRoute gateway resource can
     * only be deleted when there are no connection subresources.
     * @param resourceGroupName The name of the resource group.
     * @param expressRouteGatewayName The name of the ExpressRoute gateway.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, expressRouteGatewayName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, expressRouteGatewayName, options }, deleteOperationSpec$12);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Deletes the specified ExpressRoute gateway in a resource group. An ExpressRoute gateway resource can
     * only be deleted when there are no connection subresources.
     * @param resourceGroupName The name of the resource group.
     * @param expressRouteGatewayName The name of the ExpressRoute gateway.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, expressRouteGatewayName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, expressRouteGatewayName, options);
            return poller.pollUntilDone();
        });
    }
}
// Operation Specifications
const serializer$1E = coreClient.createSerializer(Mappers, /* isXml */ false);
const listBySubscriptionOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/expressRouteGateways",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ExpressRouteGatewayList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$1E
};
const listByResourceGroupOperationSpec$l = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/expressRouteGateways",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ExpressRouteGatewayList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$1E
};
const createOrUpdateOperationSpec$12 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/expressRouteGateways/{expressRouteGatewayName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ExpressRouteGateway
        },
        201: {
            bodyMapper: ExpressRouteGateway
        },
        202: {
            bodyMapper: ExpressRouteGateway
        },
        204: {
            bodyMapper: ExpressRouteGateway
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: putExpressRouteGatewayParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        expressRouteGatewayName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1E
};
const updateTagsOperationSpec$B = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/expressRouteGateways/{expressRouteGatewayName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: ExpressRouteGateway
        },
        201: {
            bodyMapper: ExpressRouteGateway
        },
        202: {
            bodyMapper: ExpressRouteGateway
        },
        204: {
            bodyMapper: ExpressRouteGateway
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: expressRouteGatewayParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        expressRouteGatewayName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1E
};
const getOperationSpec$1h = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/expressRouteGateways/{expressRouteGatewayName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ExpressRouteGateway
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        expressRouteGatewayName
    ],
    headerParameters: [accept],
    serializer: serializer$1E
};
const deleteOperationSpec$12 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/expressRouteGateways/{expressRouteGatewayName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        expressRouteGatewayName
    ],
    headerParameters: [accept],
    serializer: serializer$1E
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing ExpressRouteConnections operations. */
class ExpressRouteConnectionsImpl {
    /**
     * Initialize a new instance of the class ExpressRouteConnections class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Creates a connection between an ExpressRoute gateway and an ExpressRoute circuit.
     * @param resourceGroupName The name of the resource group.
     * @param expressRouteGatewayName The name of the ExpressRoute gateway.
     * @param connectionName The name of the connection subresource.
     * @param putExpressRouteConnectionParameters Parameters required in an ExpressRouteConnection PUT
     *                                            operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, expressRouteGatewayName, connectionName, putExpressRouteConnectionParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                expressRouteGatewayName,
                connectionName,
                putExpressRouteConnectionParameters,
                options
            }, createOrUpdateOperationSpec$13);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
        });
    }
    /**
     * Creates a connection between an ExpressRoute gateway and an ExpressRoute circuit.
     * @param resourceGroupName The name of the resource group.
     * @param expressRouteGatewayName The name of the ExpressRoute gateway.
     * @param connectionName The name of the connection subresource.
     * @param putExpressRouteConnectionParameters Parameters required in an ExpressRouteConnection PUT
     *                                            operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, expressRouteGatewayName, connectionName, putExpressRouteConnectionParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, expressRouteGatewayName, connectionName, putExpressRouteConnectionParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the specified ExpressRouteConnection.
     * @param resourceGroupName The name of the resource group.
     * @param expressRouteGatewayName The name of the ExpressRoute gateway.
     * @param connectionName The name of the ExpressRoute connection.
     * @param options The options parameters.
     */
    get(resourceGroupName, expressRouteGatewayName, connectionName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, expressRouteGatewayName, connectionName, options }, getOperationSpec$1i);
    }
    /**
     * Deletes a connection to a ExpressRoute circuit.
     * @param resourceGroupName The name of the resource group.
     * @param expressRouteGatewayName The name of the ExpressRoute gateway.
     * @param connectionName The name of the connection subresource.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, expressRouteGatewayName, connectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, expressRouteGatewayName, connectionName, options }, deleteOperationSpec$13);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Deletes a connection to a ExpressRoute circuit.
     * @param resourceGroupName The name of the resource group.
     * @param expressRouteGatewayName The name of the ExpressRoute gateway.
     * @param connectionName The name of the connection subresource.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, expressRouteGatewayName, connectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, expressRouteGatewayName, connectionName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Lists ExpressRouteConnections.
     * @param resourceGroupName The name of the resource group.
     * @param expressRouteGatewayName The name of the ExpressRoute gateway.
     * @param options The options parameters.
     */
    list(resourceGroupName, expressRouteGatewayName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, expressRouteGatewayName, options }, listOperationSpec$1q);
    }
}
// Operation Specifications
const serializer$1F = coreClient.createSerializer(Mappers, /* isXml */ false);
const createOrUpdateOperationSpec$13 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/expressRouteGateways/{expressRouteGatewayName}/expressRouteConnections/{connectionName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ExpressRouteConnection
        },
        201: {
            bodyMapper: ExpressRouteConnection
        },
        202: {
            bodyMapper: ExpressRouteConnection
        },
        204: {
            bodyMapper: ExpressRouteConnection
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: putExpressRouteConnectionParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        connectionName,
        expressRouteGatewayName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1F
};
const getOperationSpec$1i = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/expressRouteGateways/{expressRouteGatewayName}/expressRouteConnections/{connectionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ExpressRouteConnection
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        connectionName,
        expressRouteGatewayName
    ],
    headerParameters: [accept],
    serializer: serializer$1F
};
const deleteOperationSpec$13 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/expressRouteGateways/{expressRouteGatewayName}/expressRouteConnections/{connectionName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        connectionName,
        expressRouteGatewayName
    ],
    headerParameters: [accept],
    serializer: serializer$1F
};
const listOperationSpec$1q = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/expressRouteGateways/{expressRouteGatewayName}/expressRouteConnections",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ExpressRouteConnectionList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        expressRouteGatewayName
    ],
    headerParameters: [accept],
    serializer: serializer$1F
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing VirtualHubBgpConnection operations. */
class VirtualHubBgpConnectionImpl {
    /**
     * Initialize a new instance of the class VirtualHubBgpConnection class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Retrieves the details of a Virtual Hub Bgp Connection.
     * @param resourceGroupName The resource group name of the VirtualHub.
     * @param virtualHubName The name of the VirtualHub.
     * @param connectionName The name of the connection.
     * @param options The options parameters.
     */
    get(resourceGroupName, virtualHubName, connectionName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, virtualHubName, connectionName, options }, getOperationSpec$1j);
    }
    /**
     * Creates a VirtualHubBgpConnection resource if it doesn't exist else updates the existing
     * VirtualHubBgpConnection.
     * @param resourceGroupName The resource group name of the VirtualHub.
     * @param virtualHubName The name of the VirtualHub.
     * @param connectionName The name of the connection.
     * @param parameters Parameters of Bgp connection.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, virtualHubName, connectionName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                virtualHubName,
                connectionName,
                parameters,
                options
            }, createOrUpdateOperationSpec$14);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
        });
    }
    /**
     * Creates a VirtualHubBgpConnection resource if it doesn't exist else updates the existing
     * VirtualHubBgpConnection.
     * @param resourceGroupName The resource group name of the VirtualHub.
     * @param virtualHubName The name of the VirtualHub.
     * @param connectionName The name of the connection.
     * @param parameters Parameters of Bgp connection.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, virtualHubName, connectionName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, virtualHubName, connectionName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes a VirtualHubBgpConnection.
     * @param resourceGroupName The resource group name of the VirtualHubBgpConnection.
     * @param virtualHubName The name of the VirtualHub.
     * @param connectionName The name of the connection.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, virtualHubName, connectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, virtualHubName, connectionName, options }, deleteOperationSpec$14);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Deletes a VirtualHubBgpConnection.
     * @param resourceGroupName The resource group name of the VirtualHubBgpConnection.
     * @param virtualHubName The name of the VirtualHub.
     * @param connectionName The name of the connection.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, virtualHubName, connectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, virtualHubName, connectionName, options);
            return poller.pollUntilDone();
        });
    }
}
// Operation Specifications
const serializer$1G = coreClient.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$1j = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualHubs/{virtualHubName}/bgpConnections/{connectionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: BgpConnection
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        connectionName,
        virtualHubName
    ],
    headerParameters: [accept],
    serializer: serializer$1G
};
const createOrUpdateOperationSpec$14 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualHubs/{virtualHubName}/bgpConnections/{connectionName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: BgpConnection
        },
        201: {
            bodyMapper: BgpConnection
        },
        202: {
            bodyMapper: BgpConnection
        },
        204: {
            bodyMapper: BgpConnection
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters75,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        connectionName,
        virtualHubName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1G
};
const deleteOperationSpec$14 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualHubs/{virtualHubName}/bgpConnections/{connectionName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        connectionName,
        virtualHubName
    ],
    headerParameters: [accept],
    serializer: serializer$1G
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing VirtualHubBgpConnections operations. */
class VirtualHubBgpConnectionsImpl {
    /**
     * Initialize a new instance of the class VirtualHubBgpConnections class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Retrieves the details of all VirtualHubBgpConnections.
     * @param resourceGroupName The resource group name of the VirtualHub.
     * @param virtualHubName The name of the VirtualHub.
     * @param options The options parameters.
     */
    list(resourceGroupName, virtualHubName, options) {
        const iter = this.listPagingAll(resourceGroupName, virtualHubName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, virtualHubName, options);
            }
        };
    }
    listPagingPage(resourceGroupName, virtualHubName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, virtualHubName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, virtualHubName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceGroupName, virtualHubName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, virtualHubName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Retrieves the details of all VirtualHubBgpConnections.
     * @param resourceGroupName The resource group name of the VirtualHub.
     * @param virtualHubName The name of the VirtualHub.
     * @param options The options parameters.
     */
    _list(resourceGroupName, virtualHubName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, virtualHubName, options }, listOperationSpec$1r);
    }
    /**
     * Retrieves a list of routes the virtual hub bgp connection has learned.
     * @param resourceGroupName The name of the resource group.
     * @param hubName The name of the virtual hub.
     * @param connectionName The name of the virtual hub bgp connection.
     * @param options The options parameters.
     */
    beginListLearnedRoutes(resourceGroupName, hubName, connectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, hubName, connectionName, options }, listLearnedRoutesOperationSpec);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Retrieves a list of routes the virtual hub bgp connection has learned.
     * @param resourceGroupName The name of the resource group.
     * @param hubName The name of the virtual hub.
     * @param connectionName The name of the virtual hub bgp connection.
     * @param options The options parameters.
     */
    beginListLearnedRoutesAndWait(resourceGroupName, hubName, connectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginListLearnedRoutes(resourceGroupName, hubName, connectionName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Retrieves a list of routes the virtual hub bgp connection is advertising to the specified peer.
     * @param resourceGroupName The name of the resource group.
     * @param hubName The name of the virtual hub.
     * @param connectionName The name of the virtual hub bgp connection.
     * @param options The options parameters.
     */
    beginListAdvertisedRoutes(resourceGroupName, hubName, connectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, hubName, connectionName, options }, listAdvertisedRoutesOperationSpec);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Retrieves a list of routes the virtual hub bgp connection is advertising to the specified peer.
     * @param resourceGroupName The name of the resource group.
     * @param hubName The name of the virtual hub.
     * @param connectionName The name of the virtual hub bgp connection.
     * @param options The options parameters.
     */
    beginListAdvertisedRoutesAndWait(resourceGroupName, hubName, connectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginListAdvertisedRoutes(resourceGroupName, hubName, connectionName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListNext
     * @param resourceGroupName The resource group name of the VirtualHub.
     * @param virtualHubName The name of the VirtualHub.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, virtualHubName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, virtualHubName, nextLink, options }, listNextOperationSpec$1g);
    }
}
// Operation Specifications
const serializer$1H = coreClient.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$1r = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualHubs/{virtualHubName}/bgpConnections",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListVirtualHubBgpConnectionResults
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualHubName
    ],
    headerParameters: [accept],
    serializer: serializer$1H
};
const listLearnedRoutesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualHubs/{hubName}/bgpConnections/{connectionName}/learnedRoutes",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: PeerRouteList
        },
        201: {
            bodyMapper: PeerRouteList
        },
        202: {
            bodyMapper: PeerRouteList
        },
        204: {
            bodyMapper: PeerRouteList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        connectionName,
        hubName
    ],
    headerParameters: [accept],
    serializer: serializer$1H
};
const listAdvertisedRoutesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualHubs/{hubName}/bgpConnections/{connectionName}/advertisedRoutes",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: PeerRouteList
        },
        201: {
            bodyMapper: PeerRouteList
        },
        202: {
            bodyMapper: PeerRouteList
        },
        204: {
            bodyMapper: PeerRouteList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        connectionName,
        hubName
    ],
    headerParameters: [accept],
    serializer: serializer$1H
};
const listNextOperationSpec$1g = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListVirtualHubBgpConnectionResults
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        virtualHubName
    ],
    headerParameters: [accept],
    serializer: serializer$1H
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing VirtualHubIpConfiguration operations. */
class VirtualHubIpConfigurationImpl {
    /**
     * Initialize a new instance of the class VirtualHubIpConfiguration class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Retrieves the details of all VirtualHubIpConfigurations.
     * @param resourceGroupName The resource group name of the VirtualHub.
     * @param virtualHubName The name of the VirtualHub.
     * @param options The options parameters.
     */
    list(resourceGroupName, virtualHubName, options) {
        const iter = this.listPagingAll(resourceGroupName, virtualHubName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, virtualHubName, options);
            }
        };
    }
    listPagingPage(resourceGroupName, virtualHubName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, virtualHubName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, virtualHubName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceGroupName, virtualHubName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, virtualHubName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Retrieves the details of a Virtual Hub Ip configuration.
     * @param resourceGroupName The resource group name of the VirtualHub.
     * @param virtualHubName The name of the VirtualHub.
     * @param ipConfigName The name of the ipconfig.
     * @param options The options parameters.
     */
    get(resourceGroupName, virtualHubName, ipConfigName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, virtualHubName, ipConfigName, options }, getOperationSpec$1k);
    }
    /**
     * Creates a VirtualHubIpConfiguration resource if it doesn't exist else updates the existing
     * VirtualHubIpConfiguration.
     * @param resourceGroupName The resource group name of the VirtualHub.
     * @param virtualHubName The name of the VirtualHub.
     * @param ipConfigName The name of the ipconfig.
     * @param parameters Hub Ip Configuration parameters.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, virtualHubName, ipConfigName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, virtualHubName, ipConfigName, parameters, options }, createOrUpdateOperationSpec$15);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
        });
    }
    /**
     * Creates a VirtualHubIpConfiguration resource if it doesn't exist else updates the existing
     * VirtualHubIpConfiguration.
     * @param resourceGroupName The resource group name of the VirtualHub.
     * @param virtualHubName The name of the VirtualHub.
     * @param ipConfigName The name of the ipconfig.
     * @param parameters Hub Ip Configuration parameters.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, virtualHubName, ipConfigName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, virtualHubName, ipConfigName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes a VirtualHubIpConfiguration.
     * @param resourceGroupName The resource group name of the VirtualHubBgpConnection.
     * @param virtualHubName The name of the VirtualHub.
     * @param ipConfigName The name of the ipconfig.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, virtualHubName, ipConfigName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, virtualHubName, ipConfigName, options }, deleteOperationSpec$15);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Deletes a VirtualHubIpConfiguration.
     * @param resourceGroupName The resource group name of the VirtualHubBgpConnection.
     * @param virtualHubName The name of the VirtualHub.
     * @param ipConfigName The name of the ipconfig.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, virtualHubName, ipConfigName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, virtualHubName, ipConfigName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Retrieves the details of all VirtualHubIpConfigurations.
     * @param resourceGroupName The resource group name of the VirtualHub.
     * @param virtualHubName The name of the VirtualHub.
     * @param options The options parameters.
     */
    _list(resourceGroupName, virtualHubName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, virtualHubName, options }, listOperationSpec$1s);
    }
    /**
     * ListNext
     * @param resourceGroupName The resource group name of the VirtualHub.
     * @param virtualHubName The name of the VirtualHub.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, virtualHubName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, virtualHubName, nextLink, options }, listNextOperationSpec$1h);
    }
}
// Operation Specifications
const serializer$1I = coreClient.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$1k = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualHubs/{virtualHubName}/ipConfigurations/{ipConfigName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: HubIpConfiguration
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualHubName,
        ipConfigName
    ],
    headerParameters: [accept],
    serializer: serializer$1I
};
const createOrUpdateOperationSpec$15 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualHubs/{virtualHubName}/ipConfigurations/{ipConfigName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: HubIpConfiguration
        },
        201: {
            bodyMapper: HubIpConfiguration
        },
        202: {
            bodyMapper: HubIpConfiguration
        },
        204: {
            bodyMapper: HubIpConfiguration
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters76,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualHubName,
        ipConfigName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1I
};
const deleteOperationSpec$15 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualHubs/{virtualHubName}/ipConfigurations/{ipConfigName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualHubName,
        ipConfigName
    ],
    headerParameters: [accept],
    serializer: serializer$1I
};
const listOperationSpec$1s = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualHubs/{virtualHubName}/ipConfigurations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListVirtualHubIpConfigurationResults
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualHubName
    ],
    headerParameters: [accept],
    serializer: serializer$1I
};
const listNextOperationSpec$1h = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListVirtualHubIpConfigurationResults
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        virtualHubName
    ],
    headerParameters: [accept],
    serializer: serializer$1I
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing HubRouteTables operations. */
class HubRouteTablesImpl {
    /**
     * Initialize a new instance of the class HubRouteTables class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Retrieves the details of all RouteTables.
     * @param resourceGroupName The resource group name of the VirtualHub.
     * @param virtualHubName The name of the VirtualHub.
     * @param options The options parameters.
     */
    list(resourceGroupName, virtualHubName, options) {
        const iter = this.listPagingAll(resourceGroupName, virtualHubName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, virtualHubName, options);
            }
        };
    }
    listPagingPage(resourceGroupName, virtualHubName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, virtualHubName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, virtualHubName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceGroupName, virtualHubName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, virtualHubName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Creates a RouteTable resource if it doesn't exist else updates the existing RouteTable.
     * @param resourceGroupName The resource group name of the VirtualHub.
     * @param virtualHubName The name of the VirtualHub.
     * @param routeTableName The name of the RouteTable.
     * @param routeTableParameters Parameters supplied to create or update RouteTable.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, virtualHubName, routeTableName, routeTableParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                virtualHubName,
                routeTableName,
                routeTableParameters,
                options
            }, createOrUpdateOperationSpec$16);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
        });
    }
    /**
     * Creates a RouteTable resource if it doesn't exist else updates the existing RouteTable.
     * @param resourceGroupName The resource group name of the VirtualHub.
     * @param virtualHubName The name of the VirtualHub.
     * @param routeTableName The name of the RouteTable.
     * @param routeTableParameters Parameters supplied to create or update RouteTable.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, virtualHubName, routeTableName, routeTableParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, virtualHubName, routeTableName, routeTableParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Retrieves the details of a RouteTable.
     * @param resourceGroupName The resource group name of the VirtualHub.
     * @param virtualHubName The name of the VirtualHub.
     * @param routeTableName The name of the RouteTable.
     * @param options The options parameters.
     */
    get(resourceGroupName, virtualHubName, routeTableName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, virtualHubName, routeTableName, options }, getOperationSpec$1l);
    }
    /**
     * Deletes a RouteTable.
     * @param resourceGroupName The resource group name of the RouteTable.
     * @param virtualHubName The name of the VirtualHub.
     * @param routeTableName The name of the RouteTable.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, virtualHubName, routeTableName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, virtualHubName, routeTableName, options }, deleteOperationSpec$16);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Deletes a RouteTable.
     * @param resourceGroupName The resource group name of the RouteTable.
     * @param virtualHubName The name of the VirtualHub.
     * @param routeTableName The name of the RouteTable.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, virtualHubName, routeTableName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, virtualHubName, routeTableName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Retrieves the details of all RouteTables.
     * @param resourceGroupName The resource group name of the VirtualHub.
     * @param virtualHubName The name of the VirtualHub.
     * @param options The options parameters.
     */
    _list(resourceGroupName, virtualHubName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, virtualHubName, options }, listOperationSpec$1t);
    }
    /**
     * ListNext
     * @param resourceGroupName The resource group name of the VirtualHub.
     * @param virtualHubName The name of the VirtualHub.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, virtualHubName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, virtualHubName, nextLink, options }, listNextOperationSpec$1i);
    }
}
// Operation Specifications
const serializer$1J = coreClient.createSerializer(Mappers, /* isXml */ false);
const createOrUpdateOperationSpec$16 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualHubs/{virtualHubName}/hubRouteTables/{routeTableName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: HubRouteTable
        },
        201: {
            bodyMapper: HubRouteTable
        },
        202: {
            bodyMapper: HubRouteTable
        },
        204: {
            bodyMapper: HubRouteTable
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: routeTableParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        routeTableName,
        virtualHubName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1J
};
const getOperationSpec$1l = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualHubs/{virtualHubName}/hubRouteTables/{routeTableName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: HubRouteTable
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        routeTableName,
        virtualHubName
    ],
    headerParameters: [accept],
    serializer: serializer$1J
};
const deleteOperationSpec$16 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualHubs/{virtualHubName}/hubRouteTables/{routeTableName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        routeTableName,
        virtualHubName
    ],
    headerParameters: [accept],
    serializer: serializer$1J
};
const listOperationSpec$1t = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualHubs/{virtualHubName}/hubRouteTables",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListHubRouteTablesResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualHubName
    ],
    headerParameters: [accept],
    serializer: serializer$1J
};
const listNextOperationSpec$1i = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListHubRouteTablesResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        virtualHubName
    ],
    headerParameters: [accept],
    serializer: serializer$1J
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing RoutingIntentOperations operations. */
class RoutingIntentOperationsImpl {
    /**
     * Initialize a new instance of the class RoutingIntentOperations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Retrieves the details of all RoutingIntent child resources of the VirtualHub.
     * @param resourceGroupName The resource group name of the VirtualHub.
     * @param virtualHubName The name of the VirtualHub.
     * @param options The options parameters.
     */
    list(resourceGroupName, virtualHubName, options) {
        const iter = this.listPagingAll(resourceGroupName, virtualHubName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, virtualHubName, options);
            }
        };
    }
    listPagingPage(resourceGroupName, virtualHubName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, virtualHubName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, virtualHubName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceGroupName, virtualHubName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, virtualHubName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Creates a RoutingIntent resource if it doesn't exist else updates the existing RoutingIntent.
     * @param resourceGroupName The resource group name of the RoutingIntent.
     * @param virtualHubName The name of the VirtualHub.
     * @param routingIntentName The name of the per VirtualHub singleton Routing Intent resource.
     * @param routingIntentParameters Parameters supplied to create or update RoutingIntent.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, virtualHubName, routingIntentName, routingIntentParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                virtualHubName,
                routingIntentName,
                routingIntentParameters,
                options
            }, createOrUpdateOperationSpec$17);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
        });
    }
    /**
     * Creates a RoutingIntent resource if it doesn't exist else updates the existing RoutingIntent.
     * @param resourceGroupName The resource group name of the RoutingIntent.
     * @param virtualHubName The name of the VirtualHub.
     * @param routingIntentName The name of the per VirtualHub singleton Routing Intent resource.
     * @param routingIntentParameters Parameters supplied to create or update RoutingIntent.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, virtualHubName, routingIntentName, routingIntentParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, virtualHubName, routingIntentName, routingIntentParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Retrieves the details of a RoutingIntent.
     * @param resourceGroupName The resource group name of the RoutingIntent.
     * @param virtualHubName The name of the VirtualHub.
     * @param routingIntentName The name of the RoutingIntent.
     * @param options The options parameters.
     */
    get(resourceGroupName, virtualHubName, routingIntentName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, virtualHubName, routingIntentName, options }, getOperationSpec$1m);
    }
    /**
     * Deletes a RoutingIntent.
     * @param resourceGroupName The resource group name of the RoutingIntent.
     * @param virtualHubName The name of the VirtualHub.
     * @param routingIntentName The name of the RoutingIntent.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, virtualHubName, routingIntentName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, virtualHubName, routingIntentName, options }, deleteOperationSpec$17);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Deletes a RoutingIntent.
     * @param resourceGroupName The resource group name of the RoutingIntent.
     * @param virtualHubName The name of the VirtualHub.
     * @param routingIntentName The name of the RoutingIntent.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, virtualHubName, routingIntentName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, virtualHubName, routingIntentName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Retrieves the details of all RoutingIntent child resources of the VirtualHub.
     * @param resourceGroupName The resource group name of the VirtualHub.
     * @param virtualHubName The name of the VirtualHub.
     * @param options The options parameters.
     */
    _list(resourceGroupName, virtualHubName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, virtualHubName, options }, listOperationSpec$1u);
    }
    /**
     * ListNext
     * @param resourceGroupName The resource group name of the VirtualHub.
     * @param virtualHubName The name of the VirtualHub.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, virtualHubName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, virtualHubName, nextLink, options }, listNextOperationSpec$1j);
    }
}
// Operation Specifications
const serializer$1K = coreClient.createSerializer(Mappers, /* isXml */ false);
const createOrUpdateOperationSpec$17 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualHubs/{virtualHubName}/routingIntent/{routingIntentName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: RoutingIntent
        },
        201: {
            bodyMapper: RoutingIntent
        },
        202: {
            bodyMapper: RoutingIntent
        },
        204: {
            bodyMapper: RoutingIntent
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: routingIntentParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualHubName,
        routingIntentName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1K
};
const getOperationSpec$1m = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualHubs/{virtualHubName}/routingIntent/{routingIntentName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RoutingIntent
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualHubName,
        routingIntentName
    ],
    headerParameters: [accept],
    serializer: serializer$1K
};
const deleteOperationSpec$17 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualHubs/{virtualHubName}/routingIntent/{routingIntentName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualHubName,
        routingIntentName
    ],
    headerParameters: [accept],
    serializer: serializer$1K
};
const listOperationSpec$1u = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualHubs/{virtualHubName}/routingIntent",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListRoutingIntentResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualHubName
    ],
    headerParameters: [accept],
    serializer: serializer$1K
};
const listNextOperationSpec$1j = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListRoutingIntentResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        virtualHubName
    ],
    headerParameters: [accept],
    serializer: serializer$1K
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing WebApplicationFirewallPolicies operations. */
class WebApplicationFirewallPoliciesImpl {
    /**
     * Initialize a new instance of the class WebApplicationFirewallPolicies class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all of the protection policies within a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    list(resourceGroupName, options) {
        const iter = this.listPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, options);
            }
        };
    }
    listPagingPage(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets all the WAF policies in a subscription.
     * @param options The options parameters.
     */
    listAll(options) {
        const iter = this.listAllPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listAllPagingPage(options);
            }
        };
    }
    listAllPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listAllPagingPage_1() {
            let result = yield tslib.__await(this._listAll(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listAllNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listAllPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listAllPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listAllPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Lists all of the protection policies within a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    _list(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listOperationSpec$1v);
    }
    /**
     * Gets all the WAF policies in a subscription.
     * @param options The options parameters.
     */
    _listAll(options) {
        return this.client.sendOperationRequest({ options }, listAllOperationSpec$j);
    }
    /**
     * Retrieve protection policy with specified name within a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param policyName The name of the policy.
     * @param options The options parameters.
     */
    get(resourceGroupName, policyName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, policyName, options }, getOperationSpec$1n);
    }
    /**
     * Creates or update policy with specified rule set name within a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param policyName The name of the policy.
     * @param parameters Policy to be created.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, policyName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, policyName, parameters, options }, createOrUpdateOperationSpec$18);
    }
    /**
     * Deletes Policy.
     * @param resourceGroupName The name of the resource group.
     * @param policyName The name of the policy.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, policyName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, policyName, options }, deleteOperationSpec$18);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Deletes Policy.
     * @param resourceGroupName The name of the resource group.
     * @param policyName The name of the policy.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, policyName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, policyName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listNextOperationSpec$1k);
    }
    /**
     * ListAllNext
     * @param nextLink The nextLink from the previous successful call to the ListAll method.
     * @param options The options parameters.
     */
    _listAllNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listAllNextOperationSpec$i);
    }
}
// Operation Specifications
const serializer$1L = coreClient.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$1v = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/ApplicationGatewayWebApplicationFirewallPolicies",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WebApplicationFirewallPolicyListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$1L
};
const listAllOperationSpec$j = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/ApplicationGatewayWebApplicationFirewallPolicies",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WebApplicationFirewallPolicyListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$1L
};
const getOperationSpec$1n = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/ApplicationGatewayWebApplicationFirewallPolicies/{policyName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WebApplicationFirewallPolicy
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        policyName
    ],
    headerParameters: [accept],
    serializer: serializer$1L
};
const createOrUpdateOperationSpec$18 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/ApplicationGatewayWebApplicationFirewallPolicies/{policyName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: WebApplicationFirewallPolicy
        },
        201: {
            bodyMapper: WebApplicationFirewallPolicy
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters77,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        policyName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1L
};
const deleteOperationSpec$18 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/ApplicationGatewayWebApplicationFirewallPolicies/{policyName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        policyName
    ],
    headerParameters: [accept],
    serializer: serializer$1L
};
const listNextOperationSpec$1k = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WebApplicationFirewallPolicyListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$1L
};
const listAllNextOperationSpec$i = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WebApplicationFirewallPolicyListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$1L
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
class NetworkManagementClient extends coreClient.ServiceClient {
    /**
     * Initializes a new instance of the NetworkManagementClient class.
     * @param credentials Subscription credentials which uniquely identify client subscription.
     * @param subscriptionId The subscription credentials which uniquely identify the Microsoft Azure
     *                       subscription. The subscription ID forms part of the URI for every service call.
     * @param options The parameter options
     */
    constructor(credentials, subscriptionId, options) {
        if (credentials === undefined) {
            throw new Error("'credentials' cannot be null");
        }
        if (subscriptionId === undefined) {
            throw new Error("'subscriptionId' cannot be null");
        }
        // Initializing default values for options
        if (!options) {
            options = {};
        }
        const defaults = {
            requestContentType: "application/json; charset=utf-8",
            credential: credentials
        };
        const packageDetails = `azsdk-js-arm-network/26.0.0`;
        const userAgentPrefix = options.userAgentOptions && options.userAgentOptions.userAgentPrefix
            ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}`
            : `${packageDetails}`;
        if (!options.credentialScopes) {
            options.credentialScopes = ["https://management.azure.com/.default"];
        }
        const optionsWithDefaults = Object.assign(Object.assign(Object.assign({}, defaults), options), { userAgentOptions: {
                userAgentPrefix
            }, baseUri: options.endpoint || "https://management.azure.com" });
        super(optionsWithDefaults);
        // Parameter assignments
        this.subscriptionId = subscriptionId;
        // Assigning values to Constant parameters
        this.$host = options.$host || "https://management.azure.com";
        this.applicationGateways = new ApplicationGatewaysImpl(this);
        this.applicationGatewayPrivateLinkResources = new ApplicationGatewayPrivateLinkResourcesImpl(this);
        this.applicationGatewayPrivateEndpointConnections = new ApplicationGatewayPrivateEndpointConnectionsImpl(this);
        this.applicationSecurityGroups = new ApplicationSecurityGroupsImpl(this);
        this.availableDelegations = new AvailableDelegationsImpl(this);
        this.availableResourceGroupDelegations = new AvailableResourceGroupDelegationsImpl(this);
        this.availableServiceAliases = new AvailableServiceAliasesImpl(this);
        this.azureFirewalls = new AzureFirewallsImpl(this);
        this.azureFirewallFqdnTags = new AzureFirewallFqdnTagsImpl(this);
        this.webCategories = new WebCategoriesImpl(this);
        this.bastionHosts = new BastionHostsImpl(this);
        this.networkInterfaces = new NetworkInterfacesImpl(this);
        this.publicIPAddresses = new PublicIPAddressesImpl(this);
        this.customIPPrefixes = new CustomIPPrefixesImpl(this);
        this.ddosCustomPolicies = new DdosCustomPoliciesImpl(this);
        this.ddosProtectionPlans = new DdosProtectionPlansImpl(this);
        this.dscpConfigurationOperations = new DscpConfigurationOperationsImpl(this);
        this.availableEndpointServices = new AvailableEndpointServicesImpl(this);
        this.expressRouteCircuitAuthorizations = new ExpressRouteCircuitAuthorizationsImpl(this);
        this.expressRouteCircuitPeerings = new ExpressRouteCircuitPeeringsImpl(this);
        this.expressRouteCircuitConnections = new ExpressRouteCircuitConnectionsImpl(this);
        this.peerExpressRouteCircuitConnections = new PeerExpressRouteCircuitConnectionsImpl(this);
        this.expressRouteCircuits = new ExpressRouteCircuitsImpl(this);
        this.expressRouteServiceProviders = new ExpressRouteServiceProvidersImpl(this);
        this.expressRouteCrossConnections = new ExpressRouteCrossConnectionsImpl(this);
        this.expressRouteCrossConnectionPeerings = new ExpressRouteCrossConnectionPeeringsImpl(this);
        this.expressRoutePortsLocations = new ExpressRoutePortsLocationsImpl(this);
        this.expressRoutePorts = new ExpressRoutePortsImpl(this);
        this.expressRouteLinks = new ExpressRouteLinksImpl(this);
        this.firewallPolicies = new FirewallPoliciesImpl(this);
        this.firewallPolicyRuleCollectionGroups = new FirewallPolicyRuleCollectionGroupsImpl(this);
        this.firewallPolicyIdpsSignatures = new FirewallPolicyIdpsSignaturesImpl(this);
        this.firewallPolicyIdpsSignaturesOverrides = new FirewallPolicyIdpsSignaturesOverridesImpl(this);
        this.firewallPolicyIdpsSignaturesFilterValues = new FirewallPolicyIdpsSignaturesFilterValuesImpl(this);
        this.ipAllocations = new IpAllocationsImpl(this);
        this.ipGroups = new IpGroupsImpl(this);
        this.loadBalancers = new LoadBalancersImpl(this);
        this.loadBalancerBackendAddressPools = new LoadBalancerBackendAddressPoolsImpl(this);
        this.loadBalancerFrontendIPConfigurations = new LoadBalancerFrontendIPConfigurationsImpl(this);
        this.inboundNatRules = new InboundNatRulesImpl(this);
        this.loadBalancerLoadBalancingRules = new LoadBalancerLoadBalancingRulesImpl(this);
        this.loadBalancerOutboundRules = new LoadBalancerOutboundRulesImpl(this);
        this.loadBalancerNetworkInterfaces = new LoadBalancerNetworkInterfacesImpl(this);
        this.loadBalancerProbes = new LoadBalancerProbesImpl(this);
        this.natGateways = new NatGatewaysImpl(this);
        this.networkInterfaceIPConfigurations = new NetworkInterfaceIPConfigurationsImpl(this);
        this.networkInterfaceLoadBalancers = new NetworkInterfaceLoadBalancersImpl(this);
        this.networkInterfaceTapConfigurations = new NetworkInterfaceTapConfigurationsImpl(this);
        this.networkProfiles = new NetworkProfilesImpl(this);
        this.networkSecurityGroups = new NetworkSecurityGroupsImpl(this);
        this.securityRules = new SecurityRulesImpl(this);
        this.defaultSecurityRules = new DefaultSecurityRulesImpl(this);
        this.networkVirtualAppliances = new NetworkVirtualAppliancesImpl(this);
        this.virtualApplianceSites = new VirtualApplianceSitesImpl(this);
        this.virtualApplianceSkus = new VirtualApplianceSkusImpl(this);
        this.inboundSecurityRuleOperations = new InboundSecurityRuleOperationsImpl(this);
        this.networkWatchers = new NetworkWatchersImpl(this);
        this.packetCaptures = new PacketCapturesImpl(this);
        this.connectionMonitors = new ConnectionMonitorsImpl(this);
        this.flowLogs = new FlowLogsImpl(this);
        this.operations = new OperationsImpl(this);
        this.privateEndpoints = new PrivateEndpointsImpl(this);
        this.availablePrivateEndpointTypes = new AvailablePrivateEndpointTypesImpl(this);
        this.privateDnsZoneGroups = new PrivateDnsZoneGroupsImpl(this);
        this.privateLinkServices = new PrivateLinkServicesImpl(this);
        this.publicIPPrefixes = new PublicIPPrefixesImpl(this);
        this.routeFilters = new RouteFiltersImpl(this);
        this.routeFilterRules = new RouteFilterRulesImpl(this);
        this.routeTables = new RouteTablesImpl(this);
        this.routes = new RoutesImpl(this);
        this.securityPartnerProviders = new SecurityPartnerProvidersImpl(this);
        this.bgpServiceCommunities = new BgpServiceCommunitiesImpl(this);
        this.serviceEndpointPolicies = new ServiceEndpointPoliciesImpl(this);
        this.serviceEndpointPolicyDefinitions = new ServiceEndpointPolicyDefinitionsImpl(this);
        this.serviceTags = new ServiceTagsImpl(this);
        this.serviceTagInformationOperations = new ServiceTagInformationOperationsImpl(this);
        this.usages = new UsagesImpl(this);
        this.virtualNetworks = new VirtualNetworksImpl(this);
        this.subnets = new SubnetsImpl(this);
        this.resourceNavigationLinks = new ResourceNavigationLinksImpl(this);
        this.serviceAssociationLinks = new ServiceAssociationLinksImpl(this);
        this.virtualNetworkPeerings = new VirtualNetworkPeeringsImpl(this);
        this.virtualNetworkGateways = new VirtualNetworkGatewaysImpl(this);
        this.virtualNetworkGatewayConnections = new VirtualNetworkGatewayConnectionsImpl(this);
        this.localNetworkGateways = new LocalNetworkGatewaysImpl(this);
        this.virtualNetworkGatewayNatRules = new VirtualNetworkGatewayNatRulesImpl(this);
        this.virtualNetworkTaps = new VirtualNetworkTapsImpl(this);
        this.virtualRouters = new VirtualRoutersImpl(this);
        this.virtualRouterPeerings = new VirtualRouterPeeringsImpl(this);
        this.virtualWans = new VirtualWansImpl(this);
        this.vpnSites = new VpnSitesImpl(this);
        this.vpnSiteLinks = new VpnSiteLinksImpl(this);
        this.vpnSitesConfiguration = new VpnSitesConfigurationImpl(this);
        this.vpnServerConfigurations = new VpnServerConfigurationsImpl(this);
        this.virtualHubs = new VirtualHubsImpl(this);
        this.hubVirtualNetworkConnections = new HubVirtualNetworkConnectionsImpl(this);
        this.vpnGateways = new VpnGatewaysImpl(this);
        this.vpnLinkConnections = new VpnLinkConnectionsImpl(this);
        this.vpnConnections = new VpnConnectionsImpl(this);
        this.vpnSiteLinkConnections = new VpnSiteLinkConnectionsImpl(this);
        this.natRules = new NatRulesImpl(this);
        this.p2SVpnGateways = new P2SVpnGatewaysImpl(this);
        this.vpnServerConfigurationsAssociatedWithVirtualWan = new VpnServerConfigurationsAssociatedWithVirtualWanImpl(this);
        this.virtualHubRouteTableV2S = new VirtualHubRouteTableV2SImpl(this);
        this.expressRouteGateways = new ExpressRouteGatewaysImpl(this);
        this.expressRouteConnections = new ExpressRouteConnectionsImpl(this);
        this.virtualHubBgpConnection = new VirtualHubBgpConnectionImpl(this);
        this.virtualHubBgpConnections = new VirtualHubBgpConnectionsImpl(this);
        this.virtualHubIpConfiguration = new VirtualHubIpConfigurationImpl(this);
        this.hubRouteTables = new HubRouteTablesImpl(this);
        this.routingIntentOperations = new RoutingIntentOperationsImpl(this);
        this.webApplicationFirewallPolicies = new WebApplicationFirewallPoliciesImpl(this);
    }
    /**
     * Creates a Bastion Shareable Links for all the VMs specified in the request.
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostName The name of the Bastion Host.
     * @param bslRequest Post request for all the Bastion Shareable Link endpoints.
     * @param options The options parameters.
     */
    beginListPutBastionShareableLinkAndWait(resourceGroupName, bastionHostName, bslRequest, options) {
        const iter = this.putBastionShareableLinkPagingAll(resourceGroupName, bastionHostName, bslRequest, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.putBastionShareableLinkPagingPage(resourceGroupName, bastionHostName, bslRequest, options);
            }
        };
    }
    putBastionShareableLinkPagingPage(resourceGroupName, bastionHostName, bslRequest, options) {
        return tslib.__asyncGenerator(this, arguments, function* putBastionShareableLinkPagingPage_1() {
            const poller = yield tslib.__await(this._putBastionShareableLink(resourceGroupName, bastionHostName, bslRequest, options));
            let result = yield tslib.__await(poller.pollUntilDone());
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._putBastionShareableLinkNext(resourceGroupName, bastionHostName, bslRequest, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    putBastionShareableLinkPagingAll(resourceGroupName, bastionHostName, bslRequest, options) {
        return tslib.__asyncGenerator(this, arguments, function* putBastionShareableLinkPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.putBastionShareableLinkPagingPage(resourceGroupName, bastionHostName, bslRequest, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Return the Bastion Shareable Links for all the VMs specified in the request.
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostName The name of the Bastion Host.
     * @param bslRequest Post request for all the Bastion Shareable Link endpoints.
     * @param options The options parameters.
     */
    listBastionShareableLink(resourceGroupName, bastionHostName, bslRequest, options) {
        const iter = this.getBastionShareableLinkPagingAll(resourceGroupName, bastionHostName, bslRequest, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.getBastionShareableLinkPagingPage(resourceGroupName, bastionHostName, bslRequest, options);
            }
        };
    }
    getBastionShareableLinkPagingPage(resourceGroupName, bastionHostName, bslRequest, options) {
        return tslib.__asyncGenerator(this, arguments, function* getBastionShareableLinkPagingPage_1() {
            let result = yield tslib.__await(this._getBastionShareableLink(resourceGroupName, bastionHostName, bslRequest, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._getBastionShareableLinkNext(resourceGroupName, bastionHostName, bslRequest, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    getBastionShareableLinkPagingAll(resourceGroupName, bastionHostName, bslRequest, options) {
        return tslib.__asyncGenerator(this, arguments, function* getBastionShareableLinkPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.getBastionShareableLinkPagingPage(resourceGroupName, bastionHostName, bslRequest, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Returns the list of currently active sessions on the Bastion.
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostName The name of the Bastion Host.
     * @param options The options parameters.
     */
    beginListActiveSessionsAndWait(resourceGroupName, bastionHostName, options) {
        const iter = this.getActiveSessionsPagingAll(resourceGroupName, bastionHostName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.getActiveSessionsPagingPage(resourceGroupName, bastionHostName, options);
            }
        };
    }
    getActiveSessionsPagingPage(resourceGroupName, bastionHostName, options) {
        return tslib.__asyncGenerator(this, arguments, function* getActiveSessionsPagingPage_1() {
            const poller = yield tslib.__await(this._getActiveSessions(resourceGroupName, bastionHostName, options));
            let result = yield tslib.__await(poller.pollUntilDone());
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._getActiveSessionsNext(resourceGroupName, bastionHostName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    getActiveSessionsPagingAll(resourceGroupName, bastionHostName, options) {
        return tslib.__asyncGenerator(this, arguments, function* getActiveSessionsPagingAll_1() {
            var e_3, _a;
            try {
                for (var _b = tslib.__asyncValues(this.getActiveSessionsPagingPage(resourceGroupName, bastionHostName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_3) throw e_3.error; }
            }
        });
    }
    /**
     * Returns the list of currently active sessions on the Bastion.
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostName The name of the Bastion Host.
     * @param sessionIds The list of sessionids to disconnect.
     * @param options The options parameters.
     */
    listDisconnectActiveSessions(resourceGroupName, bastionHostName, sessionIds, options) {
        const iter = this.disconnectActiveSessionsPagingAll(resourceGroupName, bastionHostName, sessionIds, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.disconnectActiveSessionsPagingPage(resourceGroupName, bastionHostName, sessionIds, options);
            }
        };
    }
    disconnectActiveSessionsPagingPage(resourceGroupName, bastionHostName, sessionIds, options) {
        return tslib.__asyncGenerator(this, arguments, function* disconnectActiveSessionsPagingPage_1() {
            let result = yield tslib.__await(this._disconnectActiveSessions(resourceGroupName, bastionHostName, sessionIds, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._disconnectActiveSessionsNext(resourceGroupName, bastionHostName, sessionIds, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    disconnectActiveSessionsPagingAll(resourceGroupName, bastionHostName, sessionIds, options) {
        return tslib.__asyncGenerator(this, arguments, function* disconnectActiveSessionsPagingAll_1() {
            var e_4, _a;
            try {
                for (var _b = tslib.__asyncValues(this.disconnectActiveSessionsPagingPage(resourceGroupName, bastionHostName, sessionIds, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_4) throw e_4.error; }
            }
        });
    }
    /**
     * Creates a Bastion Shareable Links for all the VMs specified in the request.
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostName The name of the Bastion Host.
     * @param bslRequest Post request for all the Bastion Shareable Link endpoints.
     * @param options The options parameters.
     */
    _putBastionShareableLink(resourceGroupName, bastionHostName, bslRequest, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, bastionHostName, bslRequest, options }, putBastionShareableLinkOperationSpec);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Deletes the Bastion Shareable Links for all the VMs specified in the request.
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostName The name of the Bastion Host.
     * @param bslRequest Post request for all the Bastion Shareable Link endpoints.
     * @param options The options parameters.
     */
    beginDeleteBastionShareableLink(resourceGroupName, bastionHostName, bslRequest, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, bastionHostName, bslRequest, options }, deleteBastionShareableLinkOperationSpec);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Deletes the Bastion Shareable Links for all the VMs specified in the request.
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostName The name of the Bastion Host.
     * @param bslRequest Post request for all the Bastion Shareable Link endpoints.
     * @param options The options parameters.
     */
    beginDeleteBastionShareableLinkAndWait(resourceGroupName, bastionHostName, bslRequest, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDeleteBastionShareableLink(resourceGroupName, bastionHostName, bslRequest, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Return the Bastion Shareable Links for all the VMs specified in the request.
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostName The name of the Bastion Host.
     * @param bslRequest Post request for all the Bastion Shareable Link endpoints.
     * @param options The options parameters.
     */
    _getBastionShareableLink(resourceGroupName, bastionHostName, bslRequest, options) {
        return this.sendOperationRequest({ resourceGroupName, bastionHostName, bslRequest, options }, getBastionShareableLinkOperationSpec);
    }
    /**
     * Returns the list of currently active sessions on the Bastion.
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostName The name of the Bastion Host.
     * @param options The options parameters.
     */
    _getActiveSessions(resourceGroupName, bastionHostName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, bastionHostName, options }, getActiveSessionsOperationSpec);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Returns the list of currently active sessions on the Bastion.
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostName The name of the Bastion Host.
     * @param sessionIds The list of sessionids to disconnect.
     * @param options The options parameters.
     */
    _disconnectActiveSessions(resourceGroupName, bastionHostName, sessionIds, options) {
        return this.sendOperationRequest({ resourceGroupName, bastionHostName, sessionIds, options }, disconnectActiveSessionsOperationSpec);
    }
    /**
     * Checks whether a domain name in the cloudapp.azure.com zone is available for use.
     * @param location The location of the domain name.
     * @param domainNameLabel The domain name to be verified. It must conform to the following regular
     *                        expression: ^[a-z][a-z0-9-]{1,61}[a-z0-9]$.
     * @param options The options parameters.
     */
    checkDnsNameAvailability(location, domainNameLabel, options) {
        return this.sendOperationRequest({ location, domainNameLabel, options }, checkDnsNameAvailabilityOperationSpec);
    }
    /**
     * Gives the supported security providers for the virtual wan.
     * @param resourceGroupName The resource group name.
     * @param virtualWANName The name of the VirtualWAN for which supported security providers are needed.
     * @param options The options parameters.
     */
    supportedSecurityProviders(resourceGroupName, virtualWANName, options) {
        return this.sendOperationRequest({ resourceGroupName, virtualWANName, options }, supportedSecurityProvidersOperationSpec);
    }
    /**
     * Generates a unique VPN profile for P2S clients for VirtualWan and associated VpnServerConfiguration
     * combination in the specified resource group.
     * @param resourceGroupName The resource group name.
     * @param virtualWANName The name of the VirtualWAN whose associated VpnServerConfigurations is needed.
     * @param vpnClientParams Parameters supplied to the generate VirtualWan VPN profile generation
     *                        operation.
     * @param options The options parameters.
     */
    beginGeneratevirtualwanvpnserverconfigurationvpnprofile(resourceGroupName, virtualWANName, vpnClientParams, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, virtualWANName, vpnClientParams, options }, generatevirtualwanvpnserverconfigurationvpnprofileOperationSpec);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Generates a unique VPN profile for P2S clients for VirtualWan and associated VpnServerConfiguration
     * combination in the specified resource group.
     * @param resourceGroupName The resource group name.
     * @param virtualWANName The name of the VirtualWAN whose associated VpnServerConfigurations is needed.
     * @param vpnClientParams Parameters supplied to the generate VirtualWan VPN profile generation
     *                        operation.
     * @param options The options parameters.
     */
    beginGeneratevirtualwanvpnserverconfigurationvpnprofileAndWait(resourceGroupName, virtualWANName, vpnClientParams, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginGeneratevirtualwanvpnserverconfigurationvpnprofile(resourceGroupName, virtualWANName, vpnClientParams, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * PutBastionShareableLinkNext
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostName The name of the Bastion Host.
     * @param bslRequest Post request for all the Bastion Shareable Link endpoints.
     * @param nextLink The nextLink from the previous successful call to the PutBastionShareableLink
     *                 method.
     * @param options The options parameters.
     */
    _putBastionShareableLinkNext(resourceGroupName, bastionHostName, bslRequest, nextLink, options) {
        return this.sendOperationRequest({ resourceGroupName, bastionHostName, bslRequest, nextLink, options }, putBastionShareableLinkNextOperationSpec);
    }
    /**
     * GetBastionShareableLinkNext
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostName The name of the Bastion Host.
     * @param bslRequest Post request for all the Bastion Shareable Link endpoints.
     * @param nextLink The nextLink from the previous successful call to the GetBastionShareableLink
     *                 method.
     * @param options The options parameters.
     */
    _getBastionShareableLinkNext(resourceGroupName, bastionHostName, bslRequest, nextLink, options) {
        return this.sendOperationRequest({ resourceGroupName, bastionHostName, bslRequest, nextLink, options }, getBastionShareableLinkNextOperationSpec);
    }
    /**
     * GetActiveSessionsNext
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostName The name of the Bastion Host.
     * @param nextLink The nextLink from the previous successful call to the GetActiveSessions method.
     * @param options The options parameters.
     */
    _getActiveSessionsNext(resourceGroupName, bastionHostName, nextLink, options) {
        return this.sendOperationRequest({ resourceGroupName, bastionHostName, nextLink, options }, getActiveSessionsNextOperationSpec);
    }
    /**
     * DisconnectActiveSessionsNext
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostName The name of the Bastion Host.
     * @param sessionIds The list of sessionids to disconnect.
     * @param nextLink The nextLink from the previous successful call to the DisconnectActiveSessions
     *                 method.
     * @param options The options parameters.
     */
    _disconnectActiveSessionsNext(resourceGroupName, bastionHostName, sessionIds, nextLink, options) {
        return this.sendOperationRequest({ resourceGroupName, bastionHostName, sessionIds, nextLink, options }, disconnectActiveSessionsNextOperationSpec);
    }
}
// Operation Specifications
const serializer$1M = coreClient.createSerializer(Mappers, /* isXml */ false);
const putBastionShareableLinkOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/bastionHosts/{bastionHostName}/createShareableLinks",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: BastionShareableLinkListResult
        },
        201: {
            bodyMapper: BastionShareableLinkListResult
        },
        202: {
            bodyMapper: BastionShareableLinkListResult
        },
        204: {
            bodyMapper: BastionShareableLinkListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: bslRequest,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        bastionHostName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1M
};
const deleteBastionShareableLinkOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/bastionHosts/{bastionHostName}/deleteShareableLinks",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: bslRequest,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        bastionHostName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1M
};
const getBastionShareableLinkOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/bastionHosts/{bastionHostName}/getShareableLinks",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: BastionShareableLinkListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: bslRequest,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        bastionHostName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1M
};
const getActiveSessionsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/bastionHosts/{bastionHostName}/getActiveSessions",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: BastionActiveSessionListResult
        },
        201: {
            bodyMapper: BastionActiveSessionListResult
        },
        202: {
            bodyMapper: BastionActiveSessionListResult
        },
        204: {
            bodyMapper: BastionActiveSessionListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        bastionHostName
    ],
    headerParameters: [accept],
    serializer: serializer$1M
};
const disconnectActiveSessionsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/bastionHosts/{bastionHostName}/disconnectActiveSessions",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: BastionSessionDeleteResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: sessionIds,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        bastionHostName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1M
};
const checkDnsNameAvailabilityOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/locations/{location}/CheckDnsNameAvailability",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DnsNameAvailabilityResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, domainNameLabel],
    urlParameters: [
        $host,
        subscriptionId,
        location
    ],
    headerParameters: [accept],
    serializer: serializer$1M
};
const supportedSecurityProvidersOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualWans/{virtualWANName}/supportedSecurityProviders",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualWanSecurityProviders
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualWANName
    ],
    headerParameters: [accept],
    serializer: serializer$1M
};
const generatevirtualwanvpnserverconfigurationvpnprofileOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualWans/{virtualWANName}/GenerateVpnProfile",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: VpnProfileResponse
        },
        201: {
            bodyMapper: VpnProfileResponse
        },
        202: {
            bodyMapper: VpnProfileResponse
        },
        204: {
            bodyMapper: VpnProfileResponse
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: vpnClientParams,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualWANName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1M
};
const putBastionShareableLinkNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: BastionShareableLinkListResult
        },
        202: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        bastionHostName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1M
};
const getBastionShareableLinkNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: BastionShareableLinkListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        bastionHostName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1M
};
const getActiveSessionsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: BastionActiveSessionListResult
        },
        202: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        bastionHostName
    ],
    headerParameters: [accept],
    serializer: serializer$1M
};
const disconnectActiveSessionsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: BastionSessionDeleteResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        bastionHostName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1M
};

exports.NetworkManagementClient = NetworkManagementClient;
//# sourceMappingURL=index.js.map
